\documentclass{article}
\usepackage[backend=biber,natbib=true,style=alphabetic,maxbibnames=50]{biblatex}
\addbibresource{/home/nqbh/reference/bib.bib}
\usepackage[utf8]{vietnam}
\usepackage{tocloft}
\renewcommand{\cftsecleader}{\cftdotfill{\cftdotsep}}
\usepackage[colorlinks=true,linkcolor=blue,urlcolor=red,citecolor=magenta]{hyperref}
\usepackage{amsmath,amssymb,amsthm,enumitem,float,graphicx,mathtools,tikz}
\usetikzlibrary{angles,calc,intersections,matrix,patterns,quotes,shadings}
\allowdisplaybreaks
\newtheorem{assumption}{Assumption}
\newtheorem{baitoan}{Bài toán}
\newtheorem{cauhoi}{Câu hỏi}
\newtheorem{conjecture}{Conjecture}
\newtheorem{corollary}{Corollary}
\newtheorem{dangtoan}{Dạng toán}
\newtheorem{definition}{Definition}
\newtheorem{dinhly}{Định lý}
\newtheorem{dinhnghia}{Định nghĩa}
\newtheorem{example}{Example}
\newtheorem{ghichu}{Ghi chú}
\newtheorem{hequa}{Hệ quả}
\newtheorem{hypothesis}{Hypothesis}
\newtheorem{lemma}{Lemma}
\newtheorem{luuy}{Lưu ý}
\newtheorem{nhanxet}{Nhận xét}
\newtheorem{notation}{Notation}
\newtheorem{note}{Note}
\newtheorem{principle}{Principle}
\newtheorem{problem}{Problem}
\newtheorem{proposition}{Proposition}
\newtheorem{question}{Question}
\newtheorem{remark}{Remark}
\newtheorem{theorem}{Theorem}
\newtheorem{vidu}{Ví dụ}
\usepackage[left=1cm,right=1cm,top=5mm,bottom=5mm,footskip=4mm]{geometry}
\def\labelitemii{$\circ$}
\DeclareRobustCommand{\divby}{%
    \mathrel{\vbox{\baselineskip.65ex\lineskiplimit0pt\hbox{.}\hbox{.}\hbox{.}}}%
}
\setlist[itemize]{leftmargin=*}
\setlist[enumerate]{leftmargin=*}

\title{Course Project: Combinatorics {\it\&} Graph Theory\\Đồ Án Môn Học: Tổ Hợp {\it\&} Lý Thuyết Đồ Thị}
\author{Nguyễn Quản Bá Hồng\footnote{A scientist- {\it\&} creative artist wannabe, a mathematics {\it\&} computer science lecturer of Department of Artificial Intelligence {\it\&} Data Science (AIDS), School of Technology (SOT), UMT Trường Đại học Quản lý {\it\&} Công nghệ TP.HCM, Hồ Chí Minh City, Việt Nam.\\E-mail: {\sf nguyenquanbahong@gmail.com} {\it\&} {\sf hong.nguyenquanba@umt.edu.vn}. Website: \url{https://nqbh.github.io/}. GitHub: \url{https://github.com/NQBH}.}}
\date{\today}

\begin{document}
\maketitle
\begin{abstract}
    This text is a part of the series {\it Some Topics in Advanced STEM \& Beyond}:
    
    {\sc url}: \url{https://nqbh.github.io/advanced_STEM/}.
    
    Latest version:
    \begin{itemize}
        \item {\it Course Project: Combinatorics \& Graph Theory -- Đồ Án Môn Học: Tổ Hợp \& Lý Thuyết Đồ Thị}.
        
        PDF: {\sc url}: \url{https://github.com/NQBH/advanced_STEM_beyond/blob/main/combinatorics/project/NQBH_combinatorics_graph_theory_project.pdf}.
        
        \TeX: {\sc url}: \url{https://github.com/NQBH/advanced_STEM_beyond/blob/main/combinatorics/project/NQBH_combinatorics_graph_theory_project.tex}.
        \item {\it Lecture Note: Combinatorics \& Graph Theory -- Bài Giảng: Tổ Hợp \& Lý Thuyết Đồ Thị}.
        
        PDF: {\sc url}: \url{https://github.com/NQBH/advanced_STEM_beyond/blob/main/combinatorics/lecture/NQBH_combinatorics_graph_theory_lecture.pdf}.
        
        \TeX: {\sc url}: \url{https://github.com/NQBH/advanced_STEM_beyond/blob/main/combinatorics/lecture/NQBH_combinatorics_graph_theory_lecture.tex}.
        \item {\it Slide: Combinatorics \& Graph Theory -- Slide Bài Giảng: Tổ Hợp \& Lý Thuyết Đồ Thị}.
        
        PDF: {\sc url}: \url{https://github.com/NQBH/advanced_STEM_beyond/blob/main/combinatorics/slide/NQBH_combinatorics_graph_theory_slide.pdf}.
        
        \TeX: {\sc url}: \url{https://github.com/NQBH/advanced_STEM_beyond/blob/main/combinatorics/slide/NQBH_combinatorics_graph_theory_slide.tex}.
        \item {\it Survey: Combinatorics \& Graph Theory -- Khảo Sát: Tổ Hợp \& Lý Thuyết Đồ Thị}.
        
        PDF: {\sc url}: \url{https://github.com/NQBH/advanced_STEM_beyond/blob/main/combinatorics/NQBH_combinatorics.pdf}.
        
        \TeX: {\sc url}: \url{https://github.com/NQBH/advanced_STEM_beyond/blob/main/combinatorics/NQBH_combinatorics.tex}.
        \item Codes:
        \begin{itemize}
            \item C{\tt/}C++: \url{https://github.com/NQBH/advanced_STEM_beyond/blob/main/combinatorics/C++}.
            \item Pascal: \url{https://github.com/NQBH/advanced_STEM_beyond/blob/main/combinatorics/Pascal}.
            \item Python: \url{https://github.com/NQBH/advanced_STEM_beyond/blob/main/combinatorics/Python}.
        \end{itemize}
    \end{itemize}
\end{abstract}
\tableofcontents

%------------------------------------------------------------------------------%

\section*{Rules}

\begin{enumerate}
    \item Chấp{\tt/}Cho phép sử dụng AIs.
    \item Các đồ án nên được trình bày chi tiết nhất có thể, về cả 3 phương diện Toán học, thuật toán, \& lập trình:
    \begin{itemize}
        \item Derivation của các công thức đệ quy, quy hoạch động.
        \item Giải thích code, ý nghĩa của các biến quan trọng, i.e., các biến số chính đại diện cho đại lượng nào.
    \end{itemize}
    \item Gửi kèm codes chạy được với đồ án.
    \item Ưu tiên nộp đồ án theo 1 GitHub repository để tiện {\tt git clone}.
    \item Đồ án môn học được thực hiện theo cá nhân mỗi sinh viên, không thực hiện theo nhóm. Khi nộp sẽ có vấn đáp để kiểm tra khả năng \& mức độ thấu hiểu vấn đề cũng như các phương pháp \& thuật toán mà sinh viên sử dụng trong đồ án của mình.
    \item Mỗi sinh viên làm tất cả các đồ án.
\end{enumerate}
\textbf{\textsf{Resources -- Tài nguyên.}}
\begin{enumerate}
    \item \cite{Balakrishnan1997}. {\sc V. K. Balakrishnan}. {\it Schaum's Outline of Graph Theory}.
    
    \item \cite{Goldengorin2018}. {\sc Boris Goldengorin}. {\it Optimization Problems in Graph Theory}.
    
    \item \cite{Shahriari2022}. {\sc Shahriar Shahriari}. {\it An Invitation To Combinatorics}.
    
    \item \cite{Valiente2002, Valiente2021}. {\sc Gabriel Valiente}. {\it Algorithms on Trees \& Graphs With Python Code}.
\end{enumerate}

%------------------------------------------------------------------------------%

\section{Project 1: Mathematical Induction {\it\&} Recurrence Relations -- Đồ Án 1: Quy Nạp Toán Học {\it\&} Quan Hệ Truy Hồi}

%------------------------------------------------------------------------------%

\section{Project 2: Counting, Probability, Balls, \& Boxes -- Đồ Án 2: Đếm, Xác Suất, Banh \& Hộp}

%------------------------------------------------------------------------------%

\section{Project 3: Generating Functions -- Đồ Án 3: Hàm Sinh}

%------------------------------------------------------------------------------%
\section{Project: Integer Partition -- Đồ Án: Phân Hoạch Số Nguyên}

\begin{baitoan}[Ferrers \& Ferrers transpose diagrams -- Biểu đồ Ferrers \& biểu đồ Ferrers chuyển vị]
    Nhập $n,k\in\mathbb{N}$. Viết chương trình {\sf C{\tt/}C++, Python} để in ra $p_k(n)$ biểu đồ Ferrers $F$ \& biểu đồ Ferrers chuyển vị $F^\top$ cho mỗi phân hoạch $\boldsymbol{\lambda} = (\lambda_1,\lambda_2,\ldots,\lambda_k)\in(\mathbb{N}^\star)^k$ có định dạng các dấu chấm được biểu diễn bởi dấu {\tt*}.
\end{baitoan}

\begin{baitoan}
    Nhập $n,k\in\mathbb{N}$. Đếm số phân hoạch của $n\in\mathbb{N}$. Viết chương trình {\sf C{\tt/}C++, Python} để đếm số phân hoạch $p_{\max}(n,k)$ của $n$ sao cho phần tử lớn nhất là $k$. So sánh $p_k(n)$ \& $p_{\max}(n,k)$.
\end{baitoan}

\begin{baitoan}[Số phân hoạch tự liên hợp]
    Nhập $n,k\in\mathbb{N}$. (a) Đếm số phân hoạch tự liên hợp của $n$ có $k$ phần, ký hiệu $p_k^{\rm selfcjg}(n)$, rồi in ra các phân hoạch đó. (b) Đếm số phân hoạch của $n$ có lẻ phần, rồi so sánh với $p_k^{\rm selfcjg}(n)$. (c) Thiết lập công thức truy hồi cho $p_k^{\rm selfcjg}(n)$, rồi implementation bằng: (i) đệ quy. (ii) quy hoạch động.
\end{baitoan}

%------------------------------------------------------------------------------%

\section{Project 4: Graph \& Tree Traversing Problems -- Đồ Án 4: Các Bài Toán Duyệt Đồ Thị \& Cây}
Đọc \cite[1.3: Representation of Trees \& Graphs, p. 23]{Valiente2021}.
\begin{baitoan}
    Viết chương trình {\sf C{\tt/}C++, Python} chuyển đổi giữa 4 dạng biểu diễn: adjacency matrix, adjacency list, extended adjacency list, adjacency map cho $3$ đồ thị: đơn đồ thị, đa đồ thị, đồ thị tổng quát; \& 3 dạng biểu diễn: array of parents, first-child next-sibling, graph-based representation of trees của cây.
\end{baitoan}
Sẽ có $3A_4^3 + A_3^2 = 36 + 6 = 42$ converter programs.

\begin{baitoan}
    Làm Problems 1.1--1.6 \& Exercises 1.1--1.10 \cite[pp. 39--40]{Valiente2021}.
\end{baitoan}

\begin{baitoan}[Tree edit distance]
    Viết chương trình {\sf C{\tt/}C++, Python} để giải bài toán tree edit distance problem bằng cách sử dụng: (a) Backtracking. (b) Branch-\&-bound. (c) Divide-\&-conquer -- chia để trị. (d) Dynamic programming -- Quy hoạch động.
\end{baitoan}

\begin{baitoan}[Tree traversal -- Duyệt cây]
    Viết chương trình {\sf C{\tt/}C++, Python} để duyệt cây: (a) preorder traversal. (b) postorder traversal. (c) top-down traveral. (d) bottom-up traversal.
\end{baitoan}

%------------------------------------------------------------------------------%

\subsection{Breadth-first search algorithm -- Thuật toán tìm kiếm theo chiều rộng}

\begin{baitoan}
    Let $G = (V,E)$ be a finite simple graph. Implement the breadth-first search on $G$.
\end{baitoan}

\begin{baitoan}
    Let $G = (V,E)$ be a finite multigraph. Implement the breadth-first search on $G$.
\end{baitoan}

\begin{baitoan}
    Let $G = (V,E)$ be a general graph. Implement the breadth-first search on $G$.
\end{baitoan}

%------------------------------------------------------------------------------%

\subsection{Depth-first search algorithm -- Thuật toán tìm kiếm theo chiều rộng}

\begin{baitoan}
    Let $G = (V,E)$ be a finite simple graph. Implement the depth-first search on $G$.
\end{baitoan}

\begin{baitoan}
    Let $G = (V,E)$ be a finite multigraph. Implement the depth-first search on $G$.
\end{baitoan}

\begin{baitoan}
    Let $G = (V,E)$ be a general graph. Implement the depth-first search on $G$.
\end{baitoan}

%------------------------------------------------------------------------------%

\section{Project 5: Shortest Path Problems on Graphs -- Đồ Án 5: Các Bài Toán Tìm Đường Đi Ngắn Nhất Trên Đồ Thị}
\textbf{\textsf{Resources -- Tài nguyên.}}
\begin{enumerate}
    \item \href{https://en.wikipedia.org/wiki/Shortest_path_problem}{Wikipedia{\tt/}shortest path problem}.
\end{enumerate}

%------------------------------------------------------------------------------%

\subsection{Dijkstra's algorithm -- Thuật toán Dijkstra}

\begin{baitoan}
    Let $G = (V,E)$ be a finite simple graph. Implement the Dijkstra's algorithm to find the shortest path problem on $G$.
\end{baitoan}

\begin{baitoan}
    Let $G = (V,E)$ be a finite multigraph. Implement the Dijkstra's algorithm to find the shortest path problem on $G$.
\end{baitoan}

\begin{baitoan}
    Let $G = (V,E)$ be a general graph. Implement the Dijkstra's algorithm to find the shortest path problem on $G$.
\end{baitoan}

%------------------------------------------------------------------------------%

\subsection{Bellman--Ford algorithm -- Thuật toán Bellman--Ford}

\begin{baitoan}
    Let $G = (V,E)$ be a finite simple graph. Implement the Bellman--Ford algorithm to find the shortest path problem on $G$.
\end{baitoan}

\begin{baitoan}
    Let $G = (V,E)$ be a finite multigraph. Implement the Bellman--Ford algorithm to find the shortest path problem on $G$.
\end{baitoan}

\begin{baitoan}
    Let $G = (V,E)$ be a general graph. Implement the Bellman--Ford algorithm to find the shortest path problem on $G$.
\end{baitoan}

%------------------------------------------------------------------------------%

\subsection{$\rm A^*$ algorithm -- Thuật toán $\rm A^*$}

\begin{baitoan}
    Let $G = (V,E)$ be a finite simple graph. Implement the $\rm A^*$ algorithm to find the shortest path problem on $G$.
\end{baitoan}

\begin{baitoan}
    Let $G = (V,E)$ be a finite multigraph. Implement the $\rm A^*$ algorithm to find the shortest path problem on $G$.
\end{baitoan}

\begin{baitoan}
    Let $G = (V,E)$ be a general graph. Implement the $\rm A^*$ algorithm to find the shortest path problem on $G$.
\end{baitoan}

%------------------------------------------------------------------------------%

\subsection{Floyd--Warshall algorithm -- Thuật toán Floyd--Warshall}

\begin{baitoan}
    Let $G = (V,E)$ be a finite simple graph. Implement the Floyd--Warshall algorithm to find the shortest path problem on $G$.
\end{baitoan}

\begin{baitoan}
    Let $G = (V,E)$ be a finite multigraph. Implement the Floyd--Warshall algorithm to find the shortest path problem on $G$.
\end{baitoan}

\begin{baitoan}
    Let $G = (V,E)$ be a general graph. Implement the Floyd--Warshall algorithm to find the shortest path problem on $G$.
\end{baitoan}

%------------------------------------------------------------------------------%

\subsection{Optional: Johnson's algorithm -- Thuật toán Johnson}

\begin{baitoan}
    Let $G = (V,E)$ be a finite simple graph. Implement the Johnson's algorithm to find the shortest path problem on $G$.
\end{baitoan}

\begin{baitoan}
    Let $G = (V,E)$ be a finite multigraph. Implement the Johnson's algorithm to find the shortest path problem on $G$.
\end{baitoan}

\begin{baitoan}
    Let $G = (V,E)$ be a general graph. Implement the Johnson's algorithm to find the shortest path problem on $G$.
\end{baitoan}

%------------------------------------------------------------------------------%

\subsection{Optional: Viterbi's algorithm -- Thuật toán Viterbi}

\begin{baitoan}
    Let $G = (V,E)$ be a finite simple graph. Implement the Viterbi's algorithm to find the shortest path problem on $G$.
\end{baitoan}

\begin{baitoan}
    Let $G = (V,E)$ be a finite multigraph. Implement the Viterbi's algorithm to find the shortest path problem on $G$.
\end{baitoan}

\begin{baitoan}
    Let $G = (V,E)$ be a general graph. Implement the Viterbi's algorithm to find the shortest path problem on $G$.
\end{baitoan}

%------------------------------------------------------------------------------%

\section{Miscellaneous}

%------------------------------------------------------------------------------%

\printbibliography[heading=bibintoc]
    
\end{document}