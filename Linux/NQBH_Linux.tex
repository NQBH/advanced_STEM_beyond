\documentclass{article}
\usepackage[backend=biber,natbib=true,style=alphabetic,maxbibnames=50]{biblatex}
\addbibresource{/home/nqbh/reference/bib.bib}
\usepackage[utf8]{vietnam}
\usepackage{tocloft}
\renewcommand{\cftsecleader}{\cftdotfill{\cftdotsep}}
\usepackage[colorlinks=true,linkcolor=blue,urlcolor=red,citecolor=magenta]{hyperref}
\usepackage{amsmath,amssymb,amsthm,enumitem,float,graphicx,mathtools,tikz}
\usetikzlibrary{angles,calc,intersections,matrix,patterns,quotes,shadings}
\allowdisplaybreaks
\newtheorem{assumption}{Assumption}
\newtheorem{baitoan}{}
\newtheorem{cauhoi}{Câu hỏi}
\newtheorem{conjecture}{Conjecture}
\newtheorem{corollary}{Corollary}
\newtheorem{dangtoan}{Dạng toán}
\newtheorem{definition}{Definition}
\newtheorem{dinhly}{Định lý}
\newtheorem{dinhnghia}{Định nghĩa}
\newtheorem{example}{Example}
\newtheorem{ghichu}{Ghi chú}
\newtheorem{hequa}{Hệ quả}
\newtheorem{hypothesis}{Hypothesis}
\newtheorem{lemma}{Lemma}
\newtheorem{luuy}{Lưu ý}
\newtheorem{nhanxet}{Nhận xét}
\newtheorem{notation}{Notation}
\newtheorem{note}{Note}
\newtheorem{principle}{Principle}
\newtheorem{problem}{Problem}
\newtheorem{proposition}{Proposition}
\newtheorem{question}{Question}
\newtheorem{remark}{Remark}
\newtheorem{theorem}{Theorem}
\newtheorem{vidu}{Ví dụ}
\usepackage[left=1cm,right=1cm,top=5mm,bottom=5mm,footskip=4mm]{geometry}
\def\labelitemii{$\circ$}
\DeclareRobustCommand{\divby}{%
    \mathrel{\vbox{\baselineskip.65ex\lineskiplimit0pt\hbox{.}\hbox{.}\hbox{.}}}%
}
\setlist[itemize]{leftmargin=*}
\setlist[enumerate]{leftmargin=*}

\title{Linux}
\author{Nguyễn Quản Bá Hồng\footnote{A scientist- {\it\&} creative artist wannabe, a mathematics {\it\&} computer science lecturer of Department of Artificial Intelligence {\it\&} Data Science (AIDS), School of Technology (SOT), UMT Trường Đại học Quản lý {\it\&} Công nghệ TP.HCM, Hồ Chí Minh City, Việt Nam.\\E-mail: {\sf nguyenquanbahong@gmail.com} {\it\&} {\sf hong.nguyenquanba@umt.edu.vn}. Website: \url{https://nqbh.github.io/}. GitHub: \url{https://github.com/NQBH}.}}
\date{\today}

\begin{document}
\maketitle
\begin{abstract}
    This text is a part of the series {\it Some Topics in Advanced STEM \& Beyond}:
    
    {\sc url}: \url{https://nqbh.github.io/advanced_STEM/}.
    
    Latest version:
    \begin{itemize}
        \item {\it }.
        
        PDF: {\sc url}: \url{.pdf}.
        
        \TeX: {\sc url}: \url{.tex}.
        \item {\it }.
        
        PDF: {\sc url}: \url{.pdf}.
        
        \TeX: {\sc url}: \url{.tex}.
    \end{itemize}
\end{abstract}
\tableofcontents

%------------------------------------------------------------------------------%

\section{Linux Programming}

\subsection{\cite{Persson2021}. {\sc Jack-Benny Persson}. Linux System Programming Techniques: Become a Proficient Linux System Programmer Using Expert Recipes \& Techniques}

\begin{itemize}
    \item {\sf Amazon review.} Find solutions to all your problems related to Linux system programming using practical recipes for developing your own system programs.
    
    {\bf Key features.}
    \begin{itemize}
        \item Develop a deeper understanding of how Linux system programming works
        \item Gain hands-on experience of working with different Linux projects with help of practical examples
        \item Learn how to develop your own programs for Linux
    \end{itemize}
    \item {\sf About Author.} {\sc Jack-Benny Persson} is a consultant \& author based in Sweden. He has written several books about Linux \& programming. His passion for Linux \& other Unix-like systems started as a hobby $> 20$ years ago. Since then, he has spent most of his spare time reading about Linux, tinkering with Linux servers, \& writing about Linux administration. Today he has his own IT \& media company in Sweden that focuses in Linux. {\sc Jack-Benny} holds an Advanced Higher Vocational Education Diploma as a Linux system specialist. He has also studied electronics, networking, \& security.
    \item {\sf Preface.} Linux system programming is all about developing system programs for Linux OS. Linux is world's most popular open-source OS \& runs on everything from big servers to small Internet of Things (IoT) devices. Knowing how to write system programs for Linux will enable you to extend OS \& connect it with other programs \& systems.
    
    -- Lập trình hệ thống Linux là tất cả về việc phát triển các chương trình hệ thống cho HĐH Linux. Linux là HĐH nguồn mở phổ biến nhất thế giới \& chạy trên mọi thứ từ máy chủ lớn đến các thiết bị Internet vạn vật (IoT) nhỏ. Biết cách viết chương trình hệ thống cho Linux sẽ cho phép bạn mở rộng HĐH \& kết nối nó với các chương trình \& hệ thống khác.
    
    Start by learning how to make our programs easy to script \& easy to interact with other programs. When write system programs for Linux, should always strive to make them small \& do 1 thing only -- \& do it well. This is 1 of key concepts in Linux: to create small programs that can exchange data with each other in simple ways.
    
    -- Bắt đầu bằng cách học cách làm cho chương trình của chúng ta dễ viết kịch bản \& dễ tương tác với các chương trình khác. Khi viết chương trình hệ thống cho Linux, hãy luôn cố gắng làm cho chúng nhỏ \& chỉ làm 1 việc -- \& làm tốt. Đây là 1 trong những khái niệm chính trong Linux: tạo các chương trình nhỏ có thể trao đổi dữ liệu với nhau theo những cách đơn giản.
    
    Take a deep dive into C \& look at how compiler works, what linker does, how to write Makefiles, \& much more.
    
    -- Tìm hiểu sâu hơn về C \& xem trình biên dịch hoạt động như thế nào, trình liên kết thực hiện chức năng gì, cách viết Makefile, \& nhiều hơn nữa.
    
    Learn all about forking \& daemons. Also create our own daemon. Then put our daemon under {\tt systemd}'s control. This will enable us to start, stop, \& restart daemon using built-in Linux tools.
    
    -- Tìm hiểu tất cả về forking \& daemon. Cũng như tạo daemon của riêng chúng ta. Sau đó, đặt daemon của chúng ta dưới sự kiểm soát của {\tt systemd}. Điều này sẽ cho phép chúng ta khởi động, dừng, \& khởi động lại daemon bằng các công cụ Linux tích hợp.
    
    Learn how to make our processes exchange information using different kinds of {\it Inter-Process Communication (IPC)}. Also take a look at how to write threaded programs.
    
    -- Tìm hiểu cách thực hiện các quy trình trao đổi thông tin bằng các loại Giao tiếp giữa các quy trình (IPC) khác nhau. Ngoài ra, hãy xem cách viết các chương trình có luồng.
    
    At end of this book, cover how to debug our programs using {\it GNU Debugger (GDB)} \& Valgrind. By end of this book, able to write a wide variety of system programs for Linux -- everything from filters to daemons.
    
    -- Vào cuối cuốn sách này, sẽ trình bày cách gỡ lỗi chương trình của chúng tôi bằng {\it GNU Debugger (GDB)} \& Valgrind. Vào cuối cuốn sách này, có thể viết nhiều chương trình hệ thống khác nhau cho Linux -- mọi thứ từ bộ lọc đến daemon.
    \begin{itemize}
        \item {\sf Who this book is for.} This book is intended for anyone who wants to develop system programs for Linux \& wants to have a deep understanding of Linux system. Anyone facing any issues related to a particular part of Linux system programming \& looking for some specific recipes or solutions can take advantage of this book.
        
        -- {\sf Cuốn sách này dành cho ai.} Cuốn sách này dành cho bất kỳ ai muốn phát triển chương trình hệ thống cho Linux \& muốn hiểu sâu về hệ thống Linux. Bất kỳ ai gặp phải bất kỳ vấn đề nào liên quan đến một phần cụ thể của lập trình hệ thống Linux \& đang tìm kiếm một số công thức hoặc giải pháp cụ thể đều có thể tận dụng cuốn sách này.
        \item {\sf What this book covers.} p. 2+++
        \item {\sf To get most out of this book.} To get most out of this book, need a basic understanding of Linux, some basic commands, be familiar with moving around filesystem, \& installing new programs. It would help if you also have a basic understanding of programming, preferably C language.
        
        -- Để tận dụng tối đa cuốn sách này, bạn cần có hiểu biết cơ bản về Linux, một số lệnh cơ bản, quen thuộc với việc di chuyển hệ thống tệp, \& cài đặt chương trình mới. Sẽ hữu ích nếu bạn cũng có hiểu biết cơ bản về lập trình, tốt nhất là ngôn ngữ C.
        
        Will need a Linux computer with root access -- either via {\tt su} or {\tt sudo} -- to complete all recipes. Also need to install GCC compiler, Make tool, GDB, Valgrind, \& some others smaller tools. Particular Linux distribution doesn't matter that much. There are installation instructions in book for these programs for Debian, Ubuntu, CentOS, Fedora, \& Red Hat.
        
        -- Sẽ cần một máy tính Linux có quyền truy cập root -- thông qua {\tt su} hoặc {\tt sudo} -- để hoàn thành tất cả các công thức. Cũng cần cài đặt trình biên dịch GCC, công cụ Make, GDB, Valgrind, \& một số công cụ nhỏ hơn khác. Bản phân phối Linux cụ thể không quan trọng lắm. Có hướng dẫn cài đặt trong sách cho các chương trình này dành cho Debian, Ubuntu, CentOS, Fedora, \& Red Hat.
        
        Can download example code files for this book from Github at \url{https://github.com/PacktPublishing/Linux-System-Programming-Techniques}.
        \item {\sf Conventions used.} There are a number of text conventions used throughout this book. {\tt Code in text}: Indicates code words in text, directories, filenames, file extensions, pathnames, dummy URLs, user input, \& so on, e.g., Copy {\tt libprime.so.1} to {\tt/usr/local/lib}.'' Any command-line input or output is written as follows:
        \begin{verbatim}
$> mkdir cube
$> cd cube
        \end{verbatim}
        In numbered listings, command-line input is set in bold. \verb|$>| characters indicate prompt \& aren't sth you should write, an example of a numbered listing:
        \begin{verbatim}
$> ./a.out
Hello, world!
        \end{verbatim}
        Long command lines that don't fit on a single line are broken up using \verb|\| character. This is same character as you use to break along lines in Linux shell. Line under it has a {\tt>} character to indicate: line is a continuation of prev line. {\tt>} character is not sth you should write; Linux shell will automatically put this character on a new line where last line was broken up with a \verb|\| character, e.g.:
        \begin{verbatim}
$> ./exist.sh /asdf &> /dev/null; \
> if [ $? -eq 3 ]; then echo "That doesn't exist"; fi
That doesn't exist
        \end{verbatim}
    \end{itemize}
    \item {\sf1. Getting Necessary Tools \& Writing 1st Linux Programs.} In this chap, install necessary tools on Linux system, e.g. GCC, GNU Make, GDB, \& Valgrind. Also try them out \& see how they work. Knowing how to use these tools is key to being a fast \& efficient developer. Then write our 1st programs -- Linux style. By understanding different parts of a C program, can easily interact with rest of system in a best practice manner. After that, learn how to use built-in manual pages (man pages for short) to look up commands, libraries, \& system calls -- a skill that we will need a lot throughout this book. Knowing how to look up things in relevant built-in manual page is often much faster -- \& more precise -- than searching internet for answers.
    
    -- Trong chương này, hãy cài đặt các công cụ cần thiết trên hệ thống Linux, ví dụ như GCC, GNU Make, GDB, \& Valgrind. Ngoài ra, hãy thử chúng \& xem chúng hoạt động như thế nào. Biết cách sử dụng các công cụ này là chìa khóa để trở thành một nhà phát triển nhanh \& hiệu quả. Sau đó, hãy viết các chương trình đầu tiên của chúng ta -- theo phong cách Linux. Bằng cách hiểu các phần khác nhau của một chương trình C, có thể dễ dàng tương tác với phần còn lại của hệ thống theo cách thực hành tốt nhất. Sau đó, hãy học cách sử dụng các trang hướng dẫn tích hợp (gọi tắt là man pages) để tra cứu các lệnh, thư viện, \& lệnh gọi hệ thống -- một kỹ năng mà chúng ta sẽ cần rất nhiều trong suốt cuốn sách này. Biết cách tra cứu mọi thứ trong trang hướng dẫn tích hợp có liên quan thường nhanh hơn nhiều -- \& chính xác hơn -- so với việc tìm kiếm câu trả lời trên internet.
    
    In this chap, cover recipes:
    \begin{itemize}
        \item Installing GCC \& GNU Make
        \item Installing GDB \& Valgrind
        \item Writing a simple C program for Linux
        \item Writing a program that parses command-line options
        \item Looking up information in built-in manual pages
        \item Searching manual for information
    \end{itemize}
    
    \begin{itemize}
        \item {\sf Technical requirements.} For this chap, need a computer with Linux already set up. It doesn't matter if it's a local machine or a remote machine. Particular distribution you use doesn't matter much either. Look at how to install necessary programs in Debian-based distributions, as well as Fedora-based distributions. Most of major Linux distributions are either Debian-based or Fedora-based.
        
        -- {\sf Yêu cầu kỹ thuật.} Đối với chương này, cần một máy tính đã cài đặt sẵn Linux. Không quan trọng là máy cục bộ hay máy từ xa. Bản phân phối cụ thể mà bạn sử dụng cũng không quan trọng lắm. Hãy xem cách cài đặt các chương trình cần thiết trong các bản phân phối dựa trên Debian cũng như các bản phân phối dựa trên Fedora. Hầu hết các bản phân phối Linux chính đều dựa trên Debian hoặc Fedora.
        
        Also be using a text editor a lot. Which one you choose is a matter of taste. 2 most common are {\tt vi, nano}, \& they are available pretty much everywhere.
        
        C files for this chap can be downloaded from \url{https://github.com/PacktPublishing/Linux-System-Programming-Techniques}, under {\tt ch1} directory. Filenames on Github correspond to filenames on this book. can also clone the entire repository to your computer with following command:
        \begin{verbatim}
$> git clone https://github.com/PacktPublishing/Linux-System-Programming-Techniques.git
        \end{verbatim}
        \item {\sf Installing GCC \& GNU Make.} In this sect, install essential tools, GCC, compiler. It's compiler that turns C source code into a binary program that we can run on system. All C code that we write will need to be compiled. Also install GNU Make, a tool that we will be using later on to automate how projects containing $> 1$ source file are compiled.
        
        -- {\sf Cài đặt GCC \& GNU Make.} Trong phần này, hãy cài đặt các công cụ thiết yếu, GCC, trình biên dịch. Đây là trình biên dịch chuyển mã nguồn C thành chương trình nhị phân mà chúng ta có thể chạy trên hệ thống. Tất cả mã C mà chúng ta viết sẽ cần được biên dịch. Ngoài ra, hãy cài đặt GNU Make, một công cụ mà chúng ta sẽ sử dụng sau này để tự động hóa cách biên dịch các dự án chứa $> 1$ tệp nguồn.
        
        Install what is called a {\it meta-package} or a group, a package that contains a collection of other packages. This meta-package includes both GCC, GNU Make, several manual pages, \& other programs \& libraries, which are nice to have when we're developing.
        
        -- Cài đặt cái gọi là meta-package hoặc nhóm, một gói chứa một tập hợp các gói khác. Meta-package này bao gồm cả GCC, GNU Make, một số trang hướng dẫn, \& các chương trình khác \& thư viện, rất hữu ích khi chúng ta đang phát triển.
        
        \begin{verbatim}
nqbh@nqbh:~/advanced_STEM_beyond/Linux/resource$ gcc --version
gcc (Ubuntu 14.2.0-19ubuntu2) 14.2.0
Copyright (C) 2024 Free Software Foundation, Inc.
This is free software; see the source for copying conditions.  There is NO
warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.

nqbh@nqbh:~/advanced_STEM_beyond/Linux/resource$ make -v
GNU Make 4.4.1
Built for x86_64-pc-linux-gnu
Copyright (C) 1988-2023 Free Software Foundation, Inc.
License GPLv3+: GNU GPL version 3 or later <https://gnu.org/licenses/gpl.html>
This is free software: you are free to change and redistribute it.
There is NO WARRANTY, to the extent permitted by law.
        \end{verbatim}
        
        
    \end{itemize}
    \item {\sf2. Making Programs Easy to Script.}
    \item {\sf3. Diving Deep into C in Linux.} Time to take an in-depth look at C programming in Linux. Learn more about compiler, 4 stages from source code to binary program, how to use Make tool, \& differences between system calls \& a standard library functions. Also take a look at some essential header files when it comes to Linux, \& look at some C \& Portable Operating System Interface (POSIX) standards. C is tightly integrated with Linux, \& mastering C will help you understand Linux.
    
    -- Đã đến lúc xem xét sâu hơn về lập trình C trong Linux. Tìm hiểu thêm về trình biên dịch, 4 giai đoạn từ mã nguồn đến chương trình nhị phân, cách sử dụng công cụ Make, \& sự khác biệt giữa các lệnh gọi hệ thống \& các hàm thư viện chuẩn. Ngoài ra, hãy xem một số tệp tiêu đề cần thiết khi nói đến Linux, \& xem một số tiêu chuẩn C \& Giao diện hệ điều hành di động (POSIX). C được tích hợp chặt chẽ với Linux, \& thành thạo C sẽ giúp bạn hiểu Linux.
    
    In this chap, develop both programs \& libraries for Linux. Also write both a generic Makefile \& more advanced ones for more significant projects. While doing this, also learn about different C standards, why they matter, \& how they affect your programs.
    
    -- Trong chương này, hãy phát triển cả chương trình \& thư viện cho Linux. Cũng viết cả Makefile chung \& các Makefile nâng cao hơn cho các dự án quan trọng hơn. Trong khi thực hiện việc này, hãy tìm hiểu về các tiêu chuẩn C khác nhau, lý do tại sao chúng quan trọng, \& cách chúng ảnh hưởng đến chương trình của bạn.
    
    This chapter will cover the following recipes:
    \begin{itemize}
        \item Linking against libraries using GNU Compiler Collection (GCC)
        \item Changing C standards
        \item Using system calls
        \item Understand when not to use them
        \item Getting information about Linux- \& Unix-specific header files
        \item Defining feature test macros
        \item Looking at 4 stages of compilation
        \item Compiling with Make
        \item Writing a generic Makefile with GCC options
        \item Writing a simple Makefile
        \item Writing a more advanced Makefile
    \end{itemize}
    \item {\sf4. Handling Errors in Programs.}
    \item {\sf5. Working with Filo I/O \& Filesystem Operations.}
    \item {\sf6. Spawning Processes \& Using Job Control.}
    \item {\sf7. Using {\tt systemd} to Handle Your Daemons.}
    \item {\sf8. Creating Shared Libraries.}
    \item {\sf9. Terminal I/O \& Changing Terminal Behavior.}
    \item {\sf10. Using Different Kinds of IPC.}
    \item {\sf11. Using Threads in Your Programs.}
    \item {\sf12. Debugging Your Programs.}
\end{itemize}

%------------------------------------------------------------------------------%

\section{Miscellaneous}

%------------------------------------------------------------------------------%

\printbibliography[heading=bibintoc]
    
\end{document}