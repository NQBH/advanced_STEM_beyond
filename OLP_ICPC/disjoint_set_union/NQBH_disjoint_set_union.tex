\documentclass{article}
\usepackage[backend=biber,natbib=true,style=alphabetic,maxbibnames=50]{biblatex}
\addbibresource{/home/nqbh/reference/bib.bib}
\usepackage[utf8]{vietnam}
\usepackage{tocloft}
\renewcommand{\cftsecleader}{\cftdotfill{\cftdotsep}}
\usepackage[colorlinks=true,linkcolor=blue,urlcolor=red,citecolor=magenta]{hyperref}
\usepackage{amsmath,amssymb,amsthm,enumitem,fancyvrb,float,graphicx,mathtools,tikz}
\usetikzlibrary{angles,calc,intersections,matrix,patterns,quotes,shadings}
\allowdisplaybreaks
\newtheorem{assumption}{Assumption}
\newtheorem{baitoan}{Bài toán}
\newtheorem{cauhoi}{Câu hỏi}
\newtheorem{conjecture}{Conjecture}
\newtheorem{corollary}{Corollary}
\newtheorem{dangtoan}{Dạng toán}
\newtheorem{definition}{Definition}
\newtheorem{dinhly}{Định lý}
\newtheorem{dinhnghia}{Định nghĩa}
\newtheorem{example}{Example}
\newtheorem{ghichu}{Ghi chú}
\newtheorem{hequa}{Hệ quả}
\newtheorem{hypothesis}{Hypothesis}
\newtheorem{lemma}{Lemma}
\newtheorem{luuy}{Lưu ý}
\newtheorem{nhanxet}{Nhận xét}
\newtheorem{notation}{Notation}
\newtheorem{note}{Note}
\newtheorem{principle}{Principle}
\newtheorem{problem}{Problem}
\newtheorem{proposition}{Proposition}
\newtheorem{question}{Question}
\newtheorem{remark}{Remark}
\newtheorem{theorem}{Theorem}
\newtheorem{vidu}{Ví dụ}
\usepackage[left=1cm,right=1cm,top=5mm,bottom=5mm,footskip=4mm]{geometry}
\def\labelitemii{$\circ$}
\DeclareRobustCommand{\divby}{%
    \mathrel{\vbox{\baselineskip.65ex\lineskiplimit0pt\hbox{.}\hbox{.}\hbox{.}}}%
}
\setlist[itemize]{leftmargin=*}
\setlist[enumerate]{leftmargin=*}

\title{Disjoint Set Union (DSU) -- Hợp Tập Hợp Rời Rạc}
\author{Nguyễn Quản Bá Hồng\footnote{A scientist- {\it\&} creative artist wannabe, a mathematics {\it\&} computer science lecturer of Department of Artificial Intelligence {\it\&} Data Science (AIDS), School of Technology (SOT), UMT Trường Đại học Quản lý {\it\&} Công nghệ TP.HCM, Hồ Chí Minh City, Việt Nam.\\E-mail: {\sf nguyenquanbahong@gmail.com} {\it\&} {\sf hong.nguyenquanba@umt.edu.vn}. Website: \url{https://nqbh.github.io/}. GitHub: \url{https://github.com/NQBH}.}}
\date{\today}

\begin{document}
\maketitle
\begin{abstract}
    This text is a part of the series {\it Some Topics in Advanced STEM \& Beyond}:

    {\sc url}: \url{https://nqbh.github.io/advanced_STEM/}.

    Latest version:
    \begin{itemize}
        \item {\it Disjoint Set Union (DSU) -- Hợp Tập Hợp Rời Rạc}.

        PDF: {\sc url}: \url{https://github.com/NQBH/advanced_STEM_beyond/blob/main/OLP_ICPC/disjoint_set_union/NQBH_disjoint_set_union.pdf}.

        \TeX: {\sc url}: \url{https://github.com/NQBH/advanced_STEM_beyond/blob/main/OLP_ICPC/disjoint_set_union/NQBH_disjoint_set_union.tex}.
        \item {\it }.

        PDF: {\sc url}: \url{.pdf}.

        \TeX: {\sc url}: \url{.tex}.
    \end{itemize}
\end{abstract}
\tableofcontents

%------------------------------------------------------------------------------%

\section{Introduction to Disjoint Set Union -- Nhập Môn Hợp Tập Hợp Rời Rạc}
\textbf{\textsf{Resources -- Tài nguyên.}}
\begin{enumerate}
    \item \href{https://cp-algorithms.com/data_structures/disjoint_set_union.html}{Algorithms for Competitive Programming{\tt/}disjoint set union}.

    \item {\sc Benjamin Qi, Andrew Wang, Nathan Gong, Michael Cao}. \href{https://usaco.guide/gold/dsu?lang=cpp}{USACO Guide{\tt/}Disjoint Set Union}.

    {\sf Abstract.} The Disjoint Set Union (DSU) data structure, which allows you to add edges to a graph \& test whether 2 vertices of a graph are connected.

    -- Cấu trúc dữ liệu Disjoint Set Union (DSU), cho phép bạn thêm các cạnh vào đồ thị \& kiểm tra xem 2 đỉnh của đồ thị có được kết nối hay không.

    \item {\sc Ngô Quang Nhật}. \href{https://wiki.vnoi.info/algo/data-structures/disjoint-set-union}{VNOI Wiki{\tt/}Disjoint Set Union}.

    \item \href{https://en.wikipedia.org/wiki/Disjoint-set_data_structure}{Wikipedia{\tt/}disjoint-set data structure}.
\end{enumerate}
Disjoint Set Union (abbr., DSU) là 1 cấu trúc dữ liệu hữu dụng, thường xuất hiện trong các kỳ thi Lập trình Thi Đấu, \& có thể được dùng để quản lý 1 cách hiệu 1 tập hợp của các tập hợp.

\begin{baitoan}
    \label{prob: query connectedness}
    Cho 1 đồ thị $G = (V,E)$ có $|V| = n\in\mathbb{N}^\star$ đỉnh, ban đầu không có cạnh nào, $E = \emptyset$. Ta cần xử lý 2 loại truy vấn:
    \begin{enumerate}
        \item Thêm 1 cạnh giữa 2 đỉnh $x,y\in V$ trong đồ thị, i.e., $E = E\cup\{\{x,y\}\}$ nếu $G$ là đồ thị vô hướng \& $E = E\cup\{(x,y)\}$ nếu $G$ là đồ thị có hướng; tuy nhiên DSU thường chỉ áp dụng cho đồ thị vô hướng nên ta chỉ xét trường hợp đồ thị vô hướng cho đơn giản.
        \item In ra {\tt yes} nếu như 2 đỉnh $x,y$ nằm trong cùng 1 thành phần liên thông. In ra {\tt no} nếu ngược lại.
    \end{enumerate}
\end{baitoan}

%------------------------------------------------------------------------------%

\subsection{Data Structure Disjoint Set Union -- Cấu trúc dữ liệu Disjoint Set Union}
Cho tiện, ta đánh số $n$ đỉnh của đồ thị $G$ bởi $1,2,\ldots,n$ (trường hợp $n$ đỉnh được dán nhãn bởi $v_1,v_2,\ldots,v_n$ hoàn toàn tương tự vì ta có thể làm việc trên chỉ số $i$ của $v_i$), khi đó $V = [n]$. Giả sử $G$ có $c\coloneqq$ \verb|num_connected_component| $\in\mathbb{N}^\star$ (số thành phần liên thông) $C_1,C_2,\ldots,C_c$ với $\{C_i\}_{i=1}^c$ là 1 phân hoạch của $V = [n]$, i.e.:
\begin{equation*}
    \bigcup_{i=1}^c C_i = [n],\ C_i\cap C_j = \emptyset,\ \forall i,j\in[c],\ i\ne j.
\end{equation*}
Nếu ta coi mỗi đỉnh của đồ thị $G = (V,E)$ là 1 phần tử \& mỗi thành phần liên thông (connected component) trong đồ thị là 1 tập hợp, truy vấn 1 sẽ trở thành gộp 2 tập hợp lần lượt chứa phần tử $x,y$ thành 1 tập hợp mới \& truy vấn 2 trở thành việc hỏi 2 phần tử $x,y$ có nằm trong cùng 1 tập hợp không.

Để tiện tính toán \& lý luận về mặt toán học cho riêng cấu trúc dữ liệu DSU, sau đây là 1 định nghĩa lai Toán--Tin mang tính cá nhân của tác giả [NQBH], hoàn toàn không chính thống trong Lý thuyết Đồ thị:

\begin{dinhnghia}[Chỉ số thành phần liên thông]
    \label{def: index component}
    Cho đồ thị vô hướng $G = (V,E)$ với $V = [n]$. Gọi $C(i)\subset[n]$ là thành phần liên thông của $G = (V,E)$ chứa đỉnh $i\in[n]$ \& gọi chỉ số của thành phần liên thông chứa đỉnh $i$ là ${\rm cid}(i)$, i.e., $i\in C_{{\rm cid}(i)}\equiv C(i)$, với hàm ${\rm cid}:[n]\to[c]$ được gọi là {\rm hàm chỉ số liên thông}.
\end{dinhnghia}
Với định nghĩa \ref{def: index component}, ta có ngay
\begin{equation*}
    \left\{\begin{split}
        &i\in C(i) = C_{{\rm cid}(i)}\subset[n],\\
        &i,j\mbox{ are connected},\ \forall j\in C(i).
    \end{split}\right.\ \forall i\in[n].
\end{equation*}
Ở đây, ta coi mỗi đỉnh của đồ thị tự liên thông với chính nó theo nghĩa đỉnh đó đến được (reachability) chính đỉnh đó thông qua 1 đường đi có độ dài 0, được gọi là 1 {\it đường đi tầm thường}, chứ không phải theo nghĩa khuyên (loop).

\begin{lemma}[A characterization of connectedness -- 1 đặc trưng hóa của tính liên thông]
    \label{lem: characterization connectedness}
    Cho đồ thị vô hướng $G = (V,E)$.
    (i) 2 đỉnh trên 1 đồ thị $G$ không liên thông với nhau, i.e., không có đường đi nào trên $G$ nối chúng khi \& chỉ khi chúng thuộc 2 thành phần liên thông khác nhau, i.e.,
    \begin{equation*}
        \boxed{i,j\mbox{ are not connected}\Leftrightarrow C(i)\ne C(j)\Leftrightarrow C(i)\cap C(j) = \emptyset\Leftrightarrow{\rm cid}(i)\ne{\rm cid}(j),\ \forall i,j\in[n].}
    \end{equation*}
    \item(ii) 2 đỉnh trên đồ thị $G$ liên thông với nhau, i.e., có đường đi trên trên $G$ nối chúng khi \& chỉ khi chúng cùng thuộc 1 thành phần liên thông, i.e.:
    \begin{equation*}
        \boxed{i,j\mbox{ are connected}\Leftrightarrow C(i) = C(j)\Leftrightarrow C(i)\cap C(j)\ne\emptyset\Leftrightarrow{\rm cid}(i) = {\rm cid}(j),\ \forall i,j\in[n].}
    \end{equation*}
\end{lemma}
Với truy vấn 1, giả sử 2 đỉnh $i,j\in[n]$ chưa có cạnh nối chúng trực tiếp, i.e., $\{i,j\}\notin E$. Có 2 trường hợp xảy ra:
\begin{itemize}
    \item Trường hợp 1: Giả sử $i,j$ cùng thuộc 1 thành phần liên thông, theo Lem. \ref{lem: characterization connectedness}, có $C(i) = C(j)$, ${\rm cid}(i) = {\rm cid}(j)$ nên ta chỉ cần thêm cạnh $\{i,j\}$ vào tập cạnh $E$: $E\leftarrow E\cup\{\{i,j\}\}$ hay \verb|edge_list.append({i, j})| mà không cần cập nhật $c$ tập liên thông $\{C_i\}_{i=1}^c$ hay hàm chỉ số liên thông ${\rm cid}(\cdot)$.
    \item Trường hợp 2: Giả sử $i,j$ thuộc 2 thành phần liên thông khác nhau, theo \ref{lem: characterization connectedness}, có $C(i)\ne C(j)$, ${\rm cid}(i)\ne {\rm cid}(j)$. Khi đó, việc nối cạnh $i,j$ với nhau, i.e., cập nhập tập cạnh bằng cách thêm cạnh $\{i,j\}$ vào tập cạnh $E$: $E\leftarrow E\cup\{\{i,j\}\}$ hay \verb|edge_list.append({i, j})|, nhưng điều khác biệt ở đây nằm ở chỗ: ta cũng cần phải cập nhật tập các thành phần liên thông \& hàm chỉ số liên thông như sau:
    \begin{enumerate}
        \item Cập nhật thành phần liên thông chứa cả $i$ \& $j$ bằng cách lấy hợp của 2 tập hợp $C(i),C(j)$, i.e., $C_{\rm new}(i) = C_{\rm new}(j)\coloneqq C(i)\cup C(j)$.
        \item Cập nhật hàm chỉ số liên thông: ${\rm cid}_{\rm new}(i) = {\rm cid}_{\rm new}(j) = \min\{{\rm cid}(i),{\rm cid}(j)\}$ (cũng có thể lấy $\max$ thay vì $\min$ nhưng theo quy ước của DSU data structure, ta nên lấy min để đảm bảo tính nhất quán\footnote{Consistency is 1 of the kings in natural sciences.}) \& sau đó ta có thể đánh chỉ số các thành phần liên thông lại nếu cần vì sau khi nối $i,j$ với nhau, số thành phần liên thông $c$ đã giảm đi 1, i.e., $c\leftarrow c - 1$ hay {\tt--c}.
    \end{enumerate}
\end{itemize}
Với truy vấn 2, với 2 đỉnh $i,j\in[n]$, $i\ne j$, ta có thể kiểm tra 2 đỉnh này có cùng nằm trong 1 thành phần liên thông hay không bằng cách so sánh $C(i)$ \& $C(j)$ hoặc ${\rm cid}(i)$ \& ${\rm cid}(j)$, nhờ Lem. \ref{lem: characterization connectedness}. Việc thực hiện truy vấn này khá hiển nhiên do bản chất của cấu trúc dữ liệu DSU chính là rã sự liên thông thành các thành phần liên khác nhau để tiện quản lý.

Về mặt cài đặt, để giải Bài toán \ref{prob: query connectedness}, ta sẽ xây dựng 1 cấu trúc dữ liệu có 3 thao tác sau:
\begin{enumerate}
    \item \verb|make_set(v)| tạo ra 1 tập hợp mới chỉ chứa phần tử $v$: output of \verb|make_set(v)| $= \{v\}$.
    \item \verb|union_sets(a,b)| gộp tập hợp chứa phần tử $a$ \& tập hợp chứa phần tử $b$ thành 1, i.e., bước cập nhật thành phần liên thông chung bằng cách lấy hợp của 2 thành phần liên thông tương ứng: $C_{\rm new}(i) = C_{\rm new}(j)\coloneqq C(i)\cup C(j)$ đã để cập.
    \item \verb|find_set(v)| cho biết {\it đại diện} (representative) của tập hợp có chứa phần tử $v$ (phần tử đại diện cho $v$ không nhất thiết phải là $v$, e.g., người đỡ đầu cho 1 tập hợp các đứa trẻ trong 1 trại trẻ mồ côi). Đại diện này là sẽ 1 phần tử của tập hợp đó \& có thể thay đổi sau mỗi lần gọi thao tác \verb|union_sets| (e.g., nếu chọn phần tử đại diện là đỉnh có giá trị nhỏ nhất thì nếu tìm được đỉnh mới nhỏ hơn phần tử đại diện hiện tại, thì phải cập nhật phần tử đại diện mới này). Ta có thể sử dụng đại diện đó để kiểm tra 2 phần tử có nằm trong cùng 1 tập hợp hay không. $a,b$ nằm trong cùng 1 tập hợp nếu như đại diện của 2 tập chứa chúng là giống nhau \& không nằm trong cùng 1 tập hợp nếu ngược lại.
\end{enumerate}
Ta có thể xử lý 3 thao tác này 1 cách hiệu quả với các tập hợp được biểu diễn dưới dạng các cây (tree-based representation), mỗi phần tử là 1 đỉnh \& mỗi cây tương ứng với 1 tập hợp. Gốc của mỗi cây sẽ là đại diện của tập hợp đó.

Ban đầu, mỗi phần tử thuộc 1 tập hợp riêng biệt: $\{1\},\{2\},\ldots,\{n\}$, nên mỗi đỉnh là 1 cây riêng biệt, cũng là 1 thành phần liên thông riêng biệt. $|E|$ bước tiếp theo, ở bước thứ $i\in[|E|]$, ta gộp 2 tập hợp chứa phần tử $a_i,b_i\in[n]$, $a_i\ne b_i$. Sau $|E|$ bước, ta được $c$ thành phần liên thông $\{C_i\}_{i=1}^c$. Với cách cài đặt này, ta sẽ lưu 1 mảng {\tt parent} với {\tt parent[v]} là cha của phần tử $v$.

%------------------------------------------------------------------------------%

\subsubsection{Naive implementation of DSU -- Cài đặt ``ngây thơ'' của DSU}
Nếu 1 cây được đánh số sao cho nhãn của node cha luôn nhỏ hơn nhãn của node con thì ta có thể dễ dàng định nghĩa khái niệm {\it gốc} của 1 cây như sau:

\begin{dinhnghia}
    \label{def: root of tree}
    Cho 1 đồ thị vô hướng $G = (V,E)$, $V = [n]$. {\rm Gốc} của 1 cây chứa 1 đỉnh $i\in[n]$ được định nghĩa bởi công thức
    \begin{equation*}
        r(i)\coloneqq\min\{j\in[n];i,j\mbox{ are connected}\}.
    \end{equation*}
\end{dinhnghia}
Để tạo 1 tập hợp mới gồm phần tử $v$ bởi \verb|make_set(v)|, ta chỉ cần tạo 1 cây có gốc là $v$, với \verb|parent[v] = v| (giống như kiểu phim \href{https://www.imdb.com/title/tt2397535/}{\it Predestination} (2014) -- tạm dịch: {\it Tiền Định{\tt/}Định Mệnh}, mình là cha \& là mẹ của chính mình, cũng là con của chính mình luôn). Để gộp 2 tập hợp lần lượt chứa 2 phần tử $a,b\in[n]$ bởi \verb|union_sets(a,b)|, ta sẽ tìm gốc $r(a)\in[n]$ của cây có chứa phần tử $a$ \& gốc $r(b)\in[n]$ của cây có chứa phần tử $b$. Nếu 2 giá trị này giống nhau $r(a) = r(b) = r\in[n]$, thì $r\in C(a)\cap C(b)\Rightarrow C(a)\cap C(b)\ne\emptyset$ nên theo Lem. \ref{lem: characterization connectedness}(ii), $C(a) = C(b)$ hay $a,b$ đã liên thông sẵn, nên ta sẽ không làm gì do 2 phần tử $a,b$ đã nằm trong cùng 1 tập hợp chứa gốc chung $r$. Còn nếu không, i.e., $r(a)\ne r(b)$, ta sẽ đặt gốc cây này là cha của gốc cây còn lại. Cụ thể hơn, nếu muốn khớp với Định nghĩa \ref{def: root of tree}, ta áp dụng truy vấn 1 để thêm 1 cạnh giữa 2 đỉnh $r(a),r(b)\in[n]$: $E\leftarrow E\cup\{\{r(a),r(b)\}\}$. Dễ thấy điều này sẽ gộp 2 cây lại thành 1. Hơn nữa, gốc chung mới vừa được cập nhật của cây chứa cả 2 đỉnh $a,b$ chính là $\min\{r(a),r(b)\}$.

Để tìm ký hiệu của 1 tập hợp có chứa phần tử $v$ bởi \verb|find_set(v)|, ta đơn giản nhảy lên các tổ tiên của đỉnh $v$ cho đến khi ta đến gốc của cây. Thao tác này có thể dễ dàng được cài đặt bằng đệ quy.
\begin{Verbatim}[numbers=left,xleftmargin=5mm]
void make_set(int v) {
    parent[v] = v; // tạo ra cây mới có gốc là đỉnh v
}

int find_set(int v) {
    if (v == parent[v]) return v; // trả về đỉnh v nếu như đỉnh v là gốc của cây
    return find_set(parent[v]); // đệ quy lên cha của đỉnh v
}

void union_set(int a, int b) {
    a = find_set(a); // tìm gốc của cây có chứa đỉnh a
    b = find_set(b); // tìm gốc của cây có chứa đỉnh b
    if (a != b) parent[b] = a; // gộp 2 cây nếu như 2 phần tử ở 2 cây khác nhau
}
\end{Verbatim}
Vì đây là cách cài đặt ngây thơ, ta có thể dễ dàng tạo ra 1 ví dụ sao cho khi sử dụng cách cài đặt này, cây sẽ trở thành 1 đoạn thẳng gồm $n$ phần tử. Khi đó, độ phức tạp của thao tác \verb|find_set| sẽ là $O(n)$ -- hiển nhiên không thể chấp nhận được, nên ta tìm hiểu 2 phương pháp tối ưu thuật toán sau.

%------------------------------------------------------------------------------%

\subsubsection{1st Optimization: Merge according to size{\tt/}height -- Tối ưu 1: Gộp theo kích cỡ{\tt/}độ cao}
Phương pháp tối ưu này sẽ thay đổi thao tác \verb|union_sets|, i.e., thay đổi cách xét trong 2 cây đang gộp, gốc của cây nào sẽ là cha của gốc của cây còn lại. Có khá nhiều cách để xét điều này, nhưng 2 cách được sử dụng nhiều nhất chính là gộp theo kích cỡ \& gộp theo độ cao của cây. Giả sử mỗi cây có 1 giá trị, lần lượt là kích cỡ \& độ cao của cây theo 2 cách gộp. Ở cả 2 cách gộp, ta sẽ luôn đặt gốc của cây có giá trị lớn hơn là cha của gốc của cây có giá trị nhỏ hơn.

Thao tác \verb|union_sets| được tối ưu gộp theo kích cỡ:
\begin{Verbatim}[numbers=left,xleftmargin=5mm]
// merge according to size
void make_set_size(int v) {
    parent[v] = v;
    size[v] = 1; // ban đầu tập hợp chứa v có kích cỡ là 1
}

void union_set_size(int a, int b) {
    a = find_set(a);
    b = find_set(b);
    if (a != b) {
        if (size[a] < size[b]) swap(a, b); // đặt biến a là gốc của cây có kích cỡ lớn hơn
        parent[b] = a;
        size[a] += size[b]; // cập nhật kích cỡ của cây mới gộp lại
    }
}
\end{Verbatim}
Thao tác \verb|union_sets| được tối ưu gộp theo độ cao:
\begin{Verbatim}[numbers=left,xleftmargin=5mm]
// merge according to size
void make_set_height(int v) {
    parent[v] = v;
    rank[v] = 0; // gốc của cây có độ cao là 0
}

void union_set_height(int a, int b) {
    a = find_set(a);
    b = find_set(b);
    if (a != b) {
        if (rank[a] < rank[b]) swap(a, b); // đặt biến a là gốc của cây có độ cao lớn hơn
        parent[b] = a;
        if (rank[a] == rank[b]) ++rank[a]; // nếu 2 cây có cùng 1 độ cao, độ cao của cây mới
            // sau khi gộp sẽ tăng 1
    }
}
\end{Verbatim}
Chỉ cần sử dụng phương pháp tối ưu này, với 1 trong 2 cách cài đặt, độ phức tạp của thao tác \verb|find_set| sẽ trở thành $O(\log n)$. Tuy nhiên, ta có thể tối ưu hóa hơn nữa khi kết hợp với phương pháp tối ưu thứ 2.

\begin{question}
    Có cách nào hybrid để trộn giữa 2 cách hộp theo kích cỡ \& độ cao không?
\end{question}

%------------------------------------------------------------------------------%

\subsubsection{2nd Optimization: Path compression -- Tối ưu 2: Nén đường đi}
Phương pháp tối ưu nén đường đi nhằm tăng tốc thao tác \verb|find_set|. Giả sử ta gọi hàm \verb|find_set(v)| với 1 đỉnh $v\in[n]$ bất kỳ, ta tìm được $p$ là gốc của cây, đồng thời cũng là giá trị của mọi hàm \verb|find_set(u)| với $u$ là 1 đỉnh nằm trên đường đi từ $v$ đến $p$.\footnote{NQBH: Trong bài viết gốc \href{https://wiki.vnoi.info/algo/data-structures/disjoint-set-union}{VNOI Wiki{\tt/}disjoint set union}, tác giả viết nhầm thành ``với $u$ là 1 đỉnh nằm trên đường đi từ $u$ đến $p$'' sửa lại thành ``với $u$ là 1 đỉnh nằm trên đường đi từ $v$ đến $p$'' \& vài chỗ khác nhầm ký hiệu đỉnh $v$ thành $u$.} Cách tối ưu ở đây chính là làm cho đường đi đến gốc của các đỉnh $u$ ngắn đi bằng cách gán trực tiếp cha của các đỉnh $u$ này thành $p$.
\begin{Verbatim}[numbers=left,xleftmargin=5mm]
// path compression
int find_set_path_compression(int v) {
    if (v == parent[v]) return v; // trả về đỉnh v nếu như đỉnh v là gốc của cây
    int p = find_set(parent[v]); // đệ quy lên cha của đỉnh v
    parent[v] = p; // nén đoạn từ v lên gốc của cây
    return p;
}
\end{Verbatim}
1 cách cài đặt khác của thao tác \verb|find_set| thường được sử dụng nhiều trong Competitive Programming do tính ngắn gọn của nó:
\begin{Verbatim}[numbers=left,xleftmargin=5mm]
// brief find set
int find_set_brief(int v) {
    return v == parent[v] ? v : parent[v] = find_set_brief(parent[v]);
}
\end{Verbatim}

%------------------------------------------------------------------------------%

\subsection{Time complexity \& its proof -- Độ phức tạp thời gian \& chứng minh}

%------------------------------------------------------------------------------%

\subsection{An alternative implementation of DSU -- 1 cách cài đặt khác}
\textbf{\textsf{Resources -- Tài nguyên.}}
\begin{enumerate}
    \item {\sc Lê Minh Hoàng}. {\it Giải Thuật \& Lập Trình}.

    \item AtCoder Library: \url{https://github.com/atcoder/ac-library}.
\end{enumerate}
Thay vì cài đặt cấu trúc dữ liệu DSU bằng 2 mảng {\tt parent, size}, chỉ 1 mảng {\tt lab} được sử dụng. Nếu {\tt lab[v]} $< 0$ thì $v$ là gốc của 1 cây -{\tt lab[v]} là số lượng đỉnh của cây đó. Còn nếu {\tt lab[v]} $> 0$ thì {\tt lab[v]} là cha của đỉnh $v$.
\begin{Verbatim}[numbers=left,xleftmargin=5mm]
// alternative implementation of DSU
void make_set_lab(int v) {
    lab[v] = -1;
}

int find_set_lab(int v) {
    return lab[v] < 0 ? v : lab[v] = find_set_lab(lab[v]);
}

void union_set_lab(int a, int b) {
    a = find_set_lab(a);
    b = find_set_lab(b);
    if (a != b) {
        if (lab[a] > lab[b]) swap(a, b);
        lab[a] += lab[b];
        lab[b] = a;
    }
}
\end{Verbatim}

%------------------------------------------------------------------------------%

\section{Some Applications of DSU -- Vài Ứng Dụng của DSU}

%------------------------------------------------------------------------------%

\subsection{Save additional information for each set -- Lưu thêm thông tin khác cho mỗi tập hợp}
Ngoài việc lưu các thông tin về cấu trúc cây, ta có thể lưu các hàm có tính chất giao hoán \& kết hợp của từng tập hợp. E.g., ta có thể lưu tổng các phần tử{\tt/}giá trị phần tử nhỏ nhất hoặc lớn nhất, trung bình cộng, etc. của từng tập hợp. Khi đó, các thao tác của DSU sẽ được cài đặt như sau:
\begin{Verbatim}[numbers=left,xleftmargin=5mm]
// save additional information for each set in DSU
voi make_set_size_more_info(int v) {
    parent[v] = v;
    size[v] = 1;
    Min[v] = value[v]; // value[v] là giá trị của phần tử thứ v
    Max[v] = value[v];
    sum[v] = value[v];
    avg[v] = value[v];
}

int find_set_size_more_info(int v) {
    return v == parent[v] ? v : parent[v] = find_set_size_more_info(parent[v]);
}

void union_set_size_more_info(int a, int b) {
    a = find_set_size_more_info(a);
    b = find_set_size_more_info(b);
    if (a != b) {
        if (size[a] < size[b]) swap(a, b);
        parent[b] = a;
        size[a] += size[b];
        sum[a] += sum[b];
        Min[a] = min(Min[a], Min[b]);
        Max[a] = max(Min[a], Min[b]);
        avg[a] = static_cast<double>(sum[a]) / size(a);
    }
}
\end{Verbatim}
Tương tự như thông tin về độ lớn {\tt size} của cây hay độ cao {\tt rank} của cây, ta sẽ lưu các hàm này tại gốc của từng cây.
\begin{Verbatim}[numbers=left,xleftmargin=5mm]
int find_sum(int v) { // trả về tổng của các phần tử trong tập hợp chứa v
    v = find_set_size_more_info(v);
    return sum[v];
}

int find_min(int v) { // trả về giá trị nhỏ nhất của các phần tử trong tập hợp chứa v
    v = find_set_size_more_info(v);
    return Min[v];
}

int find_max(int v) { // trả về giá trị lớn nhất của các phần tử trong tập hợp chứa v
    v = find_set_size_more_info(v);
    return Max[v];
}

double find_avg(int v) { // trả về giá trị trung bình của các phần tử trong tập hợp chứa v
    v = find_set_size_more_info(v);
    return avg[v];
}
\end{Verbatim}

\begin{baitoan}[Xếp hàng]
    Cho $n\in\mathbb{N}^\star$ người đang xếp hàng ở các vị trí từ $1$ đến $n$. Viết chương trình xử lý 2 truy vấn:
    \begin{enumerate}
        \item Người đứng ở vị trí thứ $i$ rời khỏi hàng.
        \item Tìm người gần nhất về bên phải vị trí $p$ mà chưa rời khỏi hàng.
    \end{enumerate}
\end{baitoan}

\begin{proof}[1st solution: DSU]
    Gọi $Q_{\rm curr}\subset[n]$ là hàng đợi hiện tại gồm những người còn đứng trong hàng. Với mỗi vị trí $i\in[n]$, ta sẽ có 1 con trỏ ${\rm ptr}(i)$. Nếu người đứng ở vị trí $i$ vẫn đang đứng trong hàng, con trỏ trỏ vào vị trí đó, i.e., ${\rm ptr}(i) = i$, nếu không thì con trỏ này sẽ trỏ vào con trỏ ở vị trí ngay bên phải. Ta có công thức đệ quy cho hàm con trỏ ${\rm ptr}:[n]\to[n]$ như sau:
    \begin{equation*}
        {\rm ptr}(i) = \left\{\begin{split}
            &i&&\mbox{if } i\in Q_{\rm curr},\\
            &{\rm ptr(i + 1)}&&\mbox{if } i\notin Q_{\rm curr}.
        \end{split}\right.
    \end{equation*}
    Dễ dàng dự đoán \& chứng minh bằng quy nạp công thức toán học cho hàm con trỏ ${\rm ptr}:[n]\to[n]$ như sau:
    \begin{equation*}
        {\rm ptr}(i) = \min\{j\in[n];i\le j,\ j\in Q_{\rm curr}\} = \min\{j\in[n];i\le j,\ {\rm ptr}(j) = j\},
    \end{equation*}
    có ý nghĩa là con trỏ ở vị trí $i$ trỏ vào người gần nhất tính từ vị trí $i$ về phía bên phải.

    Giả sử ban đầu có $n$ người trong hàng đợi, $V\coloneqq [n]$, $Q_0 = V = [n]$, ${\rm ptr} = {\rm id}_V$, i.e., ${\rm ptr}(i) = i$, $\forall i\in[n]$. Tại các bước tiếp theo, nếu người $i\in[n]$ nào đó rời hàng, $Q_{\rm curr}\coloneqq Q_{\rm lastest}\backslash\{i\}$, ta sẽ thực hiện truy vấn 1 của Bài toán \ref{prob: query connectedness} bằng cách nối 2 đỉnh $i$ \& $i + 1$ lại với nhau, i.e., $E\leftarrow E\cup\{\{i,i + 1\}\}$, ta sẽ gán ${\rm ptr}(i) = {\rm ptr}(i + 1)$: dễ thấy để tìm người gần nhất bên phải mà chưa rời khỏi hàng, ta đi dần dần sang phải cho đến khi gặp 1 vị trí có con trỏ trỏ đến chính nó.

    Ta có thể sử dụng cấu trúc dữ liệu DSU để lưu trữ các thông tin trên \& sử dụng phương pháp tối ưu nén để đoạt được độ phức tạp trung bình $O(\log n)$ với mỗi truy vấn. Vị trí ta cần tìm chính là vị trí có thứ tự lớn nhất trong mỗi tập hợp (ứng với mỗi thành phần liên thông). Ta có thể lưu phần tử lớn nhất trong 1 tập hợp như đã cài đặt, qua đó đạt được độ phức tạp trung bình $O(\alpha(n))$ với mỗi truy vấn.
    \begin{Verbatim}[numbers=left,xleftmargin=5mm]
#include <iostream>
#include <vector>
using namespace std;

vector<int> parent, Size, Max;

void make_set_size_max(int v) {
    parent[v] = v;
    Size[v] = 1;
    Max[v] = v;
}

int find_set(int v) {
    return v == parent[v] ? v : parent[v] = find_set(parent[v]);
}

void union_set_size_max(int a, int b) {
    a = find_set(a);
    b = find_set(b);
    if (a != b) {
        if (Size[a] < Size[b]) swap(a, b);
        parent[b] = a;
        Size[a] += Size[b];
        Max[a] = max(Max[a], Max[b]);
    }
}

void leave(int v) { // người thứ v rời khỏi hàng
    union_set_size_max(v, v + 1);
}

int find_next(int p) { // trả về thứ tự của người gần nhất bên phải vị trí p mà chưa rời khỏi hàng
    p = find_set(p);
    return Max[p];
}

int main() {
    int n, num_query, type_query, node; // query has 2 types:
    // type 1: 1 i: remove person i from current queue &
    // type 2: 2 p: find closest person from p to the right that is still in the queue
    cin >> n >> num_query;
    parent.resize(n);
    Size.resize(n);
    Max.resize(n);
    for (int i = 1; i <= n; ++i) make_set_size_max(i);
    for (int i = 0; i < num_query; ++i) {
        cin >> type_query >> node;
        if (type_query == 1) leave(node); // remove person i from current queue
        else cout << find_next(node) << '\n';
    }
}
    \end{Verbatim}
\end{proof}

%------------------------------------------------------------------------------%

\subsection{Optimize algorithms of finding minimum spanning trees (MST) in graphs -- Tối ưu thuật toán tìm cây khung nhỏ nhất trong đồ thị}
\textbf{\textsf{Resources -- Tài nguyên.}}
\begin{enumerate}
    \item \href{https://wiki.vnoi.info/algo/graph-theory/minimum-spanning-tree.md}{VNOI Wiki{\tt/}minimum spanning tree -- bài toán tìm cây khung nhỏ nhất trong đồ thị}.
\end{enumerate}
Sử dụng DSU, ta có thể tối ưu độ phức tạp của thuật toán tìm cây khung nhỏ nhất của đồ thị từ $O(m\log n + n^2)$ xuống $O(m\log n$.

%------------------------------------------------------------------------------%

\subsection{Reverse query -- Đảo ngược truy vấn}
Do tính chất 1 chiểu của cấu trúc dữ liệu DSU: chỉ thêm đỉnh hoặc cạnh của đồ thị chứ không xóa được, ở 1 số bài ta phải đảo ngược thứ tự của các truy vấn trong bài để giải.

\begin{problem}[\href{https://codeforces.com/contest/722/problem/C}{CodeForces{\tt/}Intel Code Challenge Elimination Round (Div. 1 + Div. 2, combined){\tt/}C. destroying array}]
    You are given an array consisting of $n$ nonnegative integers $a_1,a_2,\ldots,a_n$. You are going to destroy integers in the array 1 by 1. Thus, you are given the permutation of integers from $1$ to $n$ defining the order elements of the array are destroyed.

    After each element is destroyed, you have to find out the segment of the array, s.t. it contains no destroyed elements \& the sum of its elements is maximum possible. The sum of elements in the empty segment is considered to be $0$.
    \item {\sf Input.} The 1st line of the input contains a single integer $n\in[10^5]$ -- the length of the array. The 2nd line contains $n$ integers $a_1,a_2,\ldots,a_n$, $a_i\in\overline{0,10^9}$, $\forall i\in[n]$. The 3rd line contains a permutation of integers from $1$ to $n$ -- the order used to destroy elements.
    \item {\sf Output.} Print $n$ lines. The $i$th line should contain a single integer -- the maximum possible sum of elements on the segment containing no destroyed elements, after 1st $i$ operators are performed.
    \item {\sf Sample.}
    \begin{table}[H]
        \centering
        \begin{tabular}{|l|l|}
            \hline
            \verb|destroy_array.inp| & \verb|destroy_array.out| \\
            \hline
            4 & 5 \\
            1 3 2 5 & 4 \\
            3 4 1 2 & 3 \\
            & 0 \\
            \hline
            5 & 6 \\
            1 2 3 4 5 & 5 \\
            4 2 3 5 1 & 5 \\
            & 1 \\
            & 0 \\
            \hline
            8 & 18 \\
            5 5 4 4 6 6 5 5 & 16 \\
            5 2 8 7 1 3 4 6 & 11 \\
            & 8 \\
            & 8 \\
            & 6 \\
            & 6 \\
            & 0 \\
            \hline
        \end{tabular}
    \end{table}
\end{problem}

\begin{baitoan}[Destroying array]
    Cho mảng gồm $n\in\mathbb{N}^\star$ số tự nhiên $a_1,a_2,\ldots,a_n\in\mathbb{N}$ \& 1 hoán vị $\pi\in S_n$ của $[n]$. $n$ phần tử sẽ lần lượt bị phá hủy theo thứ tự hoán vị trên. Sau mỗi lần 1 phần tử bị phá hủy, in ra dãy con liên tiếp có tổng lớn nhất mà không có phần tử nào đã bị phá hủy. Tổng của 1 đoạn con rỗng là $0$.
    \item {\sf Giới hạn.} $n\in[10^5],a_i\in\overline{0,10^9}$, $\forall i\in[n]$.
\end{baitoan}

\begin{proof}[1st solution: DSU]
    Source: \url{https://wiki.vnoi.info/algo/data-structures/disjoint-set-union} Do các phần tử là các số tự nhiên, nếu nếu sau khi 1 số phần tử bị phá hủy, dãy bị chia thành $k$ đoạn con liên tiếp thì đáp án sẽ là 1 trong $k$ đoạn này. Đảo ngược thứ tự của các truy vấn, ta có thể thấy bài toán trở nên dễ dàng hơn rất nhiều: Hồi sinh 1 số bị phá hủy trở về ban đầu \& in ra đoạn con có tổng lớn nhất. Khi đó ta dùng cấu trúc dữ liệu DSU để xử lý các đoạn con liên tiếp.

    Khi 1 số được hồi sinh, ta sẽ kiểm tra vị trí ngay bên trái số đó (chứ không phải tất cả vị trí bên trái số đó), nếu có số nào đã được hồi sinh từ trước thì ta sẽ thêm cạnh giữa số đó \& số ngay bên trái số đó. Tương tự với số ngay bên phải. Ở mỗi thời điểm, các thành phần liên thông trong DSU sẽ thể hiện cho 1 đoạn con liên tiếp. Việc lưu trữ tổng của 1 thành phần liên thông đã được cài đặt ở trên.
    \item {\sf C++ implementation.}
    \begin{enumerate}
        \item VNOI's C++: destroying array: \url{https://wiki.vnoi.info/algo/data-structures/disjoint-set-union}:
        \begin{Verbatim}[numbers=left,xleftmargin=5mm]
#include <iostream>
#include <vector>
using namespace std;
#define ll long long

const int N = 1e5 + 5;
int n, a[N], p[N];
ll ans, res[N];
bool flag[N];

struct DSU {
    vector<ll> parent, sz, sum;
    DSU(ll n) : parent(n), sz(n), sum(n) {};

    void make_set(ll v) {
        parent[v] = v;
        sz[v] = 1;
        sum[v] = a[v];
    }

    ll find_set(ll v) {
        return v == parent[v] ? v : parent[v] = find_set(parent[v]);
    }

    void join_sets(ll a, ll b) {
        a = find_set(a);
        b = find_set(b);
        if (a != b) {
            if (sz[a] < sz[b]) swap(a, b);
            parent[b] = a;
            sz[a] += sz[b];
            sum[a] += sum[b];
        }
    }
};

int main() {
    ios_base::sync_with_stdio(false); cin.tie(NULL);
    cin >> n;
    for (int i = 1; i <= n; ++i) cin >> a[i];
    for (int i = 1; i <= n; ++i) cin >> p[i];
    DSU g(n + 5);
    for (int i = 1; i <= n; i++) g.make_set(i);
    for (int i = n; i >= 1; --i) {
        flag[p[i]] = true;
        if (p[i] > 1 && flag[p[i] - 1]) g.join_sets(p[i], p[i] - 1);
        if (p[i] < n && flag[p[i] + 1]) g.join_sets(p[i], p[i] + 1);
        ans = max(ans, g.sum[g.find_set(p[i])]);
        res[i - 1] = ans;
    }
    for (int i = 1; i <= n; ++i) cout << res[i] << '\n';
}
        \end{Verbatim}
        \item NQBH's C++: destroying array:
        \begin{Verbatim}[numbers=left,xleftmargin=5mm]
#include <iostream>
#include <vector>
using namespace std;

vector<int> a, p, parent, sz;
vector<long long> res, sum;
vector<bool> activated_pos;

void make_set_size_sum(int i) {
    parent[i] = i;
    sz[i] = 1;
    sum[i] = a[i];
}

int find_set_size_sum(int v) {
    return v == parent[v] ? v : parent[v] = find_set_size_sum(parent[v]);
}

void union_set_size_sum(int a, int b) {
    a = find_set_size_sum(a);
    b = find_set_size_sum(b);
    if (a != b) {
        if (sz[a] < sz[b]) swap(a, b);
        parent[b] = a;
        sz[a] += sz[b];
        sum[a] += sum[b];
    }
}

int main() {
    int n;
    cin >> n;
    vector<bool> activated_pos(n + 1, false);
    a.resize(n + 1);
    p.resize(n + 1);
    parent.resize(n + 1);
    sz.resize(n + 1);
    res.resize(n + 1);
    sum.resize(n + 1);
    res[n] = 0; // last result is always 0
    for (int i = 1; i <= n; ++i) cin >> a[i];
    for (int i = 1; i <= n; ++i) cin >> p[i];
    activated_pos[p[n]] = true;
    long long ans = a[p[n]]; // initialize current max sum
    res[n - 1] = ans; // last element being destroyed
    make_set_size_sum(p[n]);
    for (int i = n - 1; i >= 1; --i) {
        activated_pos[p[i]] = true;
        make_set_size_sum(p[i]);
        if (p[i] > 1 && activated_pos[p[i] - 1]) union_set_size_sum(p[i], p[i] - 1);
        if (p[i] < n && activated_pos[p[i] + 1]) union_set_size_sum(p[i], p[i] + 1);
        ans = max(ans, sum[find_set_size_sum(p[i])]);
        res[i - 1] = ans;
    }
    for (int i = 1; i <= n; ++i) cout << res[i] << '\n';
}
        \end{Verbatim}
    \end{enumerate}
\end{proof}

%------------------------------------------------------------------------------%

\subsection{Kiểm tra tính chất 2 phía của đồ thị online}

\begin{baitoan}
    Cho 1 đồ thị có $n\in\mathbb{N}^\star$ đỉnh, ban đầu không có cạnh nào. Xử lý các truy vấn thêm cạnh vào đồ thị. Hỏi sau truy vấn nào thì đồ thị không còn là đồ thị 2 phía?
\end{baitoan}

\begin{proof}[1st solution: DSU]
    Dựa vào tính chất của đồ thị 2 phía, với mọi cặp đỉnh thuộc cùng 1 phía sẽ có đường đi bất kỳ giữa chúng có độ dài chẵn, i.e., nếu ta chọn 1 đỉnh $l$ trong 1 thành phần liên thông, 2 đỉnh $a,b\in V$ sẽ nằm cùng 1 phía nếu như khoảng cách của 2 đỉnh này tới $l$ có cùng tính chẵn lẻ. Ta hoàn toàn có thể sử dụng cấu trúc dữ liệu DSU để lưu trữ thông tin này bằng cách lưu tính chẵn lẻ của đường đi từ mọi đỉnh tới gốc của cây. Lúc này, hàm \verb|find_set| sẽ trả trả về 1 cặp \{gốc của cây, tính chẵn lẻ của độ dài đường đi đến gốc của cây\} \& được cài đặt như sau:
    \begin{Verbatim}[numbers=left,xleftmargin=5mm]
pair<int, int> find_set(int v) {
    if (v == parent[v]) return {v, 0};
    parent<int, int> val = find_set(parent[v]);
    parent[v] = val.first;
    dist[v] = (dist[v] + val.second) % 2;
    // độ dài từ đỉnh v đến cha mới
    // = độ dài từ đỉnh v đến đỉnh cha cũ
    // + độ dài từ cha cũ tới cha mới (gốc của cây)
    return {parent[a], dist[a]};
}
    \end{Verbatim}
    Tương tự, hàm \verb|union_sets| cũng cần phải được thay đổi \& được cài đặt như sau:
    \begin{Verbatim}[numbers=left,xleftmargin=5mm]
void union_set(int a, int b) {
    pair<int, int> val_a = find_set(a), val_b = find_set(b);
    a = val_a.first;
    b = val_b.first;
    if (a == b) {
        if (val_a.second != val_b.second) {
            // đồ thị không còn là đồ thị 2 phía
        }
    }
    else {
        if (sz[a] < sz[b]) swap(a, b);
        parent[b] = a;
        sz[a] += sz[b];
        dist[b] = (val_a.second + val_b.second + 1) % 2;
        // độ dài từ đỉnh b tới gốc cây
        // = độ dài từ đỉnh a tới gốc cây ban đầu chứa a
        // + độ dài từ đỉnh b tới gốc cây ban đầu chứa b
        // + 1 (khoảng cách giữa 2 đỉnh a & b)
    }
}
    \end{Verbatim}
\end{proof}

%------------------------------------------------------------------------------%

\section{Some Techniques Using DSU's Properties -- Vài Kỹ Thuật Sử Dụng Tính Chất của DSU}
Ngoài ra tính chất của DSU còn được sử dụng trong một số kĩ thuật khá phổ biến.

%------------------------------------------------------------------------------%

\subsection{Small-to-large merging -- Kỹ thuật gộp set}
Giả sử ta cần lưu trực tiếp các phần tử của 1 tập hợp bằng 1 cấu trúc dữ liệu như set{\tt/}map, thì liệu có cách nào đủ hiệu quả để thực hiện thao tác \verb|union_sets| không? Có 1 kỹ thuật gộp set (small-to-large merging) để thực hiện yêu cầu đó.

\begin{baitoan}[\href{https://oj.vnoi.info/problem/colquery}{VNOI{\tt/}color query}]
    Cho 1 đồ thị vô hướng có $n\in\mathbb{N}^\star$ đỉnh, đỉnh thứ $i$ có màu $a_i$. Ban đầu đầu thị chưa có cạnh nào $E = \emptyset$. Cho $q\in\mathbb{N}^\star$ truy vấn, mỗi truy vấn thuộc 1 trong 2 dạng:
    \begin{itemize}
        \item $1$ $u$ $v$: thêm 1 cạnh nối giữa $u,v$.
        \item $2$ $u$ $c$: Tính số đỉnh có màu $c$ trong thành phần liên thông chứa $u$.
    \end{itemize}
    \item {\sf Input.} Dòng đầu tiên chứa 2 số nguyên dương $n\in[10^5],q\in[2\cdot10^5]$. Dòng tiếp theo chứa $n$ số nguyên dương $a_i\in[n]$, $\forall i\in[n]$. $q$ dòng cuối cùng, mỗi dòng gồm 3 số nguyên dương, số đầu tiên $\in\{1,2\}$ là loại của truy vấn, 2 số nguyên còn lại $\le n$.
    \item {\sf Output.} Với mỗi truy vấn loại 2, in ra 1 dòng kết quả của truy vấn đó.
    \item {\sf Sample.}
    \begin{table}[H]
        \centering
        \begin{tabular}{|l|l|}
            \hline
            \verb|color_query.inp| & \verb|color_query.out| \\
            \hline
            5 7 & 1 \\
            2 4 2 3 2 & 0 \\
            1 1 2 & 3 \\
            2 1 2 & 1 \\
            1 3 5 & \\
            2 2 1 & \\
            1 1 3 & \\
            2 3 2 & \\
            2 4 3 & \\
            \hline
        \end{tabular}
    \end{table}
\end{baitoan}

\begin{proof}[1st solution: DSU]
    Ta sử dụng cấu trúc dữ liệu DSU \& lưu thêm 1 map chứa số lượng từng màu tại gốc của từng cây. Trong thao tác \verb|union_sets|, ta sẽ chuyển lần lượt các phần tử trong map của tập hợp bé hơn vào map của tập hợp lớn hơn, với độ phức tạp thời gian là $O(n\log n)$. Thật vậy, gọi số phần tử nằm trong 2 dãy số lớn hơn \& bé hơn lần lượt là $a,b$, thì $a + b\ge2b$, nên mỗi lần 1 phần tử bị di chuyển, nó sẽ bị di chuyển tới 1 dãy số có kích thước lớn hơn ít nhất 2 lần kích thước dãy số ban đầu nó nằm trong, nên 1 phần tử chỉ bị di chuyển tối đa $\log_2n$ lần, qua đó mà đạt được độ phức tạp $O(n\log n)$.
    \item {\sc C++ implementation.}
    \begin{enumerate}
        \item VNOI's C++: color query:
        \begin{Verbatim}[numbers=left,xleftmargin=5mm]
#include <iostream>
#include <map>
#include <vector>
using namespace std;

const int N = 1e5 + 5;
int n, q, a[N];

struct DSU {
    vector<map<int, int>> color;
    vector<int> parent, sz;

    DSU(int n) : color(n), parent(n), sz(n) {};

    void make_set(int v) {
        color[v][a[v]] = 1;
        parent[v] = v;
        sz[v] = 1;
    }

    int find_set(int v) {
        if (v == parent[v]) return v;
        int p = find_set(parent[v]);
        parent[v] = p;
        return p;
    }

    void union_set(int a, int b) {
        a = find_set(a);
        b = find_set(b);
        if (a != b) {
            if (sz[a] < sz[b]) swap(a, b);
            parent[b] = a;
            sz[a] += sz[b];
            for (auto p : color[b]) color[a][p.first] += p.second;
            color[b].clear();
        }
    }

    int query(int v, int c) {
        v = find_set(v);
        return color[v].find(c) != color[v].end() ? color[v][c] : 0;
    }
};

int main() {
    ios_base::sync_with_stdio(false);
    cin.tie(NULL);
    cin >> n >> q;
    for (int i = 1; i <= n; ++i) cin >> a[i];
    DSU g(n + 5);
    for (int i = 1; i <= n; ++i) g.make_set(i);
    while (q--) {
        int op, x, y;
        cin >> op >> x >> y;
        if (op == 1) g.union_set(x, y);
        else cout << g.query(x, y) << '\n';
    }
}
        \end{Verbatim}
        \item NQBH's C++: color query:
        \begin{Verbatim}[numbers=left,xleftmargin=5mm]
#include <iostream>
#include <vector>
using namespace std;

// int n, q, a[N], parent[N], sz[N], color[N][N];
int n, q;
vector<int> a, parent, sz, not_merge_color;
vector<vector<int>> color;

void make_set_size(int i) {
    parent[i] = i;
    sz[i] = 1;
}

int find_set_size(int v) {
    return v == parent[v] ? v : parent[v] = find_set_size(parent[v]);
}

void union_set_size(int u, int v) {
    u = find_set_size(u);
    v = find_set_size(v);
    if (u != v) {
        if (sz[u] < sz[v]) swap(u, v);
        parent[v] = u;
        sz[u] += sz[v];
        if (not_merge_color[v]) { // have not taken colors in node v yet
            for (int i = 1; i <= n; ++i) {
                color[u][i] += color[v][i];
                not_merge_color[v] = false;
            }
        }
    }
}

int main() {
    cin >> n >> q;
    a.resize(n + 1);
    parent.resize(n + 1);
    sz.resize(n + 1);
    not_merge_color.resize(n + 1);
    color.resize(n + 1, vector<int>(n + 1));
    for (int i = 1; i <= n; ++i) {
        not_merge_color[i] = true;
        cin >> a[i];
        make_set_size(i);
        color[i][a[i]] = 1;
    }
    for (int i = 0; i < q; ++i) {
        int query_type;
        cin >> query_type;
        if (query_type == 1) {
            int u, v;
            cin >> u >> v;
            union_set_size(u, v);
        }
        else {
            int u, c;
            cin >> u >> c;
            u = find_set_size(u);
            cout << color[u][c] << '\n';
        }
    }
}
        \end{Verbatim}
        MLE on large-size tests on VNOI OJ.
    \end{enumerate}
\end{proof}

%------------------------------------------------------------------------------%

\subsection{Kỹ thuật DSU trên cây (Sack)}
Kỹ thuật DSU trên cây (Sack) là 1 thuật toán sử dụng ý tưởng của kỹ thuậts gộp set để  giải quyết 1 số bài toán truy vấn trên cây 1 cách hiệu quả.

\begin{baitoan}
    Cho 1 cây có $n\in\mathbb{N}^\star$ đỉnh với gốc là đỉnh $1$, đỉnh thứ $i$ được tô màu $c_i$. Cho $q\in\mathbb{N}^\star$ truy vấn có dạng $v$ $c$, với mỗi truy vấn in ra số lượng đỉnh có màu $c$ trong cây con gốc $v$.
\end{baitoan}

%------------------------------------------------------------------------------%

\section{Miscellaneous}

\begin{question}[DSU vs. GNNs, GCNs, GATs]
    Liệu DSU data structure có thể có lợi để cài đặt Graph Neural Networks (GNNs), Graph Convolutional Network (GCNs), Graph Attention Networks (GATs) không?
\end{question}

%------------------------------------------------------------------------------%

\printbibliography[heading=bibintoc]

\end{document}