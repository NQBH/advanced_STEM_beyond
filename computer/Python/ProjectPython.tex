\documentclass[a4paper,oneside]{book}
\usepackage{tabu,float,hyperref,color,amsmath,amsxtra,amssymb,latexsym,amscd,amsthm,amsfonts,graphicx}
\numberwithin{equation}{chapter}
\usepackage{fancyhdr}
\pagestyle{fancy}
\fancyhf{}
\fancyhead[RE,LO]{\footnotesize \textsc \leftmark}
\cfoot{\thepage}
\renewcommand{\headrulewidth}{0.5pt}
\setcounter{tocdepth}{3}
\setcounter{secnumdepth}{3}
\usepackage{imakeidx}
\makeindex[columns=2, title=Alphabetical Index, 
           options= -s index.ist]
\title{\Huge Project $\star$ Python}
\author{\textsc{Nguyen Quan Ba Hong}\\
{\small Students at Faculty of Math and Computer Science,}\\ 
{\small Ho Chi Minh University of Science, Vietnam} \\
{\small \texttt{email. nguyenquanbahong@gmail.com}}\\
{\small \texttt{blog. \url{http://hongnguyenquanba.wordpress.com}} 
\footnote{Copyright \copyright\ 2016 by Nguyen Quan Ba Hong, Student at Ho Chi Minh University of Science, Vietnam. This document may be copied freely for the purposes of education and non-commercial research. Visit my site \texttt{\url{http://hongnguyenquanba.wordpress.com}} to get more.}}}
\begin{document}
\frontmatter
\maketitle
\tableofcontents
\mainmatter
\chapter{Basics}
\section{Print Commands}
Python is a very simple language, and has a very straightforward syntax. It encourages programmers to program without boilerplate (prepared) code. The simplest directive in Python is the ``print'' directive. It simply prints out a line (and also includes a newline, unlike in C).

There are two major Python versions, Python 2 and Python 3. Python 2 and 3 are quite different. Python 2 is more widely used and supported. However, Python 3 is more semantically correct, and supports newer features.

For example, one difference between Python 2 and 3 is the \texttt{print} statement. In Python 2, the \texttt{print} statement is not a function, and therefore it is invoked without parentheses. However, in Python 3, it is a function, and must be invoked with parentheses.

To print a string, just write
\begin{verbatim}
print "This line will be printed"
\end{verbatim}
in Python 2 and
\begin{verbatim}
print('This line will be printed')
\end{verbatim}
\section{Indentation}
Python uses indentation for blocks, instead of curly braces. Both tabs and spaces are supported, bu the standard indentation requires standard Python code to use four spaces.
\section{Variables and Types}
Python is completed object oriented, and not ``statically typed''. You do not need to declare variables before using them, or declare their type. Every variable in Python is an object.
\subsection{Numbers}
Python supports two types of numbers - integers and floating point numbers. It also supports complex numbers.

To define an integer, use the following syntax
\begin{verbatim}
myint = 7
\end{verbatim}

To define a floating point number, you may use one of the following notations
\begin{verbatim}
myfloat = 7.0
myfloat = float(7)
\end{verbatim}
\subsection{Strings}
Strings are defined either with a single quote or a double quotes.
\begin{verbatim}
mystring = 'hello'
mystring = "hello"
\end{verbatim}

The difference between the two is that using double quotes makes it easy to include apostrophes (whereas these would terminate the string if using single quotes)
\begin{verbatim}
mystring = "Don't worry about apostrophes"
\end{verbatim}

There are additional variations on defining strings that make it easier to include things such as carriage returns, backslashes and Unicode characters. See in \cite{2}.

Assignments can be done on more than one variable ``simultaneously'' on the same line like this
\begin{verbatim}
a,b = 3,4
\end{verbatim}

Mixing operators between numbers and strings is not supported.
\section{Lists}
Lists are very similar to arrays. They can contain any type of variable, and they can contains as many variables as you wish. Lists can also be iterated over in a very simple manner. Here is an example of how to build a list.
\begin{verbatim}
mylist = []
mylist.append(1)
mylist.append(2)
mylist.append(3)
print(mylist[0]) # prints 1
print(mylist[1]) # prints 2
print(mylist[2]) # prints 3

# prints out 1,2,3
for x in mylist
    print x
\end{verbatim}

Accessing an index which does not exist generates an exception (am error).
\begin{verbatim}
mylist = [1,2,3]
print(mylist[10])
\end{verbatim}
\section{Basic Operators}
This section explains how to use basic operators in Python.
\subsection{Arithmetic Operators}
Just as any other programming languages, the addition, subtraction, multiplication and division operators can be used with numbers.

Another operator available is the modulo \% operator, which returns the integer remainder of the division. dividend\% divisor = remainder.
\begin{verbatim}
remainder = 10 % 3
\end{verbatim}

Using two multiplication symbols makes a power relationship.
\begin{verbatim}
squared = 7 ** 2
cubed = 2 ** 3 
\end{verbatim}
\subsection{Using Operators with Strings}
Python supports concatenating strings using the addition operator.
\begin{verbatim}
a b = "a" + " " + "b"
\end{verbatim}

Python also supports multiplying strings to form a string with a repeating sequence.
\begin{verbatim}
lotsofa = "a" * 10
\end{verbatim}
\subsection{Using Operators with Lists}
Lists can be joined with the addition operators.
\begin{verbatim}
even_digits = [0,2,4,6,8]
odd_digits = [1,3,5,7,9]
all_digits = even_digits = odd_digits
\end{verbatim}

Just as in strings, Python supports forming new lists with a repeating sequence using the multiplication operator.
\begin{verbatim}
print [1,2,3] * 3
\end{verbatim}
\section{String Formatting}
Python uses C-style string formatting to create new, formatted strings. The \% operator is used to format a set of variables enclosed in a ``tupled'' (a fixed size list), together with a format string, which contains normal text together with ``argument specifiers'', special symbols like ``\%s'' and ``\%d''.
\begin{verbatim}
name = "Hong"
print "Hello, %s" % name
\end{verbatim}

To use two or more argument specifiers, use a tuple (parentheses).
\begin{verbatim}
name = "Hong"
age = 20
print "%s is %d years old." % (name, age)
\end{verbatim}

Any object which is not a string can be formatted using the \%s operator as well. The string which returns from the ``repr'' method of that object is formatted as the string. For example
\begin{verbatim}
mylist = [1,2,3]
print "A list: %s" % mylist
\end{verbatim}

Here are some basic argument specifiers you should know.
\begin{enumerate}
\item \verb|%s| String (or any object with a string representation, like numbers).
\item \verb|%d| Integers.
\item \verb|%f| Floating point numbers.
\item \verb|%.<number of digits>f| Floating point numbers with a fixed amount of digits to the right of the dot.
\item \verb|%x/%X| Integers in hex representation (lowercase/uppercase).
\end{enumerate}
\section{Basic String Operators}
Strings are bits of text. They can be defined as anything between quotes.
\begin{verbatim}
astring = "Python"
astring2 = 'Python'
\end{verbatim}

As you can see, the first thing you learned was printing a simple sentence. This sentence was stored by Python as a string. However, instead of immediately printing string out, we will explore the various things you can do to them. You can also use the single quotes to assing a string. However, you will face problems if the value to be assigned itself contains single quotes. For example to assign the string in these bracket, you need to use double quotes only like this
\begin{verbatim}
print "single quotes are ' ' "
print len(astring)
print astring.index("o") # only recognizes the first
print astring.count("P") 
print astring[2:5]
\end{verbatim}
This prints a slice of the string, starting at index 2 and ending at index 4. Most programming languages do this. It makes doing math inside those brackets easier.

If you just have one number in the brackets, it will give you the single character at that index. If you leave out the first number but keep the colon, it will give you a slice from the start to the number you left in. If you leave out the second number, it will give you a slice from the first number to end.

You can even put negative numbers inside the brackets. They are an easy way of starting at the end of the string instead of the beginning. This way, \verb|-3| means ``3rd character from the end''.
\begin{verbatim}
print astring[start:stop:step]
\end{verbatim}
This prints the characters of string from \texttt{start} to \texttt{stop} skipping \texttt{step} characters.

There is no function like \texttt{strrev} in C to reverse a string. But with the above mentioned type of slice syntax you can easily reverse a string like this
\begin{verbatim}
print astring[::-1]
\end{verbatim}
This
\begin{verbatim}
print astring.upper()
print astring.lower()
\end{verbatim}
make a new string with all letters converted to uppercase and lowercase, respectively.
\begin{verbatim}
print astring.startswith("Hello")
print astring.endswith("Bye")
\end{verbatim}
This is used to determine whether the string starts with something or ends with something, respectively. The first one will print \texttt{True}, as the string starts with \verb|"Hello"|. The second one will print \texttt{False}, as the string certainly does not end with \verb|"Bye"|.
\begin{verbatim}
afewwords = astring.split(" ")
\end{verbatim}
This splits the string into a bunch of strings grouped together in a list.
\section{Conditions}
Python uses boolean variables to evaluate conditions. The boolean values \texttt{True} and \texttt{False} are returned when an expression is compared or evaluated. 

Notice that variable assignment is done using a single equals operators \verb|=|, whereas comparison between two variables is done using the double equals operator \verb|==|. The ``not equals'' operator is marked as \verb|!=|.
\subsection{Boolean Operators}
The \texttt{and} and \texttt{or} boolean operators allow building complex boolean expressions.
\begin{verbatim}
if x == 1 and c == "A":
    print('x = 1, c = A')
if x == 1 or c == "A":
    print('x = 1 or c = A')
\end{verbatim}
\subsection{The \texttt{in} Operator}
The \texttt{in} operator could be used to check if a specified object exists within an iterable object container, such as a list
\begin{verbatim}
if c in ["a","A"]:
    print('x is a or A')
\end{verbatim}
Python uses indentation to define code blocks, instead of brackets. The standard Python indentation is 4 spaces, although tabs and any other space size will work, as long as it is consistent. Notice that code blocks do not need any termination.

Here is an example for using Python's \texttt{if} statement using code blocks
\begin{verbatim}
if <statement is true>:
    <do something>
    ...
elif <another statement is true>: # else if
    <do something else>
    ...
else:
    <do another thing>
    ...
\end{verbatim}

A statement is evaluated as true if one the the following is correct.
\begin{enumerate}
\item The \texttt{True} boolean variable is given, or calculated using an expression, such as an arithmetic comparision.
\item An object which is not considered ``empty'' is passed.
\end{enumerate}

Here are some examples for objects which are considered as empty.
\begin{enumerate}
\item An empty string \verb|""|.
\item An empty list \verb|[]|.
\item The number zero \verb|0|.
\item The false boolean variable \verb|False|.
\end{enumerate}
\subsection{The \texttt{is} Operator}
Unlike the double equals operator \verb|==|, the \texttt{is} operator does no match the values of variables, but the instances themselves. For example
\begin{verbatim}
x = [1,2,3]
y = [1,2,3]
print x == y # Prints out True
print x is y # Prints out False
\end{verbatim}
\subsection{The \texttt{not} Operator}
Using \texttt{not} before a boolean expression inverts it.
\begin{verbatim}
print not False # Prints out True
print (not False) == (False) # Print out False
\end{verbatim}
\section{Loops}
There are two types of loops in Python, \texttt{for} and \texttt{while}.
\subsection{\texttt{for} Loop}
For loops iterate over a given sequence. For example
\begin{verbatim}
primes = [2,3,5,7]
for prime in primes:
    print prime
\end{verbatim}

For loops can iterate over a sequence of numbers using the \texttt{range} and \texttt{xrange} functions. The difference between \texttt{range} and \texttt{xrange} is that the \texttt{range} function returns a new list with numbers of that specified range, whereas \texttt{xrange} returns an iterator, which is more efficient. Python 3 uses the \texttt{range} function, which acts like \texttt{xrange}. Note that the \texttt{xrange} function is zero based.
\begin{verbatim}
# Prints out the numbers 0,1,2,3,4
for x in xrange(5): # or range(5)
    print x
# Prints out 3,4,5
for x in xrange(3,6): # or range(3,6)
    print x
# Prints out 3,5,7
for x in xrange(3,8,2): # or range(3,8,2)
    print x
\end{verbatim}
\subsection{\texttt{while} Loops}
\texttt{While} loops repeat as long as a certain boolean condition is met. For example
\begin{verbatim}
# Prints out 0,1,2,3,4
count = 0
while count < 5:
    print count
    count += 1 
\end{verbatim}
\subsection{\texttt{break} and \texttt{continue} Statements}
\texttt{break} is used to exit for a loop or a \texttt{while} loop, whereas \texttt{continue} is used to skip the current block, and return to the \texttt{for} or \texttt{while} statement. A few examples
\begin{verbatim}
# Prints out 0,1,2,3,4
count = 0
while True:
    print count
    count += 1
    if count >= 5:
        break
# Prints out only odd numbers 1,3,5,7,9
for x in xrange(10):
    if x % 2 == 0:
        continue
    print x
\end{verbatim}
\subsection{\texttt{else} for Loops}
Unlike languages like C, C++, etc., we can use \texttt{else} for loops. When the loop condition of \texttt{for} or \texttt{while} statement fails then code part in \texttt{else} is executed. If \texttt{break} statement is executed inside for loop then the \texttt{else} part is skipped. Not that \texttt{else} part is executed if there is a \texttt{continue} statement. For example
\begin{verbatim}
# Prints out 0,1,2,3,4 and then it prints "count value reached 5"
count = 0
while(count < 5):
    print count
    count += 1
else:
    print "count value reached %d" %(count)
# Prints out 1,2,3,4
for i in xrange(1,10):
    if(i % 5 == 0):
        break
    print i
else:
    print "this is not printed because for loop is terminated."
\end{verbatim}
\section{Functions}
Functions are a convenient way to divide your code into useful blocks, allowing us to order our code, make it more readable, reuse it and save some time. Also functions are a key way to define interfaces so programmers can share their code.
\subsection{Write Functions in Python}
Python makes use of blocks.

A block is a are of code of written in the format of
\begin{verbatim}
block_head:
    1st block line
    2nd block line
    ...
\end{verbatim}
Where a bloc line is more Python code (even another block), and the block head is of the following format
\begin{verbatim}
block_keyword
key_name(argument1,argument2,...)
\end{verbatim}
Block keywords you already know are \texttt{if}, \texttt{for} and \texttt{while}.

Functions in Python are defined using the block keyword \texttt{def}, followed with the function's name as the block's name. For example
\begin{verbatim}
def my_function():
    print "Hi"
\end{verbatim}

Functions may also receive arguments (variables passed from the caller to the function).

Functions may return a value to the caller, using the keyword \texttt{return}. For example
\begin{verbatim}
def sum_two_numbers(a,b):
    return a + b 
\end{verbatim}
\subsection{Call Functions in Python}
Simply write the function's name followed by (), placing any required arguments within the brackets.
\begin{verbatim}
myfunction() 
x = sum_two_numbers(1,2)
\end{verbatim}
\section{Classes and Objects}
Objects are an encapsulation of variables and functions into a single entity. Objects gets their variables and functions from classes. Classes are essentially a template to create your objects.

A very basic class would look something like this
\begin{verbatim}
class MyClass
    variable = ...
    def function(f):
        ...
\end{verbatim}

We will explain why you have to include that ``self'' as a parameter a little bit later. First, to assign the above class (template) to an object you would do the following.
\begin{verbatim}
myobjectx = MyClass()
\end{verbatim}

Now the variable \texttt{myobjectx} holds an object of the class \texttt{MyClass} that contains the variable and the function defined within the class called \texttt{MyClass}.
\subsection{Accessing Object Variables}
To access the variable inside of the newly created object \texttt{myobjectx} you would do the following.
\begin{verbatim}
myobjectx.variable
\end{verbatim}

You can create multiple different objects that are of the same class (have the same variables and functions defined). However, each object contains independent copies of the variables defined in the class.
\subsection{Accessing Object Functions}
To access a function inside of an object you use notation similar to accessing a variable
\begin{verbatim}
myobjectx.function()
\end{verbatim}
\section{Dictionaries}
A dictionary is a data type similar to arrays, but works with keys and values instead of indexes. Each value stored in a dictionary can be accessed using a key, which is any type of object (a string, a number, a list, etc.) instead of using its index to address it.

For example, a database of phone numbers could be stored using a dictionary like this
\begin{verbatim}
phonebook = {}
phonebook["John"] = 938477566
phonebook["Jack"] = 938377264
phonebook["Jill"] = 947662781
\end{verbatim}

Alternatively, a dictionary can be initialized with the same values in the following notation
\begin{verbatim}
phonebook = {
    "John" : 938477566,
    "Jack" : 938377264,
    "Jill" : 947662781
}
\end{verbatim}
\subsection{Iterating Over Dictionaries}
Dictionaries can be iterated over, just like a list. However, a dictionary, unlike a list, does not keep the order of the values stored in it. To iterate over key value pairs, use the following syntax
\begin{verbatim}
for name, number in phonebook.iteritems():
    print "Phone number of %s is %d" %(name,number)
\end{verbatim}
\subsection{Removing a value}
To remove a specified index, use either one of the following notations
\begin{verbatim}
del phonebook["John"]
\end{verbatim}
or
\begin{verbatim}
phonebook.pop("John")
\end{verbatim}
\section{Modules and Packages}
Modules in Python are simply Python files with the \texttt{.py} extension, which implement a set of functions. Modules are imported from other modules using the \texttt{import} command.

To import a module, we use the \texttt{import} command. Check out the full list of built-in modules in the Python standard library in \cite{3}.

The first time a module is loaded into a running Python script, it is initialized by executing the code in the module once. If another module in your code imports the same module again, it will not be loaded twice but once only - so local variables inside the module act as a ``singleton'' - they are initialized only once.

If we want to import the module \texttt{urllib}, which enables us to create and read data from URLs, we simply \texttt{import} the module
\begin{verbatim}
# import the library
import urllib
# use it
urllib.urlopen(...)
\end{verbatim}
\subsection{Exploring Built-in Modules}
Two very important functions come in handy when exploring modules in Python - the \texttt{dir} and \texttt{help} functions.

We can look for which functions are implemented in each module by using the \texttt{dir} function.
\begin{verbatim}
>>> import urllib
>>> dir(urllib)
['ContentTooShortError', 'FancyURLopener', 'MAXFTPCACHE',
'URLopener', '__all__', '__builtins__', '__doc__', '__file__',
'__name__', '__package__', '__version__', '_ftperrors',
'_get_proxies', '_get_proxy_settings', '_have_ssl', '_hexdig',
'_hextochr', '_hostprog', '_is_unicode', '_localhost', '_noheaders',
'_nportprog', '_passwdprog', '_portprog', '_queryprog', '_safe_map',
'_safe_quoters', '_tagprog', '_thishost', '_typeprog', '_urlopener',
'_userprog', '_valueprog', 'addbase', 'addclosehook', 'addinfo',
'addinfourl', 'always_safe', 'basejoin', 'c', 'ftpcache',
'ftperrors', 'ftpwrapper', 'getproxies', 'getproxies_environment',
'getproxies_macosx_sysconf', 'i', 'localhost', 'main', 'noheaders',
'os', 'pathname2url', 'proxy_bypass', 'proxy_bypass_environment',
'proxy_bypass_macosx_sysconf', 'quote', 'quote_plus', 'reporthook',
'socket', 'splitattr', 'splithost', 'splitnport', 'splitpasswd',
'splitport', 'splitquery', 'splittag', 'splittype', 'splituser',
'splitvalue', 'ssl', 'string', 'sys', 'test', 'test1', 'thishost',
'time', 'toBytes', 'unquote', 'unquote_plus', 'unwrap',
'url2pathname', 'urlcleanup', 'urlencode', 'urlopen', 'urlretrieve']
\end{verbatim}

When we find the function in the module we want to use, we can read about it more using the \texttt{help} function, inside the Python interpreter.
\begin{verbatim}
help(urllib.urlopen)
\end{verbatim}
\subsection{Writing Modules}
Writing Python modules is very simple. To create a module of your own, simply create a new \texttt{.py} file with the module name, and then import it using the Python file name (without the \texttt{.py} extension) using the \texttt{import} command.
\subsection{Writing Packages}
Packages are namespaces which contain multiple packages and modules themselves. They are simply directories, but with a twist.

Each package in Python is a directory which must contain a special file called \verb|_init_.py|. This file can be empty, and it indicates that the directory it contains is a Python package, so it can be imported the same way a module can be imported.

If we create a directory called \texttt{foo}, which marks the package name, we can then create a module inside that package called \texttt{bar}. We also must not forget to add the \verb|_init_.py| file inside the \texttt{foo} directory.

To use the module \texttt{bar}, we can import it in two ways.
\begin{verbatim}
import foo.bar
\end{verbatim}
or
\begin{verbatim}
from foo import bar
\end{verbatim}

In the first method, we must use the \texttt{foo} prefix whenever we access the module \texttt{bar}. In the second method, we don't, because we import the module to our module's namespace.

The \verb|_init_.py| file can also decide which modules the packages exports as the API, while keeping other modules internal, by overriding the \verb|_all_| variable, like so
\begin{verbatim}
__init__.py:

__all__ = ["bar"]
\end{verbatim}
\chapter{Advanced Tutorials}
\section{Generators}
Generators are very easy to implement, but a bit difficult to understand.

Generators are used to create interators, but with a different approach. Generators are simple functions which return an iterable set of items, one at a time, in a special way.

When an iteration over a set of item starts using the statement, the generator is run. Once the generator's function code reaches a ``yield'' statement, the generator yields its execution back to the \texttt{for} loop, returning a new value from the set. The generator function can generate as many values  (possibly infinite) as it wants, yielding each one in its turn.

Here is a simple example of generator function which returns 7 random integers.
\begin{verbatim}
import random
def lottery():
    # returns 6 numbers between 1 and 40
    for i in xrange(6):
        yield random.randint(1,40)
    # returns a 7th number between 1 and 15
    yield random.randint(1,15)
for random_number in lottery()
    print "And the next number is... %d" % random_number
\end{verbatim}

This function decides how to generate the random numbers on its own, and executes the yield statements one at a time, pausing in between to yield execution back to the main for loop.
\section{List Comprehensions}
List Comprehensions is a very powerful tool, which creates a new list based on another list, in a single, readable line.

For example, let's say we need to create a list of integers which  specify the length of each word in a certain sentence, but only if the word is not the word \texttt{the}.
\begin{verbatim}
sentence = "the quick brown fox jumps over the lazy dog"
words = sentence.split()
word_lengths = [] 
for word in words
    if word != "the":
        word_lengths.append(len(word))
\end{verbatim}

Using a list comprehension, we could simplify this process to this notation.
\begin{verbatim}
sentence = "the quick brown fox jumps over the lazy dog"
words = sentence.split()
word_lengths = [len(word) for word in words if word != "the"]
\end{verbatim}
\section{Multiple Function Arguments}
Every function in Python receives a predefined number of arguments, if declared normally, like this
\begin{verbatim}
def myfunction(first,second,third):
    # do something with the 3 variables
    ...
\end{verbatim}

It is possible to declare functions which receive a variable number of arguments, using the following syntax. 
\begin{verbatim}
def foo(first,second,third,*therest):
    print "First: %s" % first
    print "Second: %s" % second
    print "Third: %s" % third
    print "And all the rest... %s" % list(therest)
\end{verbatim}

The \texttt{therest} variable is a list of variables, which receives all arguments which were given to the \texttt{foo} function after the first 3 arguments.

It is also possible to send function arguments by keyword, so that the order of the argument does not matter, using the following syntax.
\begin{verbatim}
def bar(first,second,third,**options):
    if options.get("action") == "sum":
        print "The sum is: %d" % (first + second + third)
    if options.get("number") == "first":
        return first
result = bar(1,2,3,action = "sum",number = "first")
print "Result: %d" % result
\end{verbatim}

The \texttt{bar} function receives 3 arguments. If an additional ``action'' argument is received, and it instructs on summing up the numbers, then the sum is printed out. Alternatively, the function also knows it must return the first argument, if a \texttt{return} argument is received which instructs it.
\section{Regular Expressions}
Regular Expressions (sometimes shortened to \texttt{regexp, regex} or \texttt{re} are a tool for matching patterns in text. In Python, we have the \texttt{re} module. The applications for regular expressions are wide-spread, but they are fairly complex, so when contemplating using a \texttt{regex} for a certain task, think about alternatives, and come to \texttt{regexes} as a last resort.

An example \texttt{regex} is 
\begin{verbatim}
r"^(From|To|Cc).*?python-list@python.org"
\end{verbatim}
Now for an explanation: the caret \verb|^| matches text at the beginning of a line. The following group, the part with \verb&(From|To|Cc)& means that the line has to start with one of the words that are separated by the pipe \verb&|&. That is called the \texttt{OR} operator, and the \texttt{regex} will match if the line starts with any of the words in the group. The \verb|.*?| means to un-greedily match any number of characters, except the newline \verb|\n| character. The un-greedy part means to match as few repetitions as possible. The \verb|.| character means any non-newline character, the \verb|*| means to repeat 0 or more times, and the \verb|?| character makes it un-greedy.

So, the following lines would be matched by that \texttt{regex} 
\begin{verbatim}
From: python-list@python.org 
To: !asp]<,. python-list@python.org
\end{verbatim}

A complete reference for the \texttt{re} syntax is available at \cite{4}.
\section{Exception Handling}
When programming, errors happen. It's just a fact of life. Perhaps the user gave bad input. maybe a network resource was unavailable. Maybe the program ran out of memory. Or the programmer may have even made a mistake.

Python's solution to errors are exceptions. But sometimes you don't want exceptions to completely stop the program. You might want to do something special when an exception is raised. This is done in a \texttt{try/except} block.

For more details on handling exceptions, look no further than \cite{5}.
\section{Sets}
Sets are lists with no duplicate entries. Let's say you want to collect a list of words used in a paragraph.
\begin{verbatim}
print set("my name is Eric and Eric is my name".split())
\end{verbatim}
This will print out a list containing \texttt{my, name, is, Eric} and finally \texttt{and}. Since the rest of the sentence uses words which are already in the set, they are no inserted twice.

Sets are a powerful tool in Python since they have the ability to calculate differences and intersections between other sets. For example, say you have a list of participants in events A and B.
\begin{verbatim}
a = set(["Jake", "John", "Eric"])
b = set(["John", "Jill"])
\end{verbatim}

To find out which members attended both events, you may use the intersection method.
\begin{verbatim}
>>> a.intersection(b)
set(['John'])
>>> b.intersection(a)
set(['John'])
\end{verbatim}

To find out which members attended only one of the events, use the symmetric difference method
\begin{verbatim}
>>> a.symmetric_difference(b)
set(['Jill', 'Jake', 'Eric'])
>>> b.symmetric_difference(a)
set(['Jill', 'Jake', 'Eric'])
\end{verbatim}

To find out which members attended only one event and not the other, use the difference method.
\begin{verbatim}
>>> a.difference(b)
set(['Jake', 'Eric'])
>>> b.difference(a)
set(['Jill'])
\end{verbatim}

To receive a list of all participants, use the union method.
\begin{verbatim}
>>> a.union(b)
set(['Jill', 'Jake', 'John', 'Eric'])
\end{verbatim}
\section{Serialization}
Python provides built-in JSON libraries to encode and decode JSON.

In Python 2.5, the \texttt{simplejson} module is used, whereas in Python 2.7, the \texttt{json} module is used.

In order to use the \texttt{json} module, it must first be imported.
\begin{verbatim}
import json
\end{verbatim}

There are two basic formats for JSON data. Either in a string or the object datastructure. The object datastructure, in Python, consists of lists and dictionaries nested inside each other. The object datastructure allows one to use Python methods (for lists and dictionaries) to add, list, search and remove elements from the datastructure. The String format is mainly used to pass the data into another program or load into a datastructure.

To load JSON back to a data structure, use the \texttt{loads} method. This method takes a string and turns it back into the \texttt{json} object datastructure.
\begin{verbatim}
print json.loads(json_string)
\end{verbatim}

To encode a data structure to JSON, use the \texttt{dump} method. This method takes an object and returns a String.
\begin{verbatim}
json_string = json.dumps([1,2,3,"a","b","c"])
\end{verbatim}

Python supports a Python proprietary data serialization method called pickle (and a faster alternative called cPickle).

You can use it exactly the same way.
\begin{verbatim}
import cPickle
pickled_string = cPickle.dumps([1,2,3,"a","b","c"])
print cPickle.loads(pickled_string)
\end{verbatim}
\section{Partial Functions}
You can create partial functions in Python by using the partial function from the \texttt{functools} library.

Partial functions allow one to derive a function with \texttt{x} parameters to a function with fewer parameters and fixed values set for the more limited function.

Imported required
\begin{verbatim}
from functools import partial
\end{verbatim}

For example
\begin{verbatim}
from functools import partial
def multiply(x,y):
    return x*y
# create a new function that multiplies by 2
dbl = partial(multiply,2)
print dbl(4)
\end{verbatim}
\textbf{Note.} The default values will start replacing variables from the left. The \texttt{2} will replace \texttt{x}. \texttt{y} will equal 4 when \texttt{dbl(4)} is called.
\section{Code Introspection}
Code introspection is the ability to examine classes, functions and keywords to know what they are, what they do and what they know.

Python provides several functions and utilities for code introspection.
\begin{verbatim}
help()
dir()
hasattr()
id()
type()
repr()
callable()
issubclass()
isinstance()
_doc_
_name_
\end{verbatim}
\section{Closures}
A Closure is a function object that remembers values in enclosing scopes even if they are not present in memory.

Firstly, a \textit{Nested Function} is a function defined inside another function. It is very important to note that the nested functions can access the variables of the enclosing scope. However, at least in Python, they are only readonly. However, one can use the ``nonlocal'' keyword explicitly with these variables in order to modify them.

For example
\begin{verbatim}
def transmit_to_space(message):
    "This is the enclosing function"
    def data_transmitter():
        "The nested function"
        print(message)
    data_transmitter()
\end{verbatim}
This works well as the \verb|data_transmitter| function can access the \texttt{message}. To demonstrate the use of the ``nonlocal'' keyword, consider this
\begin{verbatim}
def print_msg(number)
    def printer():
        "Here we are using the nonlocal keyword"
        nonlocal number
        number = 3
        print(number)
    print()
    print(number)
print_msg(9)
\end{verbatim}

Now, how about we return the function object rather than calling the nested function within. Remember that functions are even object.
\begin{verbatim}
def transmit_to_space(message):
    "This is the enclosing function"
    def data_transmitter():
        "The nested function"
        print(message)
    return data_transmitter
\end{verbatim}
And we call the function as follows
\begin{verbatim}
>>> fun2 = transmit_to_space("Burn the Sun!")
>>> fun2()
Burn the Sun!
\end{verbatim}

Even though the execution of the \verb|transmit_to_space()| was completed, the message was rather preserved. This technique by which the data is attached to some code even after end of those other original functions is called as closures in Python.\\
\\
\textbf{Advantage 2.1.} Closures can avoid use of global variables and provides some form of data hiding, e.g., when there are few methods in a class, use closures instead.

Also, Decorators in Python make extensive use of closures.
\section{Decorators}
Decorators allow you to make simple modifications to callable objects like functions, methods and classes. We shall deal with functions for this tutorial. The syntax
\begin{verbatim}
@decorator
def functions(arg):
    return "Return"
\end{verbatim}
is equivalent to
\begin{verbatim}
def function(arg):
return "Return"
function = decorator(function) # this passes the function to the 
# decorator, and reassigns it to the functions
\end{verbatim}

As you may have seen, a decorator is just another function which takes a functions and returns one. For example you could do this
\begin{verbatim}
def repeater(old_function):
    def new_function(*args,**kwds):
ments for how *args and **kwds works
        old_function(*args, **kwds) # Run the old function
        old_function(*args, **kwds) # Do it twice
    return new_function # Have to return the new_function
    # or it wouldn't reassign it to the value
\end{verbatim}

This would make a function repeat twice.
\begin{verbatim}
>>> @repeater
def Multiply(num1, num2):
    print num1*num2

>>> Multiply(2, 3)
6
6
\end{verbatim}

You can also make it change the output
\begin{verbatim}
def Double_Out(old_function):
    def new_function(*args, **kwds):
        # modify the return value
        return 2*old_function(*args, **kwds) 
    return new_function
\end{verbatim}
change input
\begin{verbatim}
def Double_In(old_function):
    # only words if the old function has one argument
    def new_function(arg): 
        return old_function(arg*2) # modify the argument passed
    return new_function    
\end{verbatim}
and do checking 
\begin{verbatim}
def Check(old_function):
    def new_function(arg):
        # This causes an error
        # which is better than it doing the wrong thing
        if arg < 0: raise ValueError, "Negative Argument"
        old_function(arg)
    return new_function        
\end{verbatim}

Let's say you want to multiply the output by a variable amount. You could do
\begin{verbatim}
def Multiply(multiplier):
    def Multiply_Generator(old_function):
        def new_function(*args, **kwds):
            return multiplier*old_function(*args, **kwds)
        return new_function
    return Multiply_Generator # it returns the new generator
\end{verbatim}

Now, you could do
\begin{verbatim}
@Multiply(3) # Multiply is not a generator, but Multiply(3) is
def Num(num):
    return num
\end{verbatim}

You can do anything you want with the old function, even completely ignore it. Advanced decorators can also manipulate the doc string and argument number. For some snazzy decorators, see in \cite{6}.\\
\\
\\
\\
\\
\begin{center}
\textsc{The End}
\end{center}
\newpage
\begin{thebibliography}{999}
\bibitem {1} \url{http://www.learnpython.org/}
\bibitem {2} \url{https://docs.python.org/3.6/contents.html}
\bibitem {3} \url{https://docs.python.org/2/library/}
\bibitem {4} \url{https://docs.python.org/3/library/re.html#regular-expression-syntax "RE syntax}
\bibitem {5} \url{https://docs.python.org/3/tutorial/errors.html#handling-exceptions}
\bibitem {6} \url{https://wiki.python.org/moin/PythonDecoratorLibrary}
\end{thebibliography}
\end{document}


