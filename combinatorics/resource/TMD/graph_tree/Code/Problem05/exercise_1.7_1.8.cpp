#include <iostream>
#include <vector>
#include <random> // For std::random_device, std::mt19937, std::uniform_int_distribution
#include <numeric> // For std::iota (optional, for verification)

// A type alias for graph/tree representation for better readability.
// We use an adjacency list, where each index represents a parent node,
// and the vector at that index stores its children.
using GraphAdjList = std::vector<std::vector<int>>;

/**
 * @class TreeGenerator
 * @brief A class to generate various types of trees.
 *
 * This class provides methods to programmatically construct trees based on
 * specific rules, such as complete binary trees or random trees.
 * It simulates the abstract operations like `new_node` and `new_edge`.
 */
class TreeGenerator {
private:
    GraphAdjList adj;
    int num_nodes = 0;

public:
    /**
     * @brief Resets the generator to an empty state.
     */
    void clear() {
        adj.clear();
        num_nodes = 0;
    }

    /**
     * @brief Simulates the `new_node` operation.
     * Adds a new node to the graph and returns its index.
     * @return The integer index of the newly created node.
     */
    int new_node() {
        adj.push_back({}); // Add an empty list of children for the new node
        return num_nodes++;
    }

    /**
     * @brief Simulates the `new_edge` operation for a directed tree.
     * Adds a directed edge from a parent to a child.
     * @param parent The index of the parent node.
     * @param child The index of the child node.
     */
    void new_edge(int parent, int child) {
        if (parent < num_nodes && child < num_nodes) {
            adj[parent].push_back(child);
        }
    }

    /**
     * @brief Exercise 1.7: Generates a complete binary tree.
     *
     * A complete binary tree is a binary tree in which every level, except
     * possibly the last, is completely filled, and all nodes in the last level
     * are as far left as possible. This is efficiently generated by linking
     * each node `i` to its parent at `(i-1)/2`.
     *
     * @param n The total number of nodes in the tree.
     * @return The generated tree as an adjacency list.
     */
    GraphAdjList generate_complete_binary_tree(int n) {
        clear();
        if (n <= 0) return adj;

        // Create all nodes first
        for (int i = 0; i < n; ++i) {
            new_node();
        }

        // Create edges by connecting each child to its parent
        // We start from node 1, as node 0 is the root and has no parent.
        for (int i = 1; i < n; ++i) {
            int parent_idx = (i - 1) / 2;
            new_edge(parent_idx, i);
        }
        return adj;
    }

    /**
     * @brief Exercise 1.8: Generates a random tree on n vertices.
     *
     * This algorithm works by iteratively adding a new node and connecting it
     * to a randomly chosen existing node. This guarantees that the resulting
     * graph is connected and has exactly n-1 edges, which is the definition of a tree.
     *
     * @param n The total number of nodes in the tree.
     * @return The generated random tree as an adjacency list.
     */
    GraphAdjList generate_random_tree(int n) {
        clear();
        if (n <= 0) return adj;
        
        // Setup for high-quality random number generation
        std::random_device rd;
        std::mt19937 gen(rd());

        // Create the first node
        new_node();

        // Iteratively add the remaining n-1 nodes
        for (int i = 1; i < n; ++i) {
            new_node();
            // Define the range of existing nodes to connect to: [0, i-1]
            std::uniform_int_distribution<> distrib(0, i - 1);
            int j = distrib(gen); // Pick a random existing node `j`
            
            // Connect the new node `i` to the existing node `j`
            new_edge(j, i);
        }
        return adj;
    }
};

/**
 * @brief Helper function to print a tree from its adjacency list representation.
 * @param tree The tree to print.
 * @param name A descriptive name for the tree.
 */
void print_tree(const GraphAdjList& tree, const std::string& name) {
    std::cout << "--- " << name << " ---" << std::endl;
    if (tree.empty()) {
        std::cout << "  (Empty Tree)" << std::endl;
        return;
    }
    for (size_t i = 0; i < tree.size(); ++i) {
        std::cout << "  Node " << i << " -> { ";
        for (size_t j = 0; j < tree[i].size(); ++j) {
            std::cout << tree[i][j] << (j == tree[i].size() - 1 ? "" : ", ");
        }
        std::cout << " }" << std::endl;
    }
    std::cout << "--------------------" << std::endl;
}


// =================================================================================
// MAIN FUNCTION - DEMONSTRATION FOR EXERCISES 1.7 & 1.8
// =================================================================================
int main() {
    TreeGenerator gen;
    int num_nodes = 10;

    std::cout << "=====================================================" << std::endl;
    std::cout << "      Tree Generator Demo (Exercises 1.7 & 1.8)      " << std::endl;
    std::cout << "=====================================================" << std::endl;

    // --- Exercise 1.7 ---
    std::cout << "\nGenerating a Complete Binary Tree with " << num_nodes << " nodes (Exercise 1.7):\n" << std::endl;
    GraphAdjList cbt = gen.generate_complete_binary_tree(num_nodes);
    print_tree(cbt, "Complete Binary Tree");
    
    // --- Exercise 1.8 ---
    std::cout << "\nGenerating a Random Tree with " << num_nodes << " nodes (Exercise 1.8):\n" << std::endl;
    std::cout << "(Note: The structure will be different each time you run the program)\n" << std::endl;
    GraphAdjList random_tree = gen.generate_random_tree(num_nodes);
    print_tree(random_tree, "Random Tree");

    std::cout << "=====================================================" << std::endl;

    return 0;
}