\documentclass{article}
\usepackage[backend=biber,natbib=true,style=alphabetic,maxbibnames=50]{biblatex}
\addbibresource{/home/nqbh/reference/bib.bib}
\usepackage[utf8]{vietnam}
\usepackage{tocloft}
\renewcommand{\cftsecleader}{\cftdotfill{\cftdotsep}}
\usepackage[colorlinks=true,linkcolor=blue,urlcolor=red,citecolor=magenta]{hyperref}
\usepackage{amsmath,amssymb,amsthm,enumitem,fancyvrb,float,graphicx,mathtools,tikz}
\usetikzlibrary{angles,calc,intersections,matrix,patterns,quotes,shadings}
\allowdisplaybreaks
\newtheorem{assumption}{Assumption}
\newtheorem{baitoan}{}
\newtheorem{cauhoi}{Câu hỏi}
\newtheorem{conjecture}{Conjecture}
\newtheorem{corollary}{Corollary}
\newtheorem{dangtoan}{Dạng toán}
\newtheorem{definition}{Definition}
\newtheorem{dinhly}{Định lý}
\newtheorem{dinhnghia}{Định nghĩa}
\newtheorem{example}{Example}
\newtheorem{ghichu}{Ghi chú}
\newtheorem{hequa}{Hệ quả}
\newtheorem{hypothesis}{Hypothesis}
\newtheorem{lemma}{Lemma}
\newtheorem{luuy}{Lưu ý}
\newtheorem{nhanxet}{Nhận xét}
\newtheorem{notation}{Notation}
\newtheorem{note}{Note}
\newtheorem{principle}{Principle}
\newtheorem{problem}{Problem}
\newtheorem{proposition}{Proposition}
\newtheorem{question}{Question}
\newtheorem{remark}{Remark}
\newtheorem{theorem}{Theorem}
\newtheorem{vidu}{Ví dụ}
\usepackage[left=1cm,right=1cm,top=5mm,bottom=5mm,footskip=4mm]{geometry}
\def\labelitemii{$\circ$}
\DeclareRobustCommand{\divby}{%
	\mathrel{\vbox{\baselineskip.65ex\lineskiplimit0pt\hbox{.}\hbox{.}\hbox{.}}}%
}
\setlist[itemize]{leftmargin=*}
\setlist[enumerate]{leftmargin=*}

\title{Data Structures {\it\&} Algorithms -- Cấu Trúc Dữ Liệu {\it\&} Giải Thuật}
\author{Nguyễn Quản Bá Hồng\footnote{A scientist- {\it\&} creative artist wannabe, a mathematics {\it\&} computer science lecturer of Department of Artificial Intelligence {\it\&} Data Science (AIDS), School of Technology (SOT), UMT Trường Đại học Quản lý {\it\&} Công nghệ TP.HCM, Hồ Chí Minh City, Việt Nam.\\E-mail: {\sf nguyenquanbahong@gmail.com} {\it\&} {\sf hong.nguyenquanba@umt.edu.vn}. Website: \url{https://nqbh.github.io/}. GitHub: \url{https://github.com/NQBH}.}}
\date{\today}

\begin{document}
\maketitle
\begin{abstract}
	This text is a part of the series {\it Some Topics in Advanced STEM \& Beyond}:
	
	{\sc url}: \url{https://nqbh.github.io/advanced_STEM/}.
	
	Latest version:
	\begin{itemize}
		\item {\it Data Structures \& Algorithms -- Cấu Trúc Dữ Liệu \& Giải Thuật}.
		
		PDF: {\sc url}: \url{https://github.com/NQBH/advanced_STEM_beyond/blob/main/data_structure_algorithm/lecture/NQBH_data_structure_algorithm_lecture.pdf}.
		
		\TeX: {\sc url}: \url{https://github.com/NQBH/advanced_STEM_beyond/blob/main/data_structure_algorithm/lecture/NQBH_data_structure_algorithm_lecture.tex}.
		\item {\it }.
		
		PDF: {\sc url}: \url{.pdf}.
		
		\TeX: {\sc url}: \url{.tex}.
	\end{itemize}
\end{abstract}
\tableofcontents

%------------------------------------------------------------------------------%

\section{Array in C++ STL}

%------------------------------------------------------------------------------%

\section{Vector in C++ STL}
\textbf{\textsf{Resources -- Tài nguyên.}}
\begin{enumerate}
	\item \href{https://www.geeksforgeeks.org/vector-in-cpp-stl/}{Geeks4Geeks{\tt/}vector in C++ STL}
\end{enumerate}

\begin{definition}
	{\rm C++ vector} is a dynamic array that stores collection of elements of same type in contiguous memory. It has the ability to resize itself automatically when an element is inserted or deleted.
	
	-- {\rm C++ vector} là một mảng động lưu trữ tập hợp các phần tử cùng loại trong bộ nhớ liền kề. Nó có khả năng tự động thay đổi kích thước khi một phần tử được chèn vào hoặc xóa.
\end{definition}

%------------------------------------------------------------------------------%

\subsection{Create vectors -- Tạo vectors}
\textbf{\textsf{Resources -- Tài nguyên.}}
\begin{enumerate}
	\item \href{https://www.geeksforgeeks.org/initialize-a-vector-in-cpp-different-ways/}{Geeks4Geeks{\tt/}8 ways to initialize vector in C++}.
\end{enumerate}
Before creating a vector, we must know that a vector is defined as the {\tt std::vector} class template in the {\tt<vector>} header file.
\begin{verbatim}
vector<T> v;
\end{verbatim}
where {\tt T} is the type of elements \& {\tt v} is the name assigned to the vector.

Now we are creating an instance of {\tt std::vector} class. This requires us to provide the type of elements as template parameter.
\begin{Verbatim}[numbers=left,xleftmargin=5mm]
#include <bits/stdc++.h>
using namespace std;

int main() {
    // Creating an empty vector
    vector<int> v1;	
    return 0;
}
\end{Verbatim}
We can also provide the values to be stored in the vector inside {\tt\{\}} curly braces. This process is called {\it initialization}.
\begin{Verbatim}[numbers=left,xleftmargin=5mm]
#include <bits/stdc++.h>
using namespace std;
void printVector(vector<int>& v) {
    for (auto x: v) {
        cout << x << " ";
    }
    cout << endl;
}

int main() {	
    // Creating a vector of 5 elements from initializer list
    vector<int> v1 = {1, 4, 2, 3, 5};
	
    // Creating a vector of 5 elements with default value
	vector<int> v2(5, 9);
	
    printVector(v1);
    printVector(v2);
	return 0;
}
\end{Verbatim}
Output:
\begin{verbatim}
1 4 2 3 5 
9 9 9 9 9
\end{verbatim}
Statement \verb|vector<int> v1 = {1, 4, 2, 3, 5}| initializes a vector with given values. Statement \verb|vector<int> v2(5, 9)| creates a vector of size 5 where each element initialized to 9.

\begin{remark}
	Statement \verb|vector<int> v|= $\{v_1,v_2,\ldots,v_n\}$ initializes a vector with given values. Statement \verb|vector<int> v(n, a)| creates a vector of size $n\in\mathbb{N}^\star$ where each element initialized to $a\in\mathbb{Z}$.
\end{remark}
Initializing a vector means assigning some initial values to the {\tt std::vector} elements. Here are 8 different ways to initialize a vector in C++.

%------------------------------------------------------------------------------%

\subsubsection{Initialize vector in C++ by using initializer list -- Sử dụng danh sách các giá trị khởi tạo}
We can initialize a vector with the list of values enclosed in curly braces {\tt\{\}} known as \href{https://www.geeksforgeeks.org/std-initializer_list-in-cpp-11/}{initializer list}. The value of the list will be assigned sequentially i.e. 1st value will be assigned to the 1st element of vector, 2nd value to 2nd element, $\ldots$, $n$th value to $n$th element. Syntax:
\begin{verbatim}
vector<type> v = {val1, val2, val3, ...};
\end{verbatim}
where {\tt val1, val2, val3}, $\ldots$ are the initial values, e.g.:
\begin{Verbatim}[numbers=left,xleftmargin=5mm]
// C++ Program to initializ std::vector with initializer list
#include <bits/stdc++.h>
using namespace std;

int main() {
    // Initializing std::vector with list of multiple values
    vector<int> v = {11, 23, 45, 89};
	
    for (auto i : v)
        cout << i << " ";
    return 0;
}
\end{Verbatim}
Output: {\tt 11 23 45 89}.
\begin{note}
	{\tt for (auto i : v)} means for each element of the type that will be determined automatically in the vector {\tt v}.
\end{note}

%------------------------------------------------------------------------------%

\subsubsection{Initialize vector in C++ 1 by 1 initialization}
Vector can be initialized by pushing value 1 by 1. In this method, an empty vector is created, \& elements are added to it 1 by 1 using the \href{https://www.geeksforgeeks.org/vectorpush_back-vectorpop_back-c-stl/}{\tt vector::push\_back()} method. This method is mostly used to initialize vector after declaration. Syntax:
\begin{verbatim}
v.push_back(val);
\end{verbatim}
where {\tt val} is the value which we have to insert, e.g.:
\begin{Verbatim}[numbers=left,xleftmargin=5mm]
// C++ Program to initialize std::vector by pushing values 1 by 1
#include <bits/stdc++.h>
using namespace std;

int main() {
    vector<int> v;
	
    // Pushing Value one by one
    v.push_back(11);
    v.push_back(23);
    v.push_back(45);
    v.push_back(89);
	
    for (auto i : v)
        cout << i << " ";
    return 0;
}
\end{Verbatim}
Output: {\tt11 23 45 89}.

%------------------------------------------------------------------------------%

\subsection{Initialize vector in C++ by with a single value}
We can initialize all the elements of the vector to a single value. We create a vector of a specified size \& initialize all elements to the same value using vector constructor. Syntax:
\begin{verbatim}
vector<type> v(n, val);
\end{verbatim}
where $n\in\mathbb{N}$ is the size \& {\tt val} is the initial value, e.g.:
\begin{Verbatim}[numbers=left,xleftmargin=5mm]
// C++ Program to initializ the std::vector with specific value
#include <bits/stdc++.h>
using namespace std;

int main() {
    // Initializing all the elements of a vector using a single value
    vector<int> v(5, 11);
	
    for (auto i : v)
        cout << i << " ";
    return 0;
}
\end{Verbatim}
Output: {\tt11 11 11 11 11}.

%------------------------------------------------------------------------------%

\subsubsection{Initialize vector in C++ from an array}
We can also initialize a vector using plain old static arrays using vector constructor. This works by copying all the elements of the array to the newly created vector. Syntax:
\begin{verbatim}
vector<type> v(arr, arra + n);
\end{verbatim}
where {\tt arr} is the array name \& $n\in\mathbb{N}$ is the size of the array, e.g.:
\begin{Verbatim}[numbers=left,xleftmargin=5mm]
// C++ Program to initializ the std::vector from another array
#include <bits/stdc++.h>
using namespace std;

int main() {
    int arr[] = {11, 23, 45, 89};
    int n = sizeof(arr) / sizeof(arr[0]);
	
    // initialize the std::vector v by arr
    vector<int> v = {arr, arr + n};
	
    for (auto i : v)
        cout << i << " ";
    return 0;
}
\end{Verbatim}
Output: {\tt11 23 45 89}.

%------------------------------------------------------------------------------%

\subsubsection{Initialize vector in C++ from another vector}
We can also initialize a newly created vector from an already created vector if they are of same type. Syntax:
\begin{verbatim}
vector<type> v2(v1.begin(), v1.end());
\end{verbatim}
where {\tt v1} is the already existing vector, e.g.:
\begin{Verbatim}[numbers=left,xleftmargin=5mm]
// C++ Program to initializ the std::vector from another vector
#include <bits/stdc++.h>
using namespace std;

int main() {
    vector<int> v1 = {11, 23, 45, 89};
	
    // initialize the vector v2 from vector v1
    vector<int> v2(v1.begin(), v1.end());
	
    for (auto i : v2)
        cout << i << " ";
    return 0;
}
\end{Verbatim}
Output: {\tt11 23 45 89}.

%------------------------------------------------------------------------------%

\subsubsection{Initialize vector in C++ by from any STL container}
Vectors are flexible containers that can be initialized by any other already existing containers e.g. set, multiset, map, etc. if they are of same type. Syntax:
\begin{verbatim}
vector<type> v(first, last);
\end{verbatim}
where {\tt first, last} are the iterator to the 1st element \& the element just after the last element in the range of STL container.

%------------------------------------------------------------------------------%

\subsubsection{Initialize vector in C++ by using {\tt std::fill()} function}
We can also use the \href{https://www.geeksforgeeks.org/fill-and-fill_n-functions-in-c-stl/}{\tt std::fill} function to initialize the whole or a part of a vector to the same value. Syntax:
\begin{verbatim}
fill(first, last, val);
\end{verbatim}
where {\tt first, last} are the iterator to the 1st element \& the element just after the last element in the range of STL container \& {\tt val} is the value to be initialized with, e.g.:
\begin{Verbatim}[numbers=left,xleftmargin=5mm]
// C++ Program to initialize the std::vector using std::fill() method
#include <bits/stdc++.h>
using namespace std;

int main() {
    vector<int> v(5);
	
    // initialize vector v with 11
    fill(v.begin(), v.end(), 11);
	
    for (auto i : v)
        cout << i << " ";
    return 0;
}
\end{Verbatim}
Output: {\tt11 11 11 11 11}.

%------------------------------------------------------------------------------%

\subsubsection{Initialize vector in C++ by using {\tt std::iota()} function}
The \href{https://www.geeksforgeeks.org/std-iota-in-cpp/}{\tt std::iota()} function from the {\tt<numeric>} library allows us to initialize a vector with consecutive values starting from the given value. Syntax:
\begin{verbatim}
std::iota(first, last, val);
\end{verbatim}
where {\tt first, last} are the iterator to the 1st element \& the element just after the last element in the range of the vector \& {\tt val} refers to the starting value, e.g.:
\begin{Verbatim}[numbers=left,xleftmargin=5mm]
// C++ Program to initializ the std::vector using std::iota()
#include <bits/stdc++.h>
using namespace std;

int main() {
    vector<int> v(5);
	
	// using std::iota() to initialize vector v with 11
    iota(v.begin(), v.end(), 11);
	
    for (auto i : v)
        cout << i << " ";
    return 0;
}
\end{Verbatim}
Output: {\tt11 12 13 14 15}.

%------------------------------------------------------------------------------%

\subsection{Insert elements -- Chèn phần tử}
An element can be inserted into a vector using \href{https://www.geeksforgeeks.org/vector-insert-function-in-cpp-stl}{vector insert()} method which takes linear time. But for the insertion at the end, the \href{https://www.geeksforgeeks.org/vectorpush_back-vectorpop_back-c-stl/}{vector {\tt push\_back()}} method can be used, which is much faster, taking only constant time.
\begin{Verbatim}[numbers=left,xleftmargin=5mm]
#include <bits/stdc++.h>
using namespace std;

int main() {
    vector<char> v = {'a', 'f', 'd'};
	
    // Inserting 'z' at the back
    v.push_back('z');
	
    // Inserting 'c' at index 1
    v.insert(v.begin() + 1, 'c');
	
    for (int i = 0; i < v.size(); i++)
        cout << v[i] << " ";
    return 0;
}
\end{Verbatim}
Output: {\tt a c f d z}.

%------------------------------------------------------------------------------%

\subsection{Access or update elements -- Tiếp cận hoặc cập nhật các phần tử}
Just like arrays, vector elements can be accessed using their index inside the \href{https://www.geeksforgeeks.org/vectoroperator-vectoroperator-c-stl/}{[] subscript operator}. While accessing elements, we can also update the value of that index using \href{https://www.geeksforgeeks.org/cpp-assignment-operators/}{assignment operator $=$}. The {\tt[] subscript operator} doesn't check whether the given index exists in the vector or not. So, there is another member method \href{https://www.geeksforgeeks.org/vector-at-in-cpp-stl/}{vector al()} for safely accessing or update elements.
\begin{Verbatim}[numbers=left,xleftmargin=5mm]
#include <bits/stdc++.h>
using namespace std;

int main() {
    vector<char> v = {'a', 'c', 'f', 'd', 'z'};
	
	// accessing & printing values
    cout << v[3] << endl;
    cout << v.at(2) << endl;
	
    // updating values using indexes 3 & 2
    v[3] = 'D';
    v.at(2) = 'F';
	
    cout << v[3] << endl;
    cout << v.at(2);
    return 0;
}
\end{Verbatim}

%------------------------------------------------------------------------------%

\subsection{Find vector size -- Tìm cỡ{\tt/}kích thước của vector}
1 of the common problems with arrays was to keep a separate variable to store the size information. Vector provides the solution to this problem by providing \href{https://www.geeksforgeeks.org/vector-size-in-cpp-stl/}{size()} method.
\begin{Verbatim}[numbers=left,xleftmargin=5mm]
#include <bits/stdc++.h>
using namespace std;

int main() {
    vector<char> v = {'a', 'c', 'f', 'd', 'z'};
	
    // finding size
    cout << v.size();
    return 0;
}
\end{Verbatim}
Output: {\tt5}.

%------------------------------------------------------------------------------%

\subsection{Traverse vector -- Duyệt vector}
Vector in C++ can be traversed using indexes in a loop. The indexes start from 0 \& go up to a vector size $- 1$. To iterate through this range, we can use a loop \& determine the size of the vector using the \href{https://www.geeksforgeeks.org/vectorempty-vectorsize-c-stl/}{vector size()} method.
\begin{Verbatim}[numbers=left,xleftmargin=5mm]
#include <bits/stdc++.h>
using namespace std;

int main() {
    vector<char> v = {'a', 'c', 'f', 'd', 'z'};
	
    // traversing vector using range based for loop
    for (int i = 0; i < v.size(); i++)
        cout << v[i] << " ";
    return 0;
}
\end{Verbatim}
Output: {\tt a c f d z}.

We can also use a range-based loop for simple traversal.

%------------------------------------------------------------------------------%

\subsection{Delete elements -- Xóa phần tử}
An element can be deleted from a vector using \href{https://www.geeksforgeeks.org/vector-erase-and-clear-in-cpp/}{vector erase()} but this method needs iterator to the element to be deleted. If only the value of the element is known, then {\tt find()} function is used to find the position of this element.

For the deletion at the end, the \href{https://www.geeksforgeeks.org/vector-pop-back-in-cpp-stl/}{vector {\tt pop\_back()}} method can be used, \& it is much faster, taking only constant time.
\begin{Verbatim}[numbers=left,xleftmargin=5mm]
#include <bits/stdc++.h>
using namespace std;

int main() {
    vector<char> v = {'a', 'c', 'f', 'd', 'z'};
	
    // deleting last element 'z'
    v.pop_back();
	
    // deleting element 'f'
    v.erase(find(v.begin(), v.end(), 'f'));
	
    for (int i = 0; i < v.size(); i++) {
        cout << v[i] << " ";
    }
    return 0;
}
\end{Verbatim}
Output:
\begin{verbatim}
a c f d 
a c d
\end{verbatim}

%------------------------------------------------------------------------------%

\subsection{Other operations -- Các thao tác khác}
Vector is 1 of the most frequently used containers in C++. It is used in many situations for different purposes. The following examples aim to help you master vector operations beyond the basics.

%------------------------------------------------------------------------------%

\section{2D Vector in C++}
\textbf{\textsf{Resources -- Tài nguyên.}}
\begin{enumerate}
	\item \href{https://www.geeksforgeeks.org/2d-vector-in-cpp-with-user-defined-size/}{Geeks4Geeks{\tt/}2D vector in C++}.
\end{enumerate}
A 2D vector is a vector of the vectors, i.e., each element is a vector in itself. It can be visualized as a matrix where each inner vector represents a row, \& the number of rows represents a row, \& the number of rows represents the maximum columns. A 2D vector is dynamically resizable in both dimensions. Syntax:
\begin{verbatim}
vector<vector<data_type>> v;
\end{verbatim}
where \verb|data_type| is the type of elements \& {\tt V} is the name assigned to the 2D vector.

%------------------------------------------------------------------------------%

\subsection{Creating a 2D vector -- Tạo 1 vector 2D}
In C++, we can create{\tt/}declare a 2D vector by using the vector container defined in the C++ Standard Template Library (STL). We can simply create a 2D vector by creating a vector with the vector data type.

Just like vectors, a 2D vector can be created \& initialized in multiple ways:
\begin{enumerate}
	\item {\bf Default.} An empty 2D vector can be created using the declaration:
	\begin{verbatim}
vector<vector<data_type>> v;
	\end{verbatim}
	It can be filled in later on in the program.
	\item {\bf With user defined size \& default value.} A vector of a specific size can also be declared \& initialized to the given value as default value.
	\begin{verbatim}
vector<vector<T>> v(n, vector<T>(m, value));
	\end{verbatim}
	where $n\in\mathbb{N}^\star$ is the number of rows, $m\in\mathbb{N}^\star$ is the number of columns, {\tt val} is the new default value for all of the elements of the vector.
	\item {\bf Using initializer list.} Vector can also be initialized using a list of values enclosed in {\tt\{\}} braces separated by comma. The list must be nested according to the 2 dimensions as it helps in determining the row size \& column size.
	\begin{verbatim}
vector<vector<T>> v = {{x1, x2, ...}, {y1, y2, ...}, ...};
	\end{verbatim}
	E.g.:
	\begin{Verbatim}[numbers=left,xleftmargin=5mm]
#include <bits/stdc++.h>
using namespace std;

void printV(vector<vector<int>>& v) {
    for (auto i: v) {
        for (auto j: i) {
            cout << j << " ";
        }
        cout << endl;
    }
    cout << endl;
}

int main() {
    // an empty 2D vector
    vector<vector<int>> v1;
	
    // 2D vector with initial size and value
	vector<vector<int>> v2(2, vector<int>(3, 11));
	
    // a 2D vector initialized with initializer list
    vector<vector<int>> v3 = {
        {1, 2, 3},
        {4, 5, 6},
    };
	
    printV(v1);
    printV(v2);
    printV(v3);
    return 0;
}
	\end{Verbatim}
\end{enumerate}
Output:
\begin{verbatim}
11 11 11
11 11 11

1 2 3
4 5 6
\end{verbatim}

%------------------------------------------------------------------------------%

Basic operations of 2D vector:
\begin{enumerate}
	\item Inserting elements in a 2D vector
	\item Accessing \& updating elements
	\item Deleting elements
	\item Traversing the vector
\end{enumerate}

%------------------------------------------------------------------------------%

\subsection{Inserting elements in a 2D vector}
In 2D vectors, there are 2 types of insertion:
\begin{enumerate}
	\item Insert a new row.
	\item Insert a value in an existing row.
\end{enumerate}
These can be inserted at any given position using \href{https://www.geeksforgeeks.org/vector-insert-function-in-cpp-stl/}{\tt vector\_insert()} \& at the end using \href{https://www.geeksforgeeks.org/vectorpush_back-vectorpop_back-c-stl/}{\tt vector push\_back()}. As vector can dynamically grow, each row can have different size like \href{https://www.geeksforgeeks.org/jagged-array-in-java/}{Java's jagged arrays}, e.g.:
\begin{Verbatim}[numbers=left,xleftmargin=5mm]
#include <bits/stdc++.h>
using namespace std;

int main() {
    vector<vector<int>> v = {{1, 2, 3}, {4, 5, 6}};
	
    // insert a new row at the end
    v.push_back({7, 8, 9});
	
    // insert value in 2nd row at 2nd position
    v[1].insert(v[1].begin() + 1, 10);
	
    for (int i = 0; i < v.size(); i++) {
        for (int j = 0; j < v[i].size(); j++) {
            cout << v[i][j] << " ";
        }
        cout << endl;
    }
    return 0;
}
\end{Verbatim}
Output:
\begin{verbatim}
1 2 3
4 10 5 6
7 8 9
\end{verbatim}

%------------------------------------------------------------------------------%

\subsection{Accessing \& uploading elements}
As 2D vectors are organized as matrices with row \& column, we need 2 indexes to access an element: 1 for the {\it row number} $i$ \& other for the {\it column number} $j$. We can then use any access method e.g. \href{https://www.geeksforgeeks.org/vectoroperator-vectoroperator-c-stl/}{[] operator} or \href{https://www.geeksforgeeks.org/vector-at-in-cpp-stl/}{vector at()} method.

The value of the accessed element can be changed by assigning a new value using {\tt=} operator, e.g.:
\begin{Verbatim}[numbers=left,xleftmargin=5mm]
#include <bits/stdc++.h>
using namespace std;

int main() {
    vector<vector<int>> v = {{1, 2, 3}, {4, 5, 6}};
	
    // access 3rd element in 2nd row
    cout << "3rd element in 2nd row: "<< v[1][2] << endl;
	
    // access 2nd element in 1st row
    cout << "2nd element in 1st row: "<<v[0][1]<<endl;
	
    // updating the 2nd element in 1st row
    v[0][1] = 9; 
    cout << "2nd element in 1st row after updating: " <<v[0][1]<<endl;

    return 0;
}
\end{Verbatim}
Output:
\begin{verbatim}
3rd element in 2nd row: 6
2nd element in 1st row: 2
2nd element in 1st row after updating: 9
\end{verbatim}

%------------------------------------------------------------------------------%

\subsection{Deleting elements from a 2D vector}
Similar to insertion, there are 2 types of deletion in 2D vector:
\begin{enumerate}
	\item Delete a row
	\item Delete a value in an existing row.
\end{enumerate}
Elements can be deleted using \href{https://www.geeksforgeeks.org/vector-erase-and-clear-in-cpp/}{vector erase()} for a specific position or range \& using \href{https://www.geeksforgeeks.org/vectorpush_back-vectorpop_back-c-stl/}{vector pop\_back()} to remove the last element, e.g.:
\begin{Verbatim}[numbers=left,xleftmargin=5mm]
#include <bits/stdc++.h>
using namespace std;

int main() {
    vector<vector<int>> v = {{1, 2, 3}, {4, 5, 6}};
	
    // delete the 2nd row
    v.erase(v.begin() + 1);
	
    // delete 2nd element in 1st row
    v[0].erase(v[0].begin() + 1);
	
    for (int i = 0; i < v.size(); i++) {
        for (int j = 0; j < v[i].size(); j++)
            cout << v[i][j] << " ";
        cout << endl;
    }
	
    return 0;
}
\end{Verbatim}
Output: {\tt1 3}.

%------------------------------------------------------------------------------%

\subsection{Traversing 2D vectors}
Traversing a 2D vector involves iterating through rows \& columns using nested loops \& access the elements by indexes, e.g.:
\begin{Verbatim}[numbers=left,xleftmargin=5mm]
#include <bits/stdc++.h>
using namespace std;

int main() {
    vector<vector<int>> v = {{1, 2, 3}, {4, 5, 6}};
	
    // loop through rows
    for (int i = 0; i < v.size(); i++) {
        // loop through columns
        for (int j = 0; j < v[i].size(); j++)
            cout << v[i][j] << " ";
        cout << endl;
    }
	
    return 0;
}
\end{Verbatim}
Output:
\begin{verbatim}
1 2 3
4 5 6
\end{verbatim}
C++ provides more methods to traverse 2D vector.

%------------------------------------------------------------------------------%

\subsection{Finding size of 2D vector}
Finding the size of a 2D vector involves finding its row size \& column size which can be done using the {\tt vector.size()} method. The size vector used on the outer vector gives the number of rows in the 2D vector while using them on the inner vector gives the number of columns in that row (as all rows can have different number of columns). Syntax:
\begin{verbatim}
//finding the number of rows
int rows = vec.size();

//finding the number of columns
int rows = vec[0].size();
\end{verbatim}
where {\tt vec} is the name of the vector for which the size is to be determined. Since each element of a 2D vector is a vector itself we can use the {\tt size()} method on the elements {\tt vec[0]} to find the size of each row separately, e.g.:
\begin{Verbatim}[numbers=left,xleftmargin=5mm]
#include <iostream>
#include <vector>
using namespace std;

int main() {
    // creating a 2D vector
    vector<vector<int>> vec = {
        {1, 2, 3},
        {4, 5, 6},
        {7, 8, 9}
    };
	
    // finding the number of rows  (size of the outer vector)
    int rows = vec.size();
    cout << "Number of rows: " << rows << endl;
	
    // finding the number of columns (size of any inner vector first row)
    int cols = vec[0].size();
    cout << "Number of columns: " << cols << endl;
	
    return 0;
}
\end{Verbatim}
Output:
\begin{verbatim}
Number of rows: 3
Number of columns: 3
\end{verbatim}

%------------------------------------------------------------------------------%

\subsection{Common operations \& applications}
Apart from the basic operations, there are many operations that can be performed on 2D vectors.

%------------------------------------------------------------------------------%

\section{Advantages of Vector Over Array in C++}
\textbf{\textsf{Resources -- Tài nguyên.}}
\begin{enumerate}
	\item \href{https://www.geeksforgeeks.org/advantages-of-vector-over-array-in-c/}{Geeks4Geeks{\tt/}advantages of vector over array in C++}.
\end{enumerate}
In C++, both vectors \& arrays are used to store collections of elements, but vector offers significant advantages over arrays in terms of flexibility, functionality, \& ease of use. This section explores the benefits of using vectors in C++ programming.

%------------------------------------------------------------------------------%

\subsection{Dynamic resizing}
Unlike arrays, vectors can dynamically resize themselves, i.e., you don't need to know the size of the vector in advance, it can grow \& shrink according to the number of elements present in it.
\begin{Verbatim}[numbers=left,xleftmargin=5mm]
#include <bits/stdc++.h>
using namespace std;

int main() {
    vector<int> v;
	
    // initial size
    cout << v.size() << endl;
	
    // add elements dynamically
    for (int i = 1; i <= 5; ++i)
        v.push_back(i);
	
    // size after inserting elements
    cout << v.size();
    return 0;
}
\end{Verbatim}
Output:
\begin{verbatim}
0
5
\end{verbatim}

%------------------------------------------------------------------------------%

\subsection{Built-in functions \& operations}
Vectors come with a variety of member functions, e.g. \verb|push_back(), pop_back(), insert(), erase()|, \& more, which simplify many operations. Apart from that, vectors can be easily copied from one to another using assignment operator.
\begin{Verbatim}[numbers=left,xleftmargin=5mm]
#include <bits/stdc++.h>
using namespace std;

int main() {
    vector<int> v = {1, 2, 3, 4, 5};
	
    // remove the last element
    v.pop_back();
	
    // insert a new element at the beginning
    v.insert(v.begin(), 0);
	
    for (auto i : v)
        cout << i << " ";
    return 0;
}
\end{Verbatim}
Output: {\tt0 1 2 3 4}.

%------------------------------------------------------------------------------%

\subsection{Memory management}
Vectors handle memory allocation \& deallocation automatically, whereas arrays require manual allocation \& deallocation.
\begin{Verbatim}[numbers=left,xleftmargin=5mm]
#include <bits/stdc++.h>
using namespace std;

int main() {
    vector<int> v = {1, 2, 3};
	
    // no manual reallocation needed
    v.push_back(4);
	
    for (auto i : v)
        cout << i << " ";
    return 0;
}
\end{Verbatim}
Output: {\tt1 2 3 4}.

%------------------------------------------------------------------------------%

\subsection{Bounds checking}
Vector supports bounds checking in {\tt at()} method \& throw an \verb|out_of_range| exception if the index is out of bounds, offering a safer way to access elements.
\begin{Verbatim}[numbers=left,xleftmargin=5mm]
#include <bits/stdc++.h>
using namespace std;

int main() {
    vector<int> v = {1, 2, 3, 4};
	
    try {
        // attempting to access out of range index
        cout << v.at(5) << endl;	
    } catch (const out_of_range& e) {
        cout << "Exception: " << e.what() << endl;
    }
	
    return 0;
}
\end{Verbatim}
Output:
\begin{verbatim}
Exception: vector::_M_range_check: __n (which is 5) >= this->size() (which is 4)
\end{verbatim}

%------------------------------------------------------------------------------%

\subsection{Standard Template Library (STL) integration}
Vectors are fully compatible with STL algorithms like sort, find, \verb|remove_if|, making it easier to make use of inbuilt functionality of the language.
\begin{Verbatim}[numbers=left,xleftmargin=5mm]
#include <bits/stdc++.h>
using namespace std;

int main() {
    vector<int> v = {1, 4, 3, 2, 5};
	
    // sort vector
    sort(v.begin(), v.end());
	
    // reverse sorted vector
    reverse(v.begin(), v.end());
	
    for (auto i : v)
        cout << i << " ";
    return 0;
}
\end{Verbatim}
Output: {\tt5 4 3 2 1}.

%------------------------------------------------------------------------------%

\subsection{Seamless working with functions}
When arrays are passed to a function, a separate parameter for size is also passed whereas in case of passing a vector to a function, there is no such need as vector maintains variables which keeps track of size of container at all times. Also, it can be easily passed \& returned as both value \& reference.

-- Khi mảng được truyền cho một hàm, một tham số riêng cho kích thước cũng được truyền trong khi trong trường hợp truyền một vector cho một hàm, không cần thiết vì vector duy trì các biến theo dõi kích thước của container mọi lúc. Ngoài ra, nó có thể dễ dàng được truyền \& trả về dưới dạng cả giá trị \& tham chiếu.
\begin{Verbatim}[numbers=left,xleftmargin=5mm]
#include <bits/stdc++.h> 
using namespace std;

// take vector as argument as reference but return by value
vector<int> rev(vector<int>& v) {
    reverse(v.begin(), v.end());
    return v;
}

int main()  { 
    vector<int> v1 = {1, 2, 3, 4, 5};
    vector<int> v2 = rev(v1);
    
    for (auto i: v2) cout << i << " ";
    return 0; 
}
\end{Verbatim}
Output: {\tt5 4 3 2 1}.

%------------------------------------------------------------------------------%

\section{Miscellaneous}

%------------------------------------------------------------------------------%

\printbibliography[heading=bibintoc]
	
\end{document}