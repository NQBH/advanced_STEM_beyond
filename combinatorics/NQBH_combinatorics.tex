\documentclass{article}
\usepackage[backend=biber,natbib=true,style=alphabetic,maxbibnames=50]{biblatex}
\addbibresource{/home/nqbh/reference/bib.bib}
\usepackage[utf8]{vietnam}
\usepackage{tocloft}
\renewcommand{\cftsecleader}{\cftdotfill{\cftdotsep}}
\usepackage[colorlinks=true,linkcolor=blue,urlcolor=red,citecolor=magenta]{hyperref}
\usepackage{amsmath,amssymb,amsthm,enumitem,float,graphicx,mathtools,tikz}
\usetikzlibrary{angles,calc,intersections,matrix,patterns,quotes,shadings}
\allowdisplaybreaks
\newtheorem{assumption}{Assumption}
\newtheorem{baitoan}{}
\newtheorem{cauhoi}{Câu hỏi}
\newtheorem{conjecture}{Conjecture}
\newtheorem{corollary}{Corollary}
\newtheorem{dangtoan}{Dạng toán}
\newtheorem{definition}{Definition}
\newtheorem{dinhly}{Định lý}
\newtheorem{dinhnghia}{Định nghĩa}
\newtheorem{example}{Example}
\newtheorem{ghichu}{Ghi chú}
\newtheorem{hequa}{Hệ quả}
\newtheorem{hypothesis}{Hypothesis}
\newtheorem{lemma}{Lemma}
\newtheorem{luuy}{Lưu ý}
\newtheorem{nhanxet}{Nhận xét}
\newtheorem{notation}{Notation}
\newtheorem{note}{Note}
\newtheorem{principle}{Principle}
\newtheorem{problem}{Problem}
\newtheorem{proposition}{Proposition}
\newtheorem{question}{Question}
\newtheorem{remark}{Remark}
\newtheorem{theorem}{Theorem}
\newtheorem{vidu}{Ví dụ}
\usepackage[left=1cm,right=1cm,top=5mm,bottom=5mm,footskip=4mm]{geometry}
\def\labelitemii{$\circ$}
\DeclareRobustCommand{\divby}{%
	\mathrel{\vbox{\baselineskip.65ex\lineskiplimit0pt\hbox{.}\hbox{.}\hbox{.}}}%
}
\setlist[itemize]{leftmargin=*}
\setlist[enumerate]{leftmargin=*}

\title{Combinatorics -- Tổ Hợp}
\author{Nguyễn Quản Bá Hồng\footnote{A scientist- {\it\&} creative artist wannabe, a mathematics {\it\&} computer science lecturer of Department of Artificial Intelligence {\it\&} Data Science (AIDS), School of Technology (SOT), UMT Trường Đại học Quản lý {\it\&} Công nghệ TP.HCM, Hồ Chí Minh City, Việt Nam.\\E-mail: {\sf nguyenquanbahong@gmail.com} {\it\&} {\sf hong.nguyenquanba@umt.edu.vn}. Website: \url{https://nqbh.github.io/}. GitHub: \url{https://github.com/NQBH}.}}
\date{\today}

\begin{document}
\maketitle
\begin{abstract}
	This text is a part of the series {\it Some Topics in Advanced STEM \& Beyond}:
	
	{\sc url}: \url{https://nqbh.github.io/advanced_STEM/}.
	
	Latest version:
	\begin{itemize}
		\item {\it Combinatorics -- Tổ Hợp}.
		
		PDF: {\sc url}: \url{https://github.com/NQBH/advanced_STEM_beyond/blob/main/combinatorics/NQBH_combinatorics.pdf}.
		
		\TeX: {\sc url}: \url{https://github.com/NQBH/advanced_STEM_beyond/blob/main/combinatorics/NQBH_combinatorics.tex}.
	\end{itemize}
\end{abstract}
\tableofcontents

%------------------------------------------------------------------------------%

\section{Combinatorics -- Tổ Hợp}

\subsection{\cite{Shahriari2022}. {\sc Shahriar Shahriari}. An Invitation to Combinatorics}
{\sf[14 Amazon ratings]}
\begin{itemize}
	\item {\sf Preface.} Combinatorics is a fun, difficult, broad, \& very active area of mathematics. Counting, deciding whether certain configurations exist, \& elementary graph theory are where subject begins. There are a myriad of connections to other areas of mathematics \& CS, \&, in fact, combinatorial problems can be found almost everywhere. To learn combinatorics is partly to become familiar with combinatorial topics, problems, \& techniques, \& partly to develop a can-do attitude toward discrete problem solving. This textbook is meant for a student who has completed an introductory college calculus sequence (a few sects require some knowledge of linear algebra but you can get quite a bit out of this text without a thorough understanding of linear algebra), has some familiarity with proofs, \& desires to not only become acquainted with main topics of introductory combinatorics but also to become a better problem solver.
	\begin{itemize}
		\item {\sf Key Features.}
		\begin{itemize}
			\item {\bf Conversational Style.} This text is written for students \& is meant to be read. Reading mathematics is difficult, but being able to decipher complicated technical writing is an incredibly useful \& transferable skill. Discussion in between usual theorems, proofs, \& examples are meant to facilitate reader's (ad)venture into reading a mathematics textbook.
			\item {\bf Problem-Solving Emphasis.} 1 advantage of combinatorics: many of its topics can be introduced without too much jargon. Can turn to almost any chap in this book \& find problem statements that are understandable regardless of your background. Initially, may not know how to do a problem or even where to begin, but gaining experience in passing that hurdle is at heart of becoming a better problem solver. For this to happen, reader have to get actively involved, \& learn by solving problems. Getting right answer is not really objective. Rather, it is only by trying to solve a problem that you will really understand what problem is asking \& what subtle issues need to be considered. It is only after you have given problem a try that you will appreciate solution. This text gives you ample opportunity to get actively involved. In addition to $> 1200$ problems, highlight following features.
			\begin{itemize}
				\item {\bf Collaborative Mini-projects.} Mini-projects -- there are 10 of these scattered throughout text -- are meant to be projects for groups of 3 or 4 students to collaboratively explore. They are organized akin to a science lab. A few preliminary problems are to be done individually. Collaborative part of project is meant to take up good part of an afternoon, \& it is envisioned that a project report -- really a short mathematics paper -- will be result. Mini-projects are of 2 types. In 1 type (Mini-projects 1, 6--10), project explores new material not covered elsewhere in text. 2nd type (Mini-projects 2--5) are meant to be done by students {\it before} relevant topic is covered in class. (This should explain their curious placement in text). It has been my experience: much learning happens if students 1st work on a topic, in a guided \& purposeful manner, on their own, followed by class discussion{\tt/}lecture.
				\item {\bf Guided Discovery through Scaffolded Projects.} In addition to collaborative mini-projects, quite a number of other topics are organized as a sequence of manageable smaller problems. Often assign these problems in consecutive assignments, so that can provide solutions, \& allow time for discussion before proceeding to subsequent steps. In some other problems, students are guided toward a solution through an explicit sequence of steps. Some of proofs are presented in this format with hope: an engaged reader, with a paper \& pencil at hand, will fill in details. As such, these problems are aimed at training reader in art of reading terse mathematical proofs.
				\item {\bf Warm-Up Problems \& Opening Chap Problems.} Nearly every sect starts with a warm-up problem. These are relatively straightforward problems, \& use them for in-class group work as a prelude to discussion of a topic. In contrast, every chap starts with a more subtle opening problem. Guess: for most part, student will not be able to do these opening problems before working through chap. Purpose: give a glimpse of what we are going to do in chap, \& motivate to make it through material. Each opening chap problem is solved somewhere in chap, \& all of warm-up problems have a short answer in Appendix A.
				\item {\bf Selected Hints, Short Answers, Complete Solutions.} Appendices have hints, short answers, \& complete solutions for selected problems. Try a problem 1st without looking at solution, but when you are stuck -- \& hopefully you will get stuck often \& learn to cherish experience -- then 1st look at hint sect, then later at short answer sect, \& finally at complete solutions sect. Complete solutions serve 2 purposes. They provide further examples of how to do problems, \& they model how to write mathematics in paragraph style. By contrast, short answers are not particularly helpful in telling you how to do a problem. Instead, after done with a problem, short answer can either reassure you or send you back to drawing board.
				\item {\bf Open Problems \& Conjectures.} A number of chaps end with a sect highlighting a few easily stated open problems \& conjectures. Some of these are important unsolved problems, while others are mere curiosities. This is not meant to be a guide to current cutting-edge research problems. Rather, modest aim: whet readers' appetite by convincing her: even some seemingly innocent-looking problems remain unsolved, \& combinatorics is an active area of research.
				\item {\bf Historical Asides.} I am not a historian \& historical comments \& footnotes barely scratch surface. Even so, combinatorial problems \& solutions are a wonderful example of international nature of mathematics. In addition, mathematics is created by humans who are affected by, participate in, \& sometimes, for good or bad, help shape communities \& societies that they are a part of. Declare success even if just a few of you become curious \& further investigate historical context of mathematics. Have also chosen to highlight international nature of combinatorics by naming some well-known mathematical objects differently.
			\end{itemize}
		\end{itemize}
		\item {\sf Coverage \& Organization.} Text has more than enough material for a 1-semester course in combinatorics at sophomore or junior level at an American university. Sects of book that I do not cover in my classes, \& consider optional, are marked by a $\star$. Induction proofs \& recurrence relations will be used throughout book \& subject of Chap. 1. Counting problems -- so-called {\it enumerative combinatorics} -- take up $>$ half of book, \& are subject of Chaps. 3--9. In Chap. 3, introduce a slew of ``balls \& boxes'' problems that serve as an organizing principle for our counting problems. Chaps. 3--5 cover basics of permutations \& combinations as well as a good dose of exploration of binomial coefficients. Chaps. 6--7 are on Stirling numbers \& integer partitions. 2 substantial chaps on inclusion-exclusion principle \& generating functions conclude our treatment of enumerative combinatorics. Graph theory is about $\frac{1}{3}$ of book \& is covered in Chaps. 2 \& 10. Basic vocabulary of graphs is introduced early in Sect. 2.2, but, for most part, material on graph theory is independent of other chaps. Start course with Ramsey theory since want to make sure: all students are seeing sth new, \& they are not lulled into thinking: class is going to be only about permutations \& combinations. But Ramsey theory is difficult \& could be postponed to much later. Alternatively, could start with Chap. 10, \& do graph theory 1st. Finally, Chap. 11 brings together material on partially ordered sets, a favorite of mine. Matchings in bipartite graphs is also covered in this chap, since wanted to bring out close connection between 2 frameworks.
		
		Instructor may want to augment usual fare of introductory combinatorics with 1 or 2 more substantial results. Among topics offered here are Chung--Feller theorem, Euler's pentagonal number theorem, Cayley's theorem on labeled trees, Stanley's theorem on acyclic orientations, Thomassen's 5-color theorem, Pick's formula, Erd\"ods--Ko--Rado theorem, Ramsey's theorem for hypergraphs, \& M\"obius inversion.
		\item {\sf Global Roots of Combinatorics \& Naming of Mathematical Objects.} Most ``new'' mathematical ideas \& concepts have antecedents \& precursors in older ones, \&, as a result, search for ``1st'' appearance of this or that mathematics is never-ending \& often futile. As such naming of mathematical objects \& results sometimes -- possibly always -- is a bit arbitrary
		\begin{quotation}
			``It takes a thousand men to invent a telegraph or a steam engine, or a phonograph, or a telephone, or any other important thing -- \& last man gets credit \& forget others. He added his little mite -- that is all he did. These object lessons should teach us that 99 parts of all things that proceed from the intellect are plagiarisms, pure \& simple; \& lesson ought to make us modest. But nothing can do that.'' -- {\sc Mark Twain}, {\it Letter to Helen Keller, Riverdale-on-the-Hudson}, St. Patrick's Day 1903.
			
			-- ``Cần cả ngàn người để phát minh ra máy điện báo hay máy hơi nước, hay máy hát, hay điện thoại, hay bất kỳ thứ quan trọng nào khác -- \& người cuối cùng được ghi công \& quên mất những người khác. Ông ấy đã thêm 1 đồng nhỏ của mình -- đó là tất cả những gì ông ấy đã làm. Những bài học thực tế này sẽ dạy chúng ta rằng 99 phần của tất cả mọi thứ xuất phát từ trí tuệ đều là đạo văn, thuần túy \& đơn giản; \& bài học sẽ khiến chúng ta khiêm tốn. Nhưng không gì có thể làm được điều đó.''
		\end{quotation}
		However, when look at totality of common names of mathematical objects in combinatorics -- Pascal's triangle, Vandermonde's identity, Catalan numbers, Stirling numbers, Bell numbers, or Fibonacci numbers -- a remarkable \& seemingly non-random pattern emerges. All names chosen are from European tradition. Undoubtedly, European mathematicians contributed significantly -- \&, in many subareas of mathematics, decisively -- to development of mathematics. However, this constellation of names conveys to beginning student that combinatorial ideas \& investigations were limited to Europe. In case of combinatorics, nothing could further from truth. Mathematicians from China, Japan, India, Iran, northern Africa, wider Islamic world, \& Hebrew tradition, to mention a few, have very much worked on these topics. (For some of this history, see [Wilson \& Watkins 2013]). Certainly, later European scholars have taken some topics further, but this does not take away from international character of mathematics in general \& combinatorics in particular. For this reason, have tried to use a more inclusive set of names for at least some of familiar objects. Completely understandable to want to be familiar with more common -- often universally accepted -- names for various objects, \& those are pointed out in text as well. Author does not claim expertise in history of combinatorics, \& quite possible: every good historical arguments can be made in support of other attributions or against ones suggested here. If such a discussion ensues, will all be better for it.
		
		Combinatorics is a fertile area for involving undergraduates in research.
	\end{itemize}
	\item {\sf Introduction.}
	\begin{quote}
		``Accurate reckoning. The entrance into knowledge of all existing things \& all obscure secrets.'' -- The Ahmes--Rhind Papyrus
	\end{quote}
	\begin{itemize}
		\item {\sf What is Combinatorics?} Combinatorics is a collection of techniques \& a language for study of (finite or countably infinite) discrete structures. Given a set of elements (\& possibly some structure on that set), typical questions in combinatorics are:
		\begin{itemize}
			\item Does a specific arrangement of elements exist?
			\item How many such arrangements are there?
			\item What properties do these arrangements have?
			\item Which 1 of arrangements is maximal, minimal, or optimal according to some criterion?
		\end{itemize}
		Unlike many other areas of mathematics -- e.g., analysis, algebra, topology -- core of combinatorics is neither its subject matter nor a set of ``fundamental'' theorems. More than anything else, combinatorics is a collection -- some may say a hodgepodge -- of techniques, attitudes, \& general principles for solving problems about discrete structures. For any given problem, a combinatorist combines some of these techniques \& principles -- e.g., pigeonhole principle, inclusion-exclusion principle, marriage theorem, various counting techniques, induction, recurrence relations, generating functions, probabilistic arguments, asymptotic analysis -- with (often clever) ad hoc arguments. Result is a fun \& difficult subject.
		
		In today's mathematical world, in no small part due to power of digital computers, most mathematicians find much use for tool box of combinatorics. In problems of pure mathematics, often, after deciphering layers of theory, find a combinatorics problem at core. Outside of mathematics, e.g., combinatorial problems abound in CS.
		\item {\sf Typical Problems.} To whet your appetite, a preliminary sample of problems that we will encounter in course of this text.
		\begin{itemize}
			\item How many sequences $a_1,\ldots,a_{12}$ are there consisting of 4 0's \& 8 1's, if no 2 consecutive terms are both 0's?
			\item A bakery has 8 kinds of donuts, \& a box holds 1 dozen donuts. How many different boxes can you buy? How many different boxes are there that contain at least 1 of each kind?
			\item A bakery sells 7 kinds of donuts. How many ways are there to choose 1 dozen donuts if no more than 3 donuts of any kind are used?
			\item Determine number of $n$-digit numbers with all digits odd, s.t. 1 \& 3 each occur a {\it positive} even number of times.
			\item Try to reconstruct a word made from letters A, B, C, D, \& R. Given a frequency table that shows number of times a specific triple occurs in word. {\sf[Table: triple: frequency]}. Want to know all words with same triples \& with same frequency table. Answer may be: there are no such words. Note: by a word we mean an ordered collection of letters \& not concerned with meaning.
			\item A soccer ball is usually tiled with 12 pentagons \& 20 hexagons. Are any other combinations of pentagons \& hexagons possible?
		\end{itemize}
		\item {\sf How Do We ``Count''?} Counting number of configurations of a certain type is an important part of combinatorics. In all of examples in prev sect, clear what kind of an answer we are looking for. Want a specific numerical answer or an example of a specific configuration.
		
		However, in many problems, it may be possible to present a solution satisfactory in many ways but is not quite a direct answer.
		
		-- Tuy nhiên, trong nhiều bài toán, có thể đưa ra giải pháp thỏa đáng theo nhiều cách nhưng không phải là câu trả lời trực tiếp.
		
		Unclear how irrational numbers got involved in counting a discrete phenomenon. This formula can actually be used but seems to give little insight into problem. Sometimes, there are alternatives to finding a closed formula.
		
		As examples show, will not only use a myriad of techniques for solving counting problems, but will also refine our sense of what a good situation should look like. This all will (hopefully) become clear as we get our hands dirty \& start solving problems.
		
		-- Như các ví dụ cho thấy, sẽ không chỉ sử dụng vô số kỹ thuật để giải quyết các vấn đề đếm, mà còn tinh chỉnh cảm nhận của chúng ta về tình huống tốt nên như thế nào. Tất cả những điều này (hy vọng) sẽ trở nên rõ ràng khi chúng ta bắt tay vào giải quyết vấn đề.
	\end{itemize}
	\item {\sf1. Introduction \& Recurrence Relations.} Induction is a powerful method of proof \& immensely useful in combinatorics. Suspect: most readers already have some experience with induction, \& so 1st 2 sects of this chap should provide a quick review \& some additional practice. Recurrence relations are ubiquitous in combinatorics \& provide another powerful tool in analyzing counting problems. This will be important through text, but Sect. 1.3 gives experience constructing \& using recurrence relations. Often recurrence relations \& induction provide a 1-2 punch. You are interested in a sequence of integers -- maybe a sequence that arises from a counting problem -- so 1st find a recurrence relation for sequence, then you use it to generate data, \& finally use induction to prove any patterns that you find. If you have prior experience with induction \& recurrence relations, then you should try some of problems \& move quickly to subsequent chaps. However, gaining experience with setting up recurrence relations by doing problems -- maybe concurrently as you work on later chaps -- is highly recommended. Optional Sect. 1.4 introduces to 2 possible methods for attacking recurrence relations.
	
	-- Quy nạp là 1 phương pháp chứng minh mạnh mẽ \& vô cùng hữu ích trong tổ hợp học. Nghi ngờ: hầu hết độc giả đã có 1 số kinh nghiệm với quy nạp, \& vì vậy 2 phần đầu tiên của chương này sẽ cung cấp 1 bản tóm tắt nhanh \& 1 số bài tập thực hành bổ sung. Các quan hệ đệ quy có mặt ở khắp mọi nơi trong tổ hợp \& cung cấp 1 công cụ mạnh mẽ khác để phân tích các bài toán đếm. Điều này sẽ quan trọng thông qua văn bản, nhưng Phần 1.3 cung cấp kinh nghiệm xây dựng \& sử dụng các quan hệ đệ quy. Các quan hệ đệ quy \& quy nạp thường cung cấp cú đấm 1-2. Bạn quan tâm đến 1 chuỗi các số nguyên -- có thể là 1 chuỗi phát sinh từ 1 bài toán đếm -- vì vậy trước tiên hãy tìm 1 quan hệ đệ quy cho chuỗi, sau đó bạn sử dụng nó để tạo dữ liệu, \& cuối cùng sử dụng quy nạp để chứng minh bất kỳ mẫu nào bạn tìm thấy. Nếu bạn đã có kinh nghiệm trước đó với quy nạp \& quan hệ đệ quy, thì bạn nên thử 1 số bài toán \& chuyển nhanh sang các chương tiếp theo. Tuy nhiên, việc tích lũy kinh nghiệm thiết lập các quan hệ đệ quy bằng cách giải các bài toán -- có thể đồng thời khi bạn giải các chương sau -- là điều rất được khuyến khích. Phần tùy chọn 1.4 giới thiệu 2 phương pháp có thể sử dụng để giải quyết các quan hệ hồi quy.
	\begin{itemize}
		\item {\sf1.1. Induction.} 
	\end{itemize}
	\item {\sf2. Pigeonhole Principle \& Ramsey Theory.}
	\item {\sf3. Counting, Probability, Balls, \& Boxes.}
	\item {\sf4. Permutations \& Combinations.}
	\item {\sf5. Binomial \& Multinomial Coefficients.}
	\item {\sf6. Stirling Numbers.}
	\item {\sf7. Integer Partitions.}
	\item {\sf8. Inclusion--Exclusion Principle.}
	\item {\sf9. Generating Functions.}
	\item {\sf10. Graph Theory.}
	\item {\sf11. Posets, Matchings, \& Boolean Lattices.}
\end{itemize}

%------------------------------------------------------------------------------%

\section{Graph Theory -- Lý Thuyết Đồ Thị}

\subsection{\cite{Valiente2002, Valiente2021}. {\sc Gabriel Valiente}. Algorithms on Trees \& Graphs With Python Code}

\begin{itemize}
	\item {\sf Preface to 2e.} 1e has been extensively used for graduate teaching \& research all over world in last 2 decades. In this new edition, have substituted detail pseudocode for both literate programming description \& implementation of algorithms using LEDA library of efficient data structures \& algorithms. Although pseudocode is detailed enough to allow for a straightforward implementation of algorithms in any modern programming language, have added a proof-of-concept implementation in Python of all algorithms in Appendix A. This is, therefore, a thoroughly revised \& extended edition.
	
	Regarding new material, have added an adjacency map representation of trees \& graphs, \& both maximum cardinality \& maximum weight bipartite matching as an additional application of graph traversal techniques. Further, have revised end-of-chap problems \& exercises \& have included solutions to all problems in Appendix B.
	\item {\sf Preface to 1e.} Graph algorithms, a long-established subject in mathematics \& CS curricula, are also of much interest to disciplines e.g. computational molecular biology \& computational chemistry. This book goes beyond {\it classical} graph problems of shortest paths, spanning trees, flows in networks, \& matchings in bipartite graphs, \& addresses further algorithmic problems of practical application on trees \& graphs. Much of material presented on book is only available in specialized research literature.
	
	-- Thuật toán đồ thị, 1 môn học lâu đời trong chương trình giảng dạy toán học \& CS, cũng rất được các ngành học quan tâm, ví dụ như sinh học phân tử tính toán \& hóa học tính toán. Cuốn sách này đi xa hơn các bài toán đồ thị {\it cổ điển} về đường đi ngắn nhất, cây bao trùm, luồng trong mạng, \& phép ghép trong đồ thị hai phần, \& giải quyết các bài toán thuật toán khác về ứng dụng thực tế trên cây \& đồ thị. Phần lớn tài liệu trình bày trong sách chỉ có trong tài liệu nghiên cứu chuyên ngành.
	
	Book is structured around fundamental problem of isomorphism. Tree isomorphism is covered in much detail, together with related problems of subtree isomorphism, maximum common subtree isomorphism, \& tree comparison. Graph isomorphism is also covered in much detail, together with related problems of subgraph isomorphism, maximum common subgraph isomorphism, \& graph edit distance. A building block for solving some of these isomorphism problems are algorithms for finding maximal \& maximum cliques.
	
	-- Sách được cấu trúc xung quanh vấn đề cơ bản về phép đồng cấu. Phép đồng cấu cây được trình bày chi tiết, cùng với các vấn đề liên quan đến phép đồng cấu cây con, phép đồng cấu cây con chung cực đại, \& so sánh cây. Phép đồng cấu đồ thị cũng được trình bày chi tiết, cùng với các vấn đề liên quan đến phép đồng cấu đồ thị con, phép đồng cấu đồ thị con chung cực đại, \& khoảng cách chỉnh sửa đồ thị. Một khối xây dựng để giải quyết 1 số vấn đề về phép đồng cấu này là các thuật toán để tìm các nhóm \& cực đại.
	
	Most intractable graph problems of practical application are not even approximable to within a constant bound, \& several of isomorphism problems addressed in this book are no exception. Book can thus be seen as a companion to recent texts on approximation algorithms [1, 16], but also as a complement to previous texts on combinatorial \& graph algorithms [2--15, 17].
	
	-- Hầu hết các bài toán đồ thị khó giải của ứng dụng thực tế thậm chí không thể xấp xỉ trong 1 giới hạn hằng số, \& 1 số bài toán đồng cấu được đề cập trong cuốn sách này cũng không ngoại lệ. Do đó, cuốn sách có thể được coi là 1 phần bổ sung cho các văn bản gần đây về thuật toán xấp xỉ [1, 16], nhưng cũng là phần bổ sung cho các văn bản trước đó về thuật toán đồ thị \& tổ hợp [2--15, 17].
	
	Book is conceived on ground of 1st, introducing simple algorithms for these problems in order to develop some intuition before moving on to more complicated algorithms from research literature \& 2nd, stimulating graduate research on tree \& graph algorithms by providing together with underlying theory, a solid basis for experimentation \& further development.
	
	-- Cuốn sách được hình thành trên cơ sở thứ nhất, giới thiệu các thuật toán đơn giản cho các bài toán này để phát triển trực giác trước khi chuyển sang các thuật toán phức tạp hơn từ tài liệu nghiên cứu \& Thứ hai, kích thích nghiên cứu sau đại học về thuật toán cây \& đồ thị bằng cách cung cấp cùng với lý thuyết cơ bản, 1 cơ sở vững chắc cho thử nghiệm \& phát triển hơn nữa.
	
	Algorithms are presented on an intuitive basis, followed by a detailed exposition in a literate programming style. Correctness proofs are also given, together with a worst-case analysis of algorithms. Further, full C++ implementation of all algorithms using LEDA library of efficient data structures \& algorithms is given along book. These implementations include result checking of implementation correctness using correctness certificates.
	
	-- Thuật toán được trình bày theo cách trực quan, tiếp theo là phần trình bày chi tiết theo phong cách lập trình dễ hiểu. Các bằng chứng về tính đúng đắn cũng được đưa ra, cùng với phân tích trường hợp xấu nhất của thuật toán. Ngoài ra, triển khai C++ đầy đủ của tất cả các thuật toán sử dụng thư viện LEDA về các cấu trúc dữ liệu hiệu quả \& thuật toán được đưa ra cùng với sách. Các triển khai này bao gồm kiểm tra kết quả về tính đúng đắn của triển khai bằng cách sử dụng chứng chỉ tính đúng đắn.
	
	Choice of LEDA, which is becoming a de-facto standard for graduate courses on graph algorithms throughout world is not casual, because it allows student, lecturer, researcher, \& practitioner to complement algorithmic graph theory with actual implementation \& experimentation, building upon a thorough library of efficient implementations of modern data structures \& fundamental algorithms.
	
	-- Việc lựa chọn LEDA, đang trở thành tiêu chuẩn thực tế cho các khóa học sau đại học về thuật toán đồ thị trên toàn thế giới, không phải là việc tùy tiện, vì nó cho phép sinh viên, giảng viên, nhà nghiên cứu, \& người thực hành bổ sung lý thuyết đồ thị thuật toán bằng cách triển khai \& thử nghiệm thực tế, dựa trên 1 thư viện toàn diện về các triển khai hiệu quả của các cấu trúc dữ liệu hiện đại \& thuật toán cơ bản.
	
	An interactive demonstration including animations of all algorithms using LEDA is given in an appendix. Interactive demonstration also includes visual checkers of implementation correctness.
	
	-- Một bản trình diễn tương tác bao gồm hoạt ảnh của tất cả các thuật toán sử dụng LEDA được đưa ra trong phần phụ lục. Bản trình diễn tương tác cũng bao gồm các công cụ kiểm tra trực quan về tính chính xác của việc triển khai.
	
	Book is divided into 4 parts. Part I has an introductory nature \& consists of 2 chaps. Chap. 1 includes a review of basic graph-theoretical notions \& results used along book, a brief primer of literate programming, \& an exposition of implementation correctness approach by result checking using correctness certificates. Chap. 2 is devoted exclusively to fundamental algorithmic techniques used in book: backtracking, branch-\&-bound, divide-\&-conquer, \& DP. These techniques are illustrated by means of a running example: algorithms for tree edit distance problem.
	
	-- Sách được chia thành 4 phần. Phần I có tính chất giới thiệu \& gồm 2 chương. Chương 1 bao gồm phần tổng quan về các khái niệm cơ bản về lý thuyết đồ thị \& kết quả được sử dụng trong sách, 1 bài tóm tắt ngắn gọn về lập trình có hiểu biết, \& trình bày về cách tiếp cận tính đúng đắn của việc triển khai bằng cách kiểm tra kết quả bằng cách sử dụng các chứng chỉ tính đúng đắn. Chương 2 dành riêng cho các kỹ thuật thuật toán cơ bản được sử dụng trong sách: quay lui, nhánh-\&-bound, chia-\&-chinh phục, \& DP. Các kỹ thuật này được minh họa bằng 1 ví dụ đang chạy: các thuật toán cho bài toán khoảng cách chỉnh sửa cây.
	
	Part II also consists of 2 chaps. Chap. 3 addresses most common methods for traversing general, rooted trees: depth-1st prefix leftmost (preorder), depth-1st prefix rightmost, depth-1st postfix leftmost (postorder), depth-1st postfix rightbost, breadth-1st leftmost (top-down), breadth-1st rightmost, \& bottom-up traversal. Tree drawing is also discussed as an application of tree traversal methods. Chap. 4 addresses several isomorphism problems on ordered \& unordered trees: tree isomorphism, subtree isomorphism, \& maximum common subtree isomorphism. Computational molecular biology is also discussed as an application of different isomorphism problems on trees.
	
	-- Phần II cũng bao gồm 2 chương. Chương 3 đề cập đến các phương pháp phổ biến nhất để duyệt các cây có gốc chung: tiền tố độ sâu 1 bên trái nhất (thứ tự trước), tiền tố độ sâu 1 bên phải nhất, hậu tố độ sâu 1 bên trái nhất (thứ tự sau), hậu tố độ sâu 1 bên phải nhất, chiều rộng 1 bên trái nhất (từ trên xuống), chiều rộng 1 bên phải nhất, duyệt \& từ dưới lên. Vẽ cây cũng được thảo luận như 1 ứng dụng của các phương pháp duyệt cây. Chương 4 đề cập đến 1 số vấn đề đồng cấu trên cây có thứ tự \& không có thứ tự: đồng cấu cây, đồng cấu cây con, đồng cấu cây con chung \& lớn nhất. Sinh học phân tử tính toán cũng được thảo luận như 1 ứng dụng của các vấn đề đồng cấu khác nhau trên cây.
	
	Part III consists of 3 chaps. Chap. 5 addresses most common methods for traversing graphs: depth-1st \& breadth-1st traversal, which resp. generalize depth-1st prefix leftmost (preorder) \& breadth-1st left-most (top-down) tree traversal. Leftmost depth-1st traversal of an undirected graph, a particular case of depth-1st traversal, is also discussed. Isomorphism of ordered graphs is also discussed as an application of graph traversal methods. Chap. 6 addresses related problems of finding cliques, independent sets, \& vertex covers in trees \& graphs. Multiple alignment of protein sequences in computational molecular biology is also discussed as an application of clique algorithms. Chap. 7 addresses several isomorphism problems on graphs: graph isomorphism, graph automorphism, subgraph isomorphism, \& maximum common subgraph isomorphism. Chemical structure search is also discussed as an application of different graph isomorphism problems.
	
	-- Phần III gồm 3 chương. Chương 5 đề cập đến các phương pháp phổ biến nhất để duyệt đồ thị: duyệt theo chiều sâu 1 \& theo chiều rộng 1, tương ứng là tổng quát hóa tiền tố chiều sâu 1 bên trái nhất (thứ tự trước) \& duyệt cây theo chiều rộng 1 bên trái nhất (từ trên xuống). Duyệt theo chiều sâu 1 bên trái nhất của đồ thị vô hướng, 1 trường hợp cụ thể của duyệt theo chiều sâu 1, cũng được thảo luận. Đồng cấu của đồ thị có thứ tự cũng được thảo luận như 1 ứng dụng của các phương pháp duyệt đồ thị. Chương 6 đề cập đến các vấn đề liên quan đến việc tìm clique, các tập độc lập, \& các lớp phủ đỉnh trong cây \& đồ thị. Căn chỉnh nhiều chuỗi protein trong sinh học phân tử tính toán cũng được thảo luận như 1 ứng dụng của các thuật toán clique. Chương 7 đề cập đến 1 số vấn đề đồng cấu trên đồ thị: đồng cấu đồ thị, tự động cấu đồ thị, đồng cấu đồ thị con, đồng cấu \& đồ thị con chung lớn nhất. Tìm kiếm cấu trúc hóa học cũng được thảo luận như 1 ứng dụng của các vấn đề đồng cấu đồ thị khác nhau.
	
	Part IV consists of 2 appendices, followed by bibliographies references \& an index. Appendix A gives an overview of LEDA, including a simple C++ representation of trees as LEDA graphs, \& a C++ implementation of radix sort using LEDA. Interactive demonstration of graph algorithms presented along book is put together in Appendix B. Finally, Appendix C contains a complete index to all program modules described in book.
	
	-- Phần IV gồm 2 phụ lục, tiếp theo là các tài liệu tham khảo \& 1 chỉ mục. Phụ lục A cung cấp tổng quan về LEDA, bao gồm 1 biểu diễn C++ đơn giản của cây dưới dạng đồ thị LEDA, \& 1 triển khai C++ của thuật toán sắp xếp radix sử dụng LEDA. Bản trình bày tương tác về các thuật toán đồ thị được trình bày dọc theo sách được tập hợp trong Phụ lục B. Cuối cùng, Phụ lục C chứa 1 chỉ mục đầy đủ cho tất cả các mô-đun chương trình được mô tả trong sách.
	
	This book is suitable for use in upper undergraduate \& graduate level courses on algorithmic graph theory. This book can also be used as a supplementary text in basic undergraduate \& graduate level courses on algorithms \& data structures, \& in computational molecular biology \& computational chemistry courses as well. Some basic knowledge of discrete mathematics, data structures, algorithms, \& programming at undergraduate level is assumed.
	
	{\sf PART I: INTRODUCTION.}
	
	\item {\sf1. Introduction.}
	\begin{itemize}
		\item {\sf1.1. Trees \& Graphs.} Notion of graph which is most useful in CS is that of a directed or just a graph. A graph is a combinatorial structure consisting of a finite nonempty set of objects, called {\it vertices}, together with a finite (possibly empty) set of ordered pairs of vertices, called {\it directed edges} or {\it arcs}.
		\item {\sf1.2. Basic Data Structures.}
		\item {\sf1.3. Representation of Trees \& Graphs.}
		\item {\sf Summary.}
	\end{itemize}
	\item {\sf2. Algorithmic Techniques.}
	
	{\sf PART II: ALGORITHMS ON TREES.}
	\item {\sf3. Tree Traversal.}
	\item {\sf4. Tree Isomorphism.}
	
	{\sf PART III: ALGORITHMS ON GRAPHS.}
	\item {\sf5. Graph Traversal.}
	\item {\sf6. Clique, Independent Set, \& Vertex Cover.}
	\item {\sf7. Graph Isomorphism.}
	\item {\sf A: Implementation of Algorithms in Python.}
	\item {\sf B: Solutions to All Problems.}
\end{itemize}

%------------------------------------------------------------------------------%

\section{Optimization on Graphs}

%------------------------------------------------------------------------------%

\subsection{{\sc Irwan Bello, Hieu Pham, Quoc V. Le, Mohammad Norouzi, Samy Bengio}. Neural Combinatorial Optimization with Reinforcement Learning}

\begin{itemize}
    \item {\sf Abstract.} Present a framework to tackle combinatorial optimization problems using neural networks \& reinforcement learning. Focus on traveling salesman problem (TSP) \& train a RNN that, given a set of city coordinates, predicts a distribution over different city permutations. Using negative tour length as the reward signal, optimize parameters of RNN using a policy gradient method. Compare learning network parameters on a set of training graphs against learning them on individual test graphs. Despite computational expense, without much engineering \& heuristic designing, Neural Combinatorial Optimization achieves close to optimal results on 2D Euclidean graphs with up to 100 nodes. Applied to KnapSack, another NP-hard problem, same method obtains optimal solutions e.g. with up to 200 items.
    
    -- Trình bày 1 khuôn khổ để giải quyết các vấn đề tối ưu hóa tổ hợp bằng cách sử dụng mạng nơ-ron \& học tăng cường. Tập trung vào bài toán người bán hàng du lịch (TSP) \& đào tạo 1 RNN, với 1 tập hợp các tọa độ thành phố, dự đoán phân phối trên các hoán vị thành phố khác nhau. Sử dụng độ dài chuyến tham quan âm làm tín hiệu phần thưởng, tối ưu hóa các tham số của RNN bằng phương pháp gradient chính sách. So sánh các tham số mạng học trên 1 tập hợp các đồ thị đào tạo với việc học chúng trên các đồ thị thử nghiệm riêng lẻ. Mặc dù tốn kém về mặt tính toán, không cần nhiều kỹ thuật \& thiết kế theo phương pháp tìm kiếm, Tối ưu hóa tổ hợp nơ-ron đạt được kết quả gần như tối ưu trên đồ thị Euclid 2D với tối đa 100 nút. Áp dụng cho KnapSack, 1 bài toán NP-khó khác, phương pháp tương tự thu được các giải pháp tối ưu, ví dụ với tối đa 200 mục.
    \item {\sf1. Introduction.} {\it Combinatorial optimization} is a fundamental problem in CS. A canonical example is {\it traveling salesman problem} (TSP), where given a graph, one needs to search space of permutations to find an optimal sequence of nodes with minimal total edge weights (tour length). TSP \& its variants have myriad applications in planning, manufacturing, genetics, etc. (see (Applegate et al., 2011) for an overview).
    
    --{\it Tối ưu hóa tổ hợp} là 1 bài toán cơ bản trong CS. Một ví dụ điển hình là {\it Bài toán người bán hàng du lịch} (TSP), trong đó với 1 đồ thị, người ta cần tìm kiếm không gian hoán vị để tìm ra 1 chuỗi tối ưu các nút có tổng trọng số cạnh (chiều dài hành trình) nhỏ nhất. TSP \& các biến thể của nó có vô số ứng dụng trong lập kế hoạch, sản xuất, di truyền, v.v.
        
    Finding optimal TSP solution is NP-hard, even in 2D Euclidean case (Papadimitriou, 1977), where nodes are 2D points \& edge weights are Euclidean distances between pairs of points. In practice, TSP solvers rely on handcrafted heuristics that guide their search procedures to find competitive tours efficiently. Even though these heuristics work well on TSP, once problem statement changes slightly, they need to be revised. In contrast, ML methods have potential to be applicable across many optimization tasks by automatically discovering their own heuristics based on training data, thus requiring less hand-engineering than solvers that are optimized for 1 task only.
    
    -- Việc tìm ra giải pháp TSP tối ưu là NP-khó, ngay cả trong trường hợp Euclidean 2D (Papadimitriou, 1977), trong đó các nút là các điểm 2D \& trọng số cạnh là khoảng cách Euclidean giữa các cặp điểm. Trong thực tế, các trình giải TSP dựa vào các phương pháp tìm kiếm thủ công hướng dẫn các quy trình tìm kiếm của chúng để tìm các tour du lịch cạnh tranh 1 cách hiệu quả. Mặc dù các phương pháp tìm kiếm này hoạt động tốt trên TSP, nhưng khi phát biểu bài toán thay đổi 1 chút, chúng cần được sửa đổi. Ngược lại, các phương pháp ML có tiềm năng áp dụng trên nhiều tác vụ tối ưu hóa bằng cách tự động khám phá các phương pháp tìm kiếm của riêng chúng dựa trên dữ liệu đào tạo, do đó đòi hỏi ít kỹ thuật thủ công hơn so với các trình giải được tối ưu hóa chỉ cho 1 tác vụ.
    
    While most successful ML techniques fall into family of supervised learning, where a mapping fro training inputs to outputs is learned, supervised learning is not applicable to most combinatorial optimization problems because one does not have access to optimal labels. However, one can compare quality of a set of solutions using a verifier, \& provide some reward feedbacks to a learning algorithm. Hence, follow reinforcement learning (RL) paradigm to tackle combinatorial optimization. Empirically demonstrate that, even when using optimal solutions as labeled data to optimize a supervised mapping, generalization is rather poor compared to an RL agent that explores different tours \& observes their corresponding rewards.
    
    -- Trong khi hầu hết các kỹ thuật ML thành công đều thuộc nhóm học có giám sát, trong đó ánh xạ từ đầu vào đào tạo đến đầu ra được học, học có giám sát không áp dụng được cho hầu hết các vấn đề tối ưu hóa tổ hợp vì người ta không có quyền truy cập vào các nhãn tối ưu. Tuy nhiên, người ta có thể so sánh chất lượng của một tập hợp các giải pháp bằng cách sử dụng trình xác minh, \& cung cấp một số phản hồi phần thưởng cho thuật toán học. Do đó, hãy làm theo mô hình học tăng cường (RL) để giải quyết tối ưu hóa tổ hợp. Chứng minh theo kinh nghiệm rằng, ngay cả khi sử dụng các giải pháp tối ưu làm dữ liệu có nhãn để tối ưu hóa ánh xạ có giám sát, thì khả năng khái quát hóa vẫn khá kém so với tác nhân RL khám phá các chuyến tham quan khác nhau \& quan sát phần thưởng tương ứng của chúng.
    
    Propose Neural Combinatorial Optimization, a framework to tackle combinatorial optimization problems using reinforcement learning \& neural networks. Consider 2 approaches based on policy gradients (Williams, 1992). 1st approach, called {\it RL pretraining}, uses a training set to optimize a RNN that parameterizes a stochastic policy over solutions, using expected reward as objective. At test time, policy is fixed, \& one performs inference by greedy decoding or sampling. 2nd approach, called {\it active search}, involves no pretraining. It starts from a random policy \& iteratively optimizes RNN parameters on a single test instance, again using expected reward objective, while keeping track of best solution sampled during search. Find: combining RL pretraining \& active search works best in practice.
    
    -- Đề xuất Tối ưu hóa tổ hợp nơ-ron, một khuôn khổ để giải quyết các vấn đề tối ưu hóa tổ hợp bằng cách sử dụng học tăng cường \& mạng nơ-ron. Xem xét 2 cách tiếp cận dựa trên các gradient chính sách (Williams, 1992). Cách tiếp cận thứ nhất, được gọi là {\it RL pretraining}, sử dụng một tập huấn luyện để tối ưu hóa RNN tham số hóa một chính sách ngẫu nhiên trên các giải pháp, sử dụng phần thưởng mong đợi làm mục tiêu. Tại thời điểm kiểm tra, chính sách được cố định, \& người ta thực hiện suy luận bằng cách giải mã tham lam hoặc lấy mẫu. Cách tiếp cận thứ hai, được gọi là {\it active search}, không liên quan đến việc đào tạo trước. Nó bắt đầu từ một chính sách ngẫu nhiên \& tối ưu hóa lặp lại các tham số RNN trên một trường hợp kiểm tra duy nhất, một lần nữa sử dụng mục tiêu phần thưởng mong đợi, trong khi theo dõi giải pháp tốt nhất được lấy mẫu trong quá trình tìm kiếm. Tìm: kết hợp RL pretraining \& active search hoạt động tốt nhất trong thực tế.
    
    On 2D Euclidean graphs with up to 100 nodes, Neural Combinatorial Optimization significantly outperforms supervised learning approach to TSP (Vinyals et al., 2015b) \& obtains close to optimal results when allowed more computation time. Illustrate its flexibility by testing same method on KnapSack problem, for which get optimal results e.g. with up to 200 items. These results give insights into how neural networks can be used as a general tool for tackling combinatorial optimization problems, especially those that are difficult to design heuristics for.
    
    -- Trên đồ thị Euclid 2D với tối đa 100 nút, Neural Combinatorial Optimization vượt trội hơn đáng kể so với phương pháp học có giám sát đối với TSP (Vinyals et al., 2015b) \& đạt được kết quả gần tối ưu khi được phép có nhiều thời gian tính toán hơn. Minh họa tính linh hoạt của nó bằng cách thử nghiệm cùng phương pháp trên bài toán KnapSack, trong đó đạt được kết quả tối ưu, ví dụ với tối đa 200 mục. Những kết quả này cung cấp thông tin chi tiết về cách mạng nơ-ron có thể được sử dụng như một công cụ chung để giải quyết các bài toán tối ưu hóa tổ hợp, đặc biệt là những bài toán khó thiết kế phương pháp tìm kiếm.
    \item {\sf2. Previous Work.} TSP is a well studied combinatorial optimization problem \& many exact or approximate algorithms have been proposed for both Euclidean \& non-Euclidean graphs. Christofides (1976) proposes a heuristic algorithm that involves computing a minimum-spanning tree \& a minimum-weight perfect matching. Algorithm has polynomial running time \& returns solutions guaranteed to be within a factor of $1.5\times$ to optimality in the metric instance of TSP.
    
    -- TSP là một bài toán tối ưu hóa tổ hợp được nghiên cứu kỹ \& nhiều thuật toán chính xác hoặc gần đúng đã được đề xuất cho cả đồ thị Euclid \& phi Euclid. Christofides (1976) đề xuất một thuật toán heuristic liên quan đến việc tính toán một cây có khung nhỏ nhất \& một phép ghép hoàn hảo có trọng số nhỏ nhất. Thuật toán có thời gian chạy đa thức \& trả về các giải pháp được đảm bảo nằm trong hệ số $1,5\times$ để tối ưu trong trường hợp số liệu của TSP.
    
    Best known exact dynamic programming algorithm for TSP has a complexity of $\Theta(2^nn^2)$, making it infeasible to scale up to large instances, say with 40 points. Nevertheless, state of art TSP solvers, thanks to carefully handcrafted heuristics that describe how to navigate space of feasible solutions in an efficient manner, can solve symmetric TSP instances with thousands of nodes. Concorde (Applegate et al., 2006), widely accepted as 1 of best exact TSP solvers, make use of cutting plane algorithms (Dantzig et al., 1954; Padberg \& Rinaldi, 1990; Applegate et al., 2003), iteratively solving linear programming relaxations of TSP, in conjunction with a branch-\&-bound approach that prunes parts of search space that provably will not contain an optimal solution. Similarly, Lin-Kernighan-Helsgaun heuristic (Helsgaun, 2000), inspired from Lin-Kernighan heuristic (Lin \& Kernighan, 1973), is a state of art approximate search heuristic for symmetric TSP \& has been shown to solve instances with hundreds of nodes to optimality.
    
    -- Thuật toán lập trình động chính xác nổi tiếng nhất cho TSP có độ phức tạp là $\Theta(2^nn^2)$, khiến việc mở rộng lên các trường hợp lớn, chẳng hạn như 40 điểm là không khả thi. Tuy nhiên, các trình giải TSP hiện đại, nhờ vào các thuật toán tìm kiếm được chế tạo thủ công cẩn thận mô tả cách điều hướng không gian các giải pháp khả thi theo cách hiệu quả, có thể giải các trường hợp TSP đối xứng với hàng nghìn nút. Concorde (Applegate và cộng sự, 2006), được chấp nhận rộng rãi là 1 trong những trình giải TSP chính xác tốt nhất, sử dụng các thuật toán mặt phẳng cắt (Dantzig và cộng sự, 1954; Padberg \& Rinaldi, 1990; Applegate và cộng sự, 2003), giải quyết lặp đi lặp lại các phép nới lỏng lập trình tuyến tính của TSP, kết hợp với phương pháp tiếp cận nhánh\&-bound cắt tỉa các phần của không gian tìm kiếm có thể chứng minh được là không chứa giải pháp tối ưu. Tương tự như vậy, phương pháp tìm kiếm gần đúng Lin-Kernighan-Helsgaun (Helsgaun, 2000), lấy cảm hứng từ phương pháp tìm kiếm gần đúng Lin-Kernighan (Lin \& Kernighan, 1973), là một phương pháp tìm kiếm gần đúng tiên tiến cho TSP đối xứng \& đã được chứng minh là có thể giải quyết các trường hợp có hàng trăm nút đến mức tối ưu.
    
    More generic solvers, e.g. Google's vehicle routing problem solver (Google, 2016) that tackles a superset of TSP, typically rely on a combination of local search algorithms \& metaheuristics. Local search algorithms apply a specified set of local move operators on candidate solutions, based on hand-engineered heuristics e.g. 2-opt (Johnson, 1990), to navigate from solution to solution in search space. A metaheuristic is then applied to propose uphill moves \& escape local optima. A popular choice of metaheuristic for TSP \& its variants is guided local search (Voudouris \& Tsang, 1999), which moves out of a local minimum by penalizing particular solution features that it considers should not occur in a good solution.
    
    -- Các trình giải chung hơn, ví dụ như trình giải bài toán định tuyến xe của Google (Google, 2016) giải quyết một siêu tập hợp TSP, thường dựa vào sự kết hợp của các thuật toán tìm kiếm cục bộ \& siêu thuật toán. Các thuật toán tìm kiếm cục bộ áp dụng một tập hợp các toán tử di chuyển cục bộ được chỉ định trên các giải pháp ứng viên, dựa trên các thuật toán tìm kiếm được thiết kế thủ công, ví dụ như 2-opt (Johnson, 1990), để điều hướng từ giải pháp này sang giải pháp khác trong không gian tìm kiếm. Sau đó, một siêu thuật toán được áp dụng để đề xuất các bước di chuyển lên dốc \& thoát khỏi tối ưu cục bộ. Một lựa chọn phổ biến của siêu thuật toán cho TSP \& các biến thể của nó là tìm kiếm cục bộ có hướng dẫn (Voudouris \& Tsang, 1999), di chuyển ra khỏi mức tối thiểu cục bộ bằng cách phạt các tính năng giải pháp cụ thể mà nó cho là không nên xảy ra trong một giải pháp tốt.
    
    Difficulty in applying existing search heuristics to newly encountered problems -- or even new instances of a similar problem -- is a well-known challenge that stems from {\it No Free Lunch theorem} (Wolpert \& Macready, 1997). Because all search algorithms have same performance when averaged over all problems, one must appropriately rely on a prior over problems when selecting a search algorithm to guarantee performance. This challenge has fostered interest in raising level of generality at which optimization systems operate (Burke et al., 2003) \& is underlying motivation behind hyper-heuristics, defined as ``search method[s] or learning mechanism[s] for selecting or generating heuristics to solve computation search problems''. Hyper-heuristics aim to be easier to use than problem specific methods by partially abstracting away knowledge intensive process of selecting heuristics given a combinatorial problem \& have been shown to successfully combine human-defined heuristics in superior ways across many tasks (see (Burke et al., 2013) for a survey). However, hyper-heuristics operate on search space of heuristics, rather than search space of solutions, therefore still initially relying on human created heuristics.
    
    -- Khó khăn trong việc áp dụng các phương pháp tìm kiếm hiện có vào các vấn đề mới gặp -- hoặc thậm chí là các trường hợp mới của một vấn đề tương tự -- là một thách thức nổi tiếng bắt nguồn từ {\it Định lý Không có bữa trưa miễn phí} (Wolpert \& Macready, 1997). Bởi vì tất cả các thuật toán tìm kiếm đều có cùng hiệu suất khi tính trung bình trên tất cả các vấn đề, nên người ta phải dựa vào một cách thích hợp vào một vấn đề trước khi chọn một thuật toán tìm kiếm để đảm bảo hiệu suất. Thách thức này đã thúc đẩy sự quan tâm trong việc nâng cao mức độ tổng quát mà các hệ thống tối ưu hóa hoạt động (Burke và cộng sự, 2003) \& là động lực cơ bản đằng sau các siêu phương pháp tìm kiếm, được định nghĩa là ``phương pháp tìm kiếm hoặc cơ chế học tập để lựa chọn hoặc tạo ra các phương pháp tìm kiếm nhằm giải quyết các vấn đề tìm kiếm tính toán''. Các siêu phương pháp tìm kiếm hướng đến mục đích dễ sử dụng hơn các phương pháp cụ thể của vấn đề bằng cách trừu tượng hóa một phần quá trình chuyên sâu về kiến thức để lựa chọn các phương pháp tìm kiếm cho một vấn đề kết hợp \& đã được chứng minh là kết hợp thành công các phương pháp tìm kiếm do con người xác định theo những cách vượt trội trong nhiều nhiệm vụ (xem (Burke và cộng sự, 2013) để biết khảo sát). Tuy nhiên, siêu phương pháp tìm kiếm hoạt động trên không gian tìm kiếm của phương pháp tìm kiếm, thay vì không gian tìm kiếm các giải pháp, do đó ban đầu vẫn dựa trên phương pháp tìm kiếm do con người tạo ra.
\end{itemize}

%------------------------------------------------------------------------------%

\subsection{\cite{Goldengorin2018}. {\sc Boris Goldengorin}. Optimization Problems in Graph Theory. 2018}

\begin{itemize}
    \item {\sf Preface.} Problem raised by Moon in 1960s, of estimating minimum possible number of vertices in a tournament that contains every $k$-vertex tournament as an induced subgraph. Main result: this number is $(1 + o(1))2^{\frac{k-1}{2}}$, improving earlier estimates of several researchers. Proof combines combinatorial \& probabilistic techniques with group theoretic tools.
\end{itemize}

%------------------------------------------------------------------------------%

\section{Wikipedia's}

\subsection{Wikipedia{\tt/}extremal combinatorics}
``{\it Extremal combinatorics} is a field of mathematics, which is itself a part of mathematics. Extremal combinatorics studies how large or how small a collection of finite objects (numbers, graphs, vectors, sets, etc.) can be, if it has to satisfy certain restrictions.

Much of extremal combinatorics concerns \href{https://en.wikipedia.org/wiki/Class_(set_theory)}{classes} of sets; this is called {\it extremal set theory}. E.g., in an $n$-element set, what is the largest number of $k$-element subsets that can pairwise intersect one another? What is the largest number of subsets of which more contains any other? The latter question is answered by \href{https://en.wikipedia.org/wiki/Sperner%27s_theorem}{Sperner's theorem}, which gave rise to much of extremal set theory.

Another kind of example: How many people can be invited to a party where among each 3 people there are 2 who know each other \& 2 who don't know each other? \href{https://en.wikipedia.org/wiki/Ramsey_theory}{Ramsey theory} shows: at most 5 persons can attend such a party (see \href{https://en.wikipedia.org/wiki/Theorem_on_Friends_and_Strangers}{Theorem on Friends \& Strangers}). Or, suppose given a finite set of nonzero integers, \& are asked to mark as large a subset as possible of this set under the restriction that the sum of any 2 marked integers cannot be marked. It appears that (independent of what the given integers actually are) we can always mark at least $\frac{1}{3}$ of them.'' -- \href{https://en.wikipedia.org/wiki/Extremal_combinatorics}{Wikipedia{\tt/}extremal combinatorics}

%------------------------------------------------------------------------------%

\subsection{Wikipedia{\tt/}extremal graph theory}
``{\sf\href{https://en.wikipedia.org/wiki/Tur%C3%A1n_graph}{Tur\'an graph} $T(n,r)$ is an example of an extremal graph. It has the maximum possible number of edges for a graph on $n$ vertices without $(r + 1)$-\href{https://en.wikipedia.org/wiki/Clique_(graph_theory)}{cliques}. This is $T(13,4)$.} {\it Extremal graph theory} is a branch of combinatorics, itself an area of mathematics, that lies at the intersection of \href{https://en.wikipedia.org/wiki/Extremal_combinatorics}{extremal combinatorics} \& \href{https://en.wikipedia.org/wiki/Graph_theory}{graph theory}. In essence, extremal graph theory studies how global properties of a graph influence local substructure. Results in extremal graph theory deal with quantitative connections between various \href{https://en.wikipedia.org/wiki/Graph_property}{graph properties}, both global (e.g. number of vertices \& edges) \& local (e.g. existence of specific subgraphs), \& problems in extremal graph theory can often be formulated as optimization problems: how big or small a parameter of a graph can be, given some constraints that the graph has to satisfy? A graph that is an optimal solution to such an optimization problem is called an {\it extremal graph}, \& extremal graphs are important objects of study in extremal graph theory.

Extremal graph theory is closely related to fields e.g. \href{https://en.wikipedia.org/wiki/Ramsey_theory}{Ramsey theory}, \href{https://en.wikipedia.org/wiki/Spectral_graph_theory}{spectral graph theory}, \href{https://en.wikipedia.org/wiki/Computational_complexity_theory}{computational complexity theory}, \& \href{https://en.wikipedia.org/wiki/Additive_combinatorics}{additive combinatorics}, \& frequently employs \href{https://en.wikipedia.org/wiki/Probabilistic_method}{probabilistic method}.

\subsubsection{History}

\begin{quote}
	``Extremal graph theory, in its strictest sense, is a branch of graph theory developed \& loved by Hungarians.'' -- {\sc Bollob\'as} (2004)
\end{quote}
Mantel's Theorem (1907) \& \href{https://en.wikipedia.org/wiki/Tur%C3%A1n%27s_theorem}{Tur\'an's Theorem} (1941) were some of 1st milestones in stud of extremal graph theory. In particular, Tur\'an's theorem would later on become a motivation for the finding of results e.g. \href{https://en.wikipedia.org/wiki/Erd%C5%91s%E2%80%93Stone_theorem}{Erd\H{o}s--Stone theorem} (1946). This result is surprising because it connects chromatic number with maximal number of edges in an $H$-free graph. An alternative proof of Erd\H{o}s--Stone was given in 1975, \& utilized \href{https://en.wikipedia.org/wiki/Szemer%C3%A9di_regularity_lemma}{Szemer\'edi regularity lemma}, an essential technique in resolution of extremal graph theory problems.

\subsubsection{Topics \& concepts}

\begin{itemize}
	\item {\bf Graph coloring.} Main article: \href{https://en.wikipedia.org/wiki/Graph_coloring}{Wikipedia{\tt/}graph coloring}. A {\it proper (vertex) coloring} of a graph $G$ is a coloring of vertices of $G$ s.t. no 2 adjacent vertices have the same color. Minimum number of colors needed to properly color $G$ is called {\it chromatic number} of $G$, denoted $\chi(G)$. Determining chromatic number of specific graphs is a fundamental question in extremal graph theory, because many problems in area \& related areas can be formulated in terms of graph coloring.
	
	2 simple lower bounds to chromatic number of a graph $G$ is given by \href{https://en.wikipedia.org/wiki/Clique_number}{clique number} $\omega(G)$ -- all vertices of a clique must have distinct colors -- \& by $\frac{|V(G)|}{\alpha(G)}$, where $\alpha(G)$ is independence number, because set of vertices with a given color must form an \href{https://en.wikipedia.org/wiki/Independent_set_(graph_theory)}{independent set}.
	
	A \href{https://en.wikipedia.org/wiki/Greedy_coloring}{greedy coloring} gives upper bound $\chi(G)\le\Delta(G) + 1$, where $\Delta(G)$ is maximum degree of $G$. When $G$ is not an odd cycle or a clique, \href{https://en.wikipedia.org/wiki/Brooks%27_theorem}{Brooks' theorem} states: upper bound can be reduced to $\Delta(G)$. When $G$ is a \href{https://en.wikipedia.org/wiki/Planar_graph}{planar graph}, \href{https://en.wikipedia.org/wiki/Four-color_theorem}{4-color theorem} states: $G$ has chromatic number $\le4$.
	
	In general, determining whether a given graph has a coloring with a prescribed number of colors is known to be \href{https://en.wikipedia.org/wiki/NP-hard}{NP-hard}.
	
	In addition to vertex coloring, other types of coloring are also studied, e.g. \href{https://en.wikipedia.org/wiki/Edge_coloring}{edge colorings}. {\it Chromatic index} $\chi'(G)$ of a graph $G$ is minimum number of colors in a proper edge-coloring of a graph, \& \href{https://en.wikipedia.org/wiki/Vizing%27s_theorem}{Vizing's theorem} states: chromatic index of a graph $G$ is either $\Delta(G)$ or $\Delta(G) + 1$.
	\item {\bf Forbidden subgraphs.} Main article: \href{https://en.wikipedia.org/wiki/Forbidden_subgraph_problem}{Wikipedia{\tt/}forbidden subgraph problem}. {\it Forbidden subgraph problem} is 1 of central problems in extremal graph theory. Given a graph $G$, forbidden subgraph problem asks for maximal number of edges ${\rm ex}(n,G)$ in an $n$-vertex graph that does not contain a subgraph isomorphic to $G$.
	
	When $G = K_r$ is a complete graph, \href{https://en.wikipedia.org/wiki/Tur%C3%A1n%27s_theorem}{Tur\'an's theorem} gives an exact value for ${\rm ex}(n,K_r)$ \& characterizes all graphs attaining this maximum; such graphs are known as Tur\'an graphs. For non-bipartite graphs $G$, \href{https://en.wikipedia.org/wiki/Erd%C5%91s%E2%80%93Stone_theorem}{Erd\H{o}s--Stone theorem} gives an asymptotic value of ${\rm ex}(n,G)$ in terms of chromatic number of $G$. Problem of determining asymptotics of ${\rm ex}(n,G)$ when $G$ is a \href{https://en.wikipedia.org/wiki/Bipartite_graph}{bipartite graph} is open; when $G$ is a complete bipartite graph, this is known as \href{https://en.wikipedia.org/wiki/Zarankiewicz_problem}{Zarankiewicz problem}.
	\item {\bf Homomorphism density.} Main article: \href{https://en.wikipedia.org/wiki/Homomorphism_density}{Wikipedia{\tt/}Homomorphism density}. {\it Homomorphism density} $t(H,G)$ of a graph $H$ in a graph $G$ describes probability that a randomly chosen map from vertex set of $H$ to vertex set of $G$ is also a \href{https://en.wikipedia.org/wiki/Graph_homomorphism}{graph homomorphism}. It is closely related to {\it subgraph density}, which describes how often a graph $H$ is found as a subgraph of $G$.
	
	Forbidden subgraph problem can be restated as maximizing edge density of a graph with $G$-density 0, \& this naturally leads to generalization in form of {\it graph homomorphism inequalities}, which are inequalities relating $t(H,G)$ for various graphs $H$. By extending homomorphism density to \href{https://en.wikipedia.org/wiki/Graphon}{graphons}, which are objects that arise as a limit of \href{https://en.wikipedia.org/wiki/Dense_graph}{dense graphs}, graph homomorphism density can be written in form of integrals, \& inequalities e.g. \href{https://en.wikipedia.org/wiki/Cauchy-Schwarz_inequality}{Cauchy--Schwarz inequality} \& \href{https://en.wikipedia.org/wiki/H%C3%B6lder%27s_inequality}{H\"older's inequality} can be used to derive homomorphism inequalities.
	
	A major open problem relating homomorphism densities is \href{https://en.wikipedia.org/wiki/Sidorenko%27s_conjecture}{Sidorenko's conjecture}, which states a tight lower bound on homomorphism density of a bipartite graph in a graph $G$ in terms of edge density of $G$.
	\item {\bf Graph regularity.} Main article: \href{https://en.wikipedia.org/wiki/Szemer%C3%A9di_regularity_lemma}{Wikipedia{\tt/}Szemerédi regularity lemma}. {\sf Edges between parts in a regular partition behave in a ``random-like'' fashion.} {\it Szemerédi's regularity lemma} states: all graphs are `regular' in sense: vertex set of any given graph can be partitioned into a bounded number of parts s.t. bipartite graph between most pairs of parts behave like \href{https://en.wikipedia.org/wiki/Random_graph}{random bipartite graphs}. This partition gives a structural approximation to original graph, which reveals information about properties of original graph.
	
	Regularity lemma is a central result in extremal graph theory, \& also has numerous applications in adjacent fields of \href{https://en.wikipedia.org/wiki/Additive_combinatorics}{additive combinatorics} \& \href{https://en.wikipedia.org/wiki/Computational_complexity_theory}{commputational complexity theory}. In addition to (Szemerédi) regularity, closely related notions of graph regularity e.g. strong regularity \& Frieze-Kannan weak regularity have also been studied, as well as extensions of regularity to \href{https://en.wikipedia.org/wiki/Hypergraphs}{hypergraphs}.
	
	Applications of graph regularity often utilize forms of counting lemmas \& removal lemmas. In simplest forms, \href{https://en.wikipedia.org/wiki/Graph_removal_lemma#graph_counting_lemma}{graph counting lemma} uses regularity between pairs of parts in a regular partition to approximate number of subgraphs, \& \href{https://en.wikipedia.org/wiki/Graph_removal_lemma}{graph removal lemma} states: given a graph with few copies of a given subgraph, can remove a small number of edges to eliminate all copies of subgraph.'' -- \href{https://en.wikipedia.org/wiki/Extremal_graph_theory}{Wikipedia{\tt/}extremal graph theory}
\end{itemize}

%------------------------------------------------------------------------------%

\section{Miscellaneous}

%------------------------------------------------------------------------------%

\printbibliography[heading=bibintoc]
	
\end{document}