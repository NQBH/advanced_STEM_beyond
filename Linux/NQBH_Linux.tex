\documentclass{article}
\usepackage[backend=biber,natbib=true,style=alphabetic,maxbibnames=50]{biblatex}
\addbibresource{/home/nqbh/reference/bib.bib}
\usepackage[utf8]{vietnam}
\usepackage{tocloft}
\renewcommand{\cftsecleader}{\cftdotfill{\cftdotsep}}
\usepackage[colorlinks=true,linkcolor=blue,urlcolor=red,citecolor=magenta]{hyperref}
\usepackage{amsmath,amssymb,amsthm,enumitem,float,graphicx,mathtools,tikz}
\usetikzlibrary{angles,calc,intersections,matrix,patterns,quotes,shadings}
\allowdisplaybreaks
\newtheorem{assumption}{Assumption}
\newtheorem{baitoan}{}
\newtheorem{cauhoi}{Câu hỏi}
\newtheorem{conjecture}{Conjecture}
\newtheorem{corollary}{Corollary}
\newtheorem{dangtoan}{Dạng toán}
\newtheorem{definition}{Definition}
\newtheorem{dinhly}{Định lý}
\newtheorem{dinhnghia}{Định nghĩa}
\newtheorem{example}{Example}
\newtheorem{ghichu}{Ghi chú}
\newtheorem{hequa}{Hệ quả}
\newtheorem{hypothesis}{Hypothesis}
\newtheorem{lemma}{Lemma}
\newtheorem{luuy}{Lưu ý}
\newtheorem{nhanxet}{Nhận xét}
\newtheorem{notation}{Notation}
\newtheorem{note}{Note}
\newtheorem{principle}{Principle}
\newtheorem{problem}{Problem}
\newtheorem{proposition}{Proposition}
\newtheorem{question}{Question}
\newtheorem{remark}{Remark}
\newtheorem{theorem}{Theorem}
\newtheorem{vidu}{Ví dụ}
\usepackage[left=1cm,right=1cm,top=5mm,bottom=5mm,footskip=4mm]{geometry}
\def\labelitemii{$\circ$}
\DeclareRobustCommand{\divby}{%
    \mathrel{\vbox{\baselineskip.65ex\lineskiplimit0pt\hbox{.}\hbox{.}\hbox{.}}}%
}
\setlist[itemize]{leftmargin=*}
\setlist[enumerate]{leftmargin=*}

\title{Linux}
\author{Nguyễn Quản Bá Hồng\footnote{A scientist- {\it\&} creative artist wannabe, a mathematics {\it\&} computer science lecturer of Department of Artificial Intelligence {\it\&} Data Science (AIDS), School of Technology (SOT), UMT Trường Đại học Quản lý {\it\&} Công nghệ TP.HCM, Hồ Chí Minh City, Việt Nam.\\E-mail: {\sf nguyenquanbahong@gmail.com} {\it\&} {\sf hong.nguyenquanba@umt.edu.vn}. Website: \url{https://nqbh.github.io/}. GitHub: \url{https://github.com/NQBH}.}}
\date{\today}

\begin{document}
\maketitle
\begin{abstract}
    This text is a part of the series {\it Some Topics in Advanced STEM \& Beyond}:
    
    {\sc url}: \url{https://nqbh.github.io/advanced_STEM/}.
    
    Latest version:
    \begin{itemize}
        \item {\it }.
        
        PDF: {\sc url}: \url{.pdf}.
        
        \TeX: {\sc url}: \url{.tex}.
        \item {\it }.
        
        PDF: {\sc url}: \url{.pdf}.
        
        \TeX: {\sc url}: \url{.tex}.
    \end{itemize}
\end{abstract}
\tableofcontents

%------------------------------------------------------------------------------%

\section{Linux Programming}

\subsection{\cite{Persson2021}. {\sc Jack-Benny Persson}. Linux System Programming Techniques: Become a Proficient Linux System Programmer Using Expert Recipes \& Techniques}

\begin{itemize}
    \item {\sf Amazon review.} Find solutions to all your problems related to Linux system programming using practical recipes for developing your own system programs.
    
    {\bf Key features.}
    \begin{itemize}
        \item Develop a deeper understanding of how Linux system programming works
        \item Gain hands-on experience of working with different Linux projects with help of practical examples
        \item Learn how to develop your own programs for Linux
    \end{itemize}
    \item {\sf About Author.} {\sc Jack-Benny Persson} is a consultant \& author based in Sweden. He has written several books about Linux \& programming. His passion for Linux \& other Unix-like systems started as a hobby $> 20$ years ago. Since then, he has spent most of his spare time reading about Linux, tinkering with Linux servers, \& writing about Linux administration. Today he has his own IT \& media company in Sweden that focuses in Linux. {\sc Jack-Benny} holds an Advanced Higher Vocational Education Diploma as a Linux system specialist. He has also studied electronics, networking, \& security.
    \item {\sf Preface.} Linux system programming is all about developing system programs for Linux OS. Linux is world's most popular open-source OS \& runs on everything from big servers to small Internet of Things (IoT) devices. Knowing how to write system programs for Linux will enable you to extend OS \& connect it with other programs \& systems.
    
    -- Lập trình hệ thống Linux là tất cả về việc phát triển các chương trình hệ thống cho HĐH Linux. Linux là HĐH nguồn mở phổ biến nhất thế giới \& chạy trên mọi thứ từ máy chủ lớn đến các thiết bị Internet vạn vật (IoT) nhỏ. Biết cách viết chương trình hệ thống cho Linux sẽ cho phép bạn mở rộng HĐH \& kết nối nó với các chương trình \& hệ thống khác.
    
    Start by learning how to make our programs easy to script \& easy to interact with other programs. When write system programs for Linux, should always strive to make them small \& do 1 thing only -- \& do it well. This is 1 of key concepts in Linux: to create small programs that can exchange data with each other in simple ways.
    
    -- Bắt đầu bằng cách học cách làm cho chương trình của chúng ta dễ viết kịch bản \& dễ tương tác với các chương trình khác. Khi viết chương trình hệ thống cho Linux, hãy luôn cố gắng làm cho chúng nhỏ \& chỉ làm 1 việc -- \& làm tốt. Đây là 1 trong những khái niệm chính trong Linux: tạo các chương trình nhỏ có thể trao đổi dữ liệu với nhau theo những cách đơn giản.
    
    Take a deep dive into C \& look at how compiler works, what linker does, how to write Makefiles, \& much more.
    
    -- Tìm hiểu sâu hơn về C \& xem trình biên dịch hoạt động như thế nào, trình liên kết thực hiện chức năng gì, cách viết Makefile, \& nhiều hơn nữa.
    
    Learn all about forking \& daemons. Also create our own daemon. Then put our daemon under {\tt systemd}'s control. This will enable us to start, stop, \& restart daemon using built-in Linux tools.
    
    -- Tìm hiểu tất cả về forking \& daemon. Cũng như tạo daemon của riêng chúng ta. Sau đó, đặt daemon của chúng ta dưới sự kiểm soát của {\tt systemd}. Điều này sẽ cho phép chúng ta khởi động, dừng, \& khởi động lại daemon bằng các công cụ Linux tích hợp.
    
    Learn how to make our processes exchange information using different kinds of {\it Inter-Process Communication (IPC)}. Also take a look at how to write threaded programs.
    
    -- Tìm hiểu cách thực hiện các quy trình trao đổi thông tin bằng các loại Giao tiếp giữa các quy trình (IPC) khác nhau. Ngoài ra, hãy xem cách viết các chương trình có luồng.
    
    At end of this book, cover how to debug our programs using {\it GNU Debugger (GDB)} \& Valgrind. By end of this book, able to write a wide variety of system programs for Linux -- everything from filters to daemons.
    
    -- Vào cuối cuốn sách này, sẽ trình bày cách gỡ lỗi chương trình của chúng tôi bằng {\it GNU Debugger (GDB)} \& Valgrind. Vào cuối cuốn sách này, có thể viết nhiều chương trình hệ thống khác nhau cho Linux -- mọi thứ từ bộ lọc đến daemon.
    \begin{itemize}
        \item {\sf Who this book is for.} This book is intended for anyone who wants to develop system programs for Linux \& wants to have a deep understanding of Linux system. Anyone facing any issues related to a particular part of Linux system programming \& looking for some specific recipes or solutions can take advantage of this book.
        
        -- {\sf Cuốn sách này dành cho ai.} Cuốn sách này dành cho bất kỳ ai muốn phát triển chương trình hệ thống cho Linux \& muốn hiểu sâu về hệ thống Linux. Bất kỳ ai gặp phải bất kỳ vấn đề nào liên quan đến một phần cụ thể của lập trình hệ thống Linux \& đang tìm kiếm một số công thức hoặc giải pháp cụ thể đều có thể tận dụng cuốn sách này.
        \item {\sf What this book covers.} p. 2+++
        \item {\sf To get most out of this book.} To get most out of this book, need a basic understanding of Linux, some basic commands, be familiar with moving around filesystem, \& installing new programs. It would help if you also have a basic understanding of programming, preferably C language.
        
        -- Để tận dụng tối đa cuốn sách này, bạn cần có hiểu biết cơ bản về Linux, một số lệnh cơ bản, quen thuộc với việc di chuyển hệ thống tệp, \& cài đặt chương trình mới. Sẽ hữu ích nếu bạn cũng có hiểu biết cơ bản về lập trình, tốt nhất là ngôn ngữ C.
        
        Will need a Linux computer with root access -- either via {\tt su} or {\tt sudo} -- to complete all recipes. Also need to install GCC compiler, Make tool, GDB, Valgrind, \& some others smaller tools. Particular Linux distribution doesn't matter that much. There are installation instructions in book for these programs for Debian, Ubuntu, CentOS, Fedora, \& Red Hat.
        
        -- Sẽ cần một máy tính Linux có quyền truy cập root -- thông qua {\tt su} hoặc {\tt sudo} -- để hoàn thành tất cả các công thức. Cũng cần cài đặt trình biên dịch GCC, công cụ Make, GDB, Valgrind, \& một số công cụ nhỏ hơn khác. Bản phân phối Linux cụ thể không quan trọng lắm. Có hướng dẫn cài đặt trong sách cho các chương trình này dành cho Debian, Ubuntu, CentOS, Fedora, \& Red Hat.
        
        Can download example code files for this book from Github at \url{https://github.com/PacktPublishing/Linux-System-Programming-Techniques}.
        \item {\sf Conventions used.} There are a number of text conventions used throughout this book. {\tt Code in text}: Indicates code words in text, directories, filenames, file extensions, pathnames, dummy URLs, user input, \& so on, e.g., Copy {\tt libprime.so.1} to {\tt/usr/local/lib}.'' Any command-line input or output is written as follows:
        \begin{verbatim}
$> mkdir cube
$> cd cube
        \end{verbatim}
        In numbered listings, command-line input is set in bold. \verb|$>| characters indicate prompt \& aren't sth you should write, an example of a numbered listing:
        \begin{verbatim}
$> ./a.out
Hello, world!
        \end{verbatim}
        Long command lines that don't fit on a single line are broken up using \verb|\| character. This is same character as you use to break along lines in Linux shell. Line under it has a {\tt>} character to indicate: line is a continuation of prev line. {\tt>} character is not sth you should write; Linux shell will automatically put this character on a new line where last line was broken up with a \verb|\| character, e.g.:
        \begin{verbatim}
$> ./exist.sh /asdf &> /dev/null; \
> if [ $? -eq 3 ]; then echo "That doesn't exist"; fi
That doesn't exist
        \end{verbatim}
    \end{itemize}
    \item {\sf1. Getting Necessary Tools \& Writing 1st Linux Programs.}
    \item {\sf2. Making Programs Easy to Script.}
    \item {\sf3. Diving Deep into C in Linux.} Time to take an in-depth look at C programming in Linux. Learn more about compiler, 4 stages from source code to binary program, how to use Make tool, \& differences between system calls \& a standard library functions. Also take a look at some essential header files when it comes to Linux, \& look at some C \& Portable Operating System Interface (POSIX) standards. C is tightly integrated with Linux, \& mastering C will help you understand Linux.
    
    -- Đã đến lúc xem xét sâu hơn về lập trình C trong Linux. Tìm hiểu thêm về trình biên dịch, 4 giai đoạn từ mã nguồn đến chương trình nhị phân, cách sử dụng công cụ Make, \& sự khác biệt giữa các lệnh gọi hệ thống \& các hàm thư viện chuẩn. Ngoài ra, hãy xem một số tệp tiêu đề cần thiết khi nói đến Linux, \& xem một số tiêu chuẩn C \& Giao diện hệ điều hành di động (POSIX). C được tích hợp chặt chẽ với Linux, \& thành thạo C sẽ giúp bạn hiểu Linux.
    
    In this chap, develop both programs \& libraries for Linux. Also write both a generic Makefile \& more advanced ones for more significant projects. While doing this, also learn about different C standards, why they matter, \& how they affect your programs.
    
    -- Trong chương này, hãy phát triển cả chương trình \& thư viện cho Linux. Cũng viết cả Makefile chung \& các Makefile nâng cao hơn cho các dự án quan trọng hơn. Trong khi thực hiện việc này, hãy tìm hiểu về các tiêu chuẩn C khác nhau, lý do tại sao chúng quan trọng, \& cách chúng ảnh hưởng đến chương trình của bạn.
    
    This chapter will cover the following recipes:
    \begin{itemize}
        \item Linking against libraries using GNU Compiler Collection (GCC)
        \item Changing C standards
        \item Using system calls
        \item Understand when not to use them
        \item Getting information about Linux- \& Unix-specific header files
        \item Defining feature test macros
        \item Looking at 4 stages of compilation
        \item Compiling with Make
        \item Writing a generic Makefile with GCC options
        \item Writing a simple Makefile
        \item Writing a more advanced Makefile
    \end{itemize}
    \item {\sf4. Handling Errors in Programs.}
    \item {\sf5. Working with Filo I/O \& Filesystem Operations.}
    \item {\sf6. Spawning Processes \& Using Job Control.}
    \item {\sf7. Using {\tt systemd} to Handle Your Daemons.}
    \item {\sf8. Creating Shared Libraries.}
    \item {\sf9. Terminal I/O \& Changing Terminal Behavior.}
    \item {\sf10. Using Different Kinds of IPC.}
    \item {\sf11. Using Threads in Your Programs.}
    \item {\sf12. Debugging Your Programs.}
\end{itemize}

%------------------------------------------------------------------------------%

\section{Miscellaneous}

%------------------------------------------------------------------------------%

\printbibliography[heading=bibintoc]
    
\end{document}