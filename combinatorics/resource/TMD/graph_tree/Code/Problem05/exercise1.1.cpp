#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <string>
#include <set>
#include <utility> // For std::pair
#include <algorithm>

// A type alias for graph representation for better readability.
// We use an adjacency list, where each index represents a node,
// and the vector at that index stores its 0-indexed neighbors.
using GraphAdjList = std::vector<std::vector<int>>;

/**
 * @brief Reads an undirected graph from a file in DIMACS edge format.
 *
 * This function parses a DIMACS file, adhering to its structure:
 * - Ignores comment lines starting with 'c'.
 * - Reads the problem line 'p edge n m' to determine graph size.
 * - Parses edge lines 'e i j', converting 1-based vertex numbers to 0-based indices.
 * - Since the graph is undirected, it adds an edge for both (u, v) and (v, u).
 *
 * @param file_path The path to the DIMACS file.
 * @return The graph represented as an adjacency list.
 */
GraphAdjList read_dimacs_cpp(const std::string& file_path) {
    std::ifstream file(file_path);
    if (!file.is_open()) {
        std::cerr << "Error: Could not open file " << file_path << std::endl;
        return {};
    }

    std::string line;
    GraphAdjList graph;
    int num_vertices = 0;

    while (std::getline(file, line)) {
        // Use stringstream for easy parsing of each line
        std::stringstream ss(line);
        char type;
        
        // Peek at the first character without consuming it
        if (!(ss >> type)) {
            continue; // Skip empty lines
        }

        if (type == 'c') {
            // Comment line, ignore.
            continue;
        } else if (type == 'p') {
            // Problem definition line: "p edge n m"
            std::string format;
            int num_edges;
            ss >> format >> num_vertices >> num_edges;
            // Resize the graph to hold 'num_vertices' nodes.
            graph.assign(num_vertices, std::vector<int>());
        } else if (type == 'e') {
            // Edge descriptor line: "e i j"
            int u_one_based, v_one_based;
            ss >> u_one_based >> v_one_based;
            
            // Convert from 1-based (DIMACS standard) to 0-based (vector index).
            int u = u_one_based - 1;
            int v = v_one_based - 1;

            if (u >= 0 && u < num_vertices && v >= 0 && v < num_vertices) {
                // Add the undirected edge
                graph[u].push_back(v);
                graph[v].push_back(u);
            }
        }
    }
    return graph;
}

/**
 * @brief Writes a graph to a file in DIMACS edge format.
 *
 * This function takes an internal graph representation (adjacency list) and
 * writes it to a specified file.
 * - It first determines the number of vertices and edges. To avoid double-counting
 *   edges in an undirected graph, it uses a set of canonical edges (u, v) where u < v.
 * - It writes the problem line 'p edge n m'.
 * - It iterates through the canonical edges and writes them as 'e i j', converting
 *   0-based indices back to 1-based vertex numbers.
 *
 * @param graph The graph to write, represented as an adjacency list.
 * @param file_path The path of the output file.
 */
void write_dimacs_cpp(const GraphAdjList& graph, const std::string& file_path) {
    std::ofstream file(file_path);
     if (!file.is_open()) {
        std::cerr << "Error: Could not open file for writing: " << file_path << std::endl;
        return;
    }

    int num_vertices = graph.size();
    // Use a set of pairs to store canonical edges (u, v) with u < v to avoid duplicates.
    std::set<std::pair<int, int>> edge_set;

    for (int u = 0; u < num_vertices; ++u) {
        for (int v : graph[u]) {
            if (u < v) { // Ensure we only add each edge once
                edge_set.insert({u, v});
            }
        }
    }
    int num_edges = edge_set.size();

    // Write header and problem definition line
    file << "c This file was generated by the DIMACS writer (C++)\n";
    file << "c Graph has " << num_vertices << " vertices and " << num_edges << " edges.\n";
    file << "p edge " << num_vertices << " " << num_edges << "\n";

    // Write edge descriptor lines
    for (const auto& edge : edge_set) {
        // Convert from 0-based index back to 1-based vertex number for the file.
        file << "e " << edge.first + 1 << " " << edge.second + 1 << "\n";
    }
}

/**
 * @brief Helper function to print the graph for verification.
 */
void print_graph(const GraphAdjList& graph) {
    for (int i = 0; i < graph.size(); ++i) {
        std::cout << "  Node " << i << " -> { ";
        for (int neighbor : graph[i]) {
            std::cout << neighbor << " ";
        }
        std::cout << "}\n";
    }
}


// =================================================================================
// MAIN FUNCTION - DEMONSTRATION FOR EXERCISE 1.1
// =================================================================================
int main() {
    const std::string input_filename = "sample.dimacs";
    const std::string output_filename = "output.dimacs";

    // --- 1. Create a sample DIMACS file programmatically for the example ---
    std::cout << "--> Creating a sample DIMACS file named '" << input_filename << "'..." << std::endl;
    std::ofstream sample_file(input_filename);
    sample_file << "c This is a sample graph for a square with a diagonal\n";
    sample_file << "p edge 4 5\n";
    sample_file << "e 1 2\n"; // Edges of the square
    sample_file << "e 2 3\n";
    sample_file << "e 3 4\n";
    sample_file << "e 4 1\n";
    sample_file << "e 1 3\n"; // The diagonal
    sample_file.close();
    std::cout << "--> Sample file created.\n" << std::endl;

    // --- 2. Read the DIMACS file ---
    std::cout << "--> Reading graph from '" << input_filename << "'..." << std::endl;
    GraphAdjList my_graph = read_dimacs_cpp(input_filename);
    std::cout << "--> Graph read successfully. Internal representation:" << std::endl;
    print_graph(my_graph);

    // --- 3. Write the graph to a new DIMACS file ---
    std::cout << "\n--> Writing internal graph representation to '" << output_filename << "'..." << std::endl;
    write_dimacs_cpp(my_graph, output_filename);
    std::cout << "--> Graph written successfully." << std::endl;
    std::cout << "(You can now check the contents of '" << output_filename << "')" << std::endl;

    return 0;
}