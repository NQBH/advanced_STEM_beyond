\documentclass{article}
\usepackage[backend=biber,natbib=true,style=alphabetic,maxbibnames=50]{biblatex}
\addbibresource{/home/nqbh/reference/bib.bib}
\usepackage[utf8]{vietnam}
\usepackage{tocloft}
\renewcommand{\cftsecleader}{\cftdotfill{\cftdotsep}}
\usepackage[colorlinks=true,linkcolor=blue,urlcolor=red,citecolor=magenta]{hyperref}
\usepackage{amsmath,amssymb,amsthm,enumitem,fancyvrb,float,graphicx,mathtools,tikz}
\usetikzlibrary{angles,calc,intersections,matrix,patterns,quotes,shadings}
\allowdisplaybreaks
\newtheorem{assumption}{Assumption}
\newtheorem{baitoan}{}
\newtheorem{cauhoi}{Câu hỏi}
\newtheorem{conjecture}{Conjecture}
\newtheorem{corollary}{Corollary}
\newtheorem{dangtoan}{Dạng toán}
\newtheorem{definition}{Definition}
\newtheorem{dinhly}{Định lý}
\newtheorem{dinhnghia}{Định nghĩa}
\newtheorem{example}{Example}
\newtheorem{ghichu}{Ghi chú}
\newtheorem{hequa}{Hệ quả}
\newtheorem{hypothesis}{Hypothesis}
\newtheorem{lemma}{Lemma}
\newtheorem{luuy}{Lưu ý}
\newtheorem{nhanxet}{Nhận xét}
\newtheorem{notation}{Notation}
\newtheorem{note}{Note}
\newtheorem{principle}{Principle}
\newtheorem{problem}{Problem}
\newtheorem{proposition}{Proposition}
\newtheorem{question}{Question}
\newtheorem{remark}{Remark}
\newtheorem{theorem}{Theorem}
\newtheorem{vidu}{Ví dụ}
\usepackage[left=1cm,right=1cm,top=5mm,bottom=5mm,footskip=4mm]{geometry}
\def\labelitemii{$\circ$}
\DeclareRobustCommand{\divby}{%
	\mathrel{\vbox{\baselineskip.65ex\lineskiplimit0pt\hbox{.}\hbox{.}\hbox{.}}}%
}
\setlist[itemize]{leftmargin=*}
\setlist[enumerate]{leftmargin=*}

\title{Data Structures {\it\&} Algorithms -- Cấu Trúc Dữ Liệu {\it\&} Giải Thuật}
\author{Nguyễn Quản Bá Hồng\footnote{A scientist- {\it\&} creative artist wannabe, a mathematics {\it\&} computer science lecturer of Department of Artificial Intelligence {\it\&} Data Science (AIDS), School of Technology (SOT), UMT Trường Đại học Quản lý {\it\&} Công nghệ TP.HCM, Hồ Chí Minh City, Việt Nam.\\E-mail: {\sf nguyenquanbahong@gmail.com} {\it\&} {\sf hong.nguyenquanba@umt.edu.vn}. Website: \url{https://nqbh.github.io/}. GitHub: \url{https://github.com/NQBH}.}}
\date{\today}

\begin{document}
\maketitle
\begin{abstract}
	This text is a part of the series {\it Some Topics in Advanced STEM \& Beyond}:
	
	{\sc url}: \url{https://nqbh.github.io/advanced_STEM/}.
	
	Latest version:
	\begin{itemize}
		\item {\it Data Structures \& Algorithms -- Cấu Trúc Dữ Liệu \& Giải Thuật}.
		
		PDF: {\sc url}: \url{https://github.com/NQBH/advanced_STEM_beyond/blob/main/data_structure_algorithm/lecture/NQBH_data_structure_algorithm_lecture.pdf}.
		
		\TeX: {\sc url}: \url{https://github.com/NQBH/advanced_STEM_beyond/blob/main/data_structure_algorithm/lecture/NQBH_data_structure_algorithm_lecture.tex}.
		\item {\it }.
		
		PDF: {\sc url}: \url{.pdf}.
		
		\TeX: {\sc url}: \url{.tex}.
	\end{itemize}
\end{abstract}
\tableofcontents

%------------------------------------------------------------------------------%

\section{Array in C++ STL}

%------------------------------------------------------------------------------%

\section{Vector in C++ STL}
\textbf{\textsf{Resources -- Tài nguyên.}}
\begin{enumerate}
	\item \href{https://www.geeksforgeeks.org/vector-in-cpp-stl/}{Geeks4Geeks{\tt/}vector in C++ STL}
\end{enumerate}

\begin{definition}
	{\rm C++ vector} is a dynamic array that stores collection of elements of same type in contiguous memory. It has the ability to resize itself automatically when an element is inserted or deleted.
	
	-- {\rm C++ vector} là một mảng động lưu trữ tập hợp các phần tử cùng loại trong bộ nhớ liền kề. Nó có khả năng tự động thay đổi kích thước khi một phần tử được chèn vào hoặc xóa.
\end{definition}

%------------------------------------------------------------------------------%

\subsection{Create vectors -- Tạo vectors}
\textbf{\textsf{Resources -- Tài nguyên.}}
\begin{enumerate}
	\item \href{https://www.geeksforgeeks.org/initialize-a-vector-in-cpp-different-ways/}{Geeks4Geeks{\tt/}8 ways to initialize vector in C++}.
\end{enumerate}
Before creating a vector, we must know that a vector is defined as the {\tt std::vector} class template in the {\tt<vector>} header file.
\begin{verbatim}
vector<T> v;
\end{verbatim}
where {\tt T} is the type of elements \& {\tt v} is the name assigned to the vector.

Now we are creating an instance of {\tt std::vector} class. This requires us to provide the type of elements as template parameter.
\begin{Verbatim}[numbers=left,xleftmargin=5mm]
#include <bits/stdc++.h>
using namespace std;

int main() {
    // Creating an empty vector
    vector<int> v1;	
    return 0;
}
\end{Verbatim}
We can also provide the values to be stored in the vector inside {\tt\{\}} curly braces. This process is called {\it initialization}.
\begin{Verbatim}[numbers=left,xleftmargin=5mm]
#include <bits/stdc++.h>
using namespace std;
void printVector(vector<int>& v) {
    for (auto x: v) {
        cout << x << " ";
    }
    cout << endl;
}

int main() {	
    // Creating a vector of 5 elements from initializer list
    vector<int> v1 = {1, 4, 2, 3, 5};
	
    // Creating a vector of 5 elements with default value
	vector<int> v2(5, 9);
	
    printVector(v1);
    printVector(v2);
	return 0;
}
\end{Verbatim}
Output:
\begin{verbatim}
1 4 2 3 5 
9 9 9 9 9
\end{verbatim}
Statement \verb|vector<int> v1 = {1, 4, 2, 3, 5}| initializes a vector with given values. Statement \verb|vector<int> v2(5, 9)| creates a vector of size 5 where each element initialized to 9.

\begin{remark}
	Statement \verb|vector<int> v|= $\{v_1,v_2,\ldots,v_n\}$ initializes a vector with given values. Statement \verb|vector<int> v(n, a)| creates a vector of size $n\in\mathbb{N}^\star$ where each element initialized to $a\in\mathbb{Z}$.
\end{remark}
Initializing a vector means assigning some initial values to the {\tt std::vector} elements. Here are 8 different ways to initialize a vector in C++.

%------------------------------------------------------------------------------%

\subsubsection{Initialize vector in C++ by using initializer list -- Sử dụng danh sách các giá trị khởi tạo}
We can initialize a vector with the list of values enclosed in curly braces {\tt\{\}} known as \href{https://www.geeksforgeeks.org/std-initializer_list-in-cpp-11/}{initializer list}. The value of the list will be assigned sequentially i.e. 1st value will be assigned to the 1st element of vector, 2nd value to 2nd element, $\ldots$, $n$th value to $n$th element. Syntax:
\begin{verbatim}
vector<type> v = {val1, val2, val3, ...};
\end{verbatim}
where {\tt val1, val2, val3}, $\ldots$ are the initial values, e.g.:
\begin{Verbatim}[numbers=left,xleftmargin=5mm]
// C++ Program to initializ std::vector with initializer list
#include <bits/stdc++.h>
using namespace std;

int main() {
    // Initializing std::vector with list of multiple values
    vector<int> v = {11, 23, 45, 89};
	
    for (auto i : v)
        cout << i << " ";
    return 0;
}
\end{Verbatim}
Output: {\tt 11 23 45 89}.
\begin{note}
	{\tt for (auto i : v)} means for each element of the type that will be determined automatically in the vector {\tt v}.
\end{note}

%------------------------------------------------------------------------------%

\subsubsection{Initialize vector in C++ 1 by 1 initialization}
Vector can be initialized by pushing value 1 by 1. In this method, an empty vector is created, \& elements are added to it 1 by 1 using the \href{https://www.geeksforgeeks.org/vectorpush_back-vectorpop_back-c-stl/}{\tt vector::push\_back()} method. This method is mostly used to initialize vector after declaration. Syntax:
\begin{verbatim}
v.push_back(val);
\end{verbatim}
where {\tt val} is the value which we have to insert, e.g.:
\begin{Verbatim}[numbers=left,xleftmargin=5mm]
// C++ Program to initialize std::vector by pushing values 1 by 1
#include <bits/stdc++.h>
using namespace std;

int main() {
    vector<int> v;
	
    // Pushing Value one by one
    v.push_back(11);
    v.push_back(23);
    v.push_back(45);
    v.push_back(89);
	
    for (auto i : v)
        cout << i << " ";
    return 0;
}
\end{Verbatim}
Output: {\tt11 23 45 89}.

%------------------------------------------------------------------------------%

\subsection{Initialize vector in C++ by with a single value}
We can initialize all the elements of the vector to a single value. We create a vector of a specified size \& initialize all elements to the same value using vector constructor. Syntax:
\begin{verbatim}
vector<type> v(n, val);
\end{verbatim}
where $n\in\mathbb{N}$ is the size \& {\tt val} is the initial value, e.g.:
\begin{Verbatim}[numbers=left,xleftmargin=5mm]
// C++ Program to initializ the std::vector with specific value
#include <bits/stdc++.h>
using namespace std;

int main() {
    // Initializing all the elements of a vector using a single value
    vector<int> v(5, 11);
	
    for (auto i : v)
        cout << i << " ";
    return 0;
}
\end{Verbatim}
Output: {\tt11 11 11 11 11}.

%------------------------------------------------------------------------------%

\subsubsection{Initialize vector in C++ from an array}
We can also initialize a vector using plain old static arrays using vector constructor. This works by copying all the elements of the array to the newly created vector. Syntax:
\begin{verbatim}
vector<type> v(arr, arra + n);
\end{verbatim}
where {\tt arr} is the array name \& $n\in\mathbb{N}$ is the size of the array, e.g.:
\begin{Verbatim}[numbers=left,xleftmargin=5mm]
// C++ Program to initializ the std::vector from another array
#include <bits/stdc++.h>
using namespace std;

int main() {
    int arr[] = {11, 23, 45, 89};
    int n = sizeof(arr) / sizeof(arr[0]);
	
    // initialize the std::vector v by arr
    vector<int> v = {arr, arr + n};
	
    for (auto i : v)
        cout << i << " ";
    return 0;
}
\end{Verbatim}
Output: {\tt11 23 45 89}.

%------------------------------------------------------------------------------%

\subsubsection{Initialize vector in C++ from another vector}
We can also initialize a newly created vector from an already created vector if they are of same type. Syntax:
\begin{verbatim}
vector<type> v2(v1.begin(), v1.end());
\end{verbatim}
where {\tt v1} is the already existing vector, e.g.:
\begin{Verbatim}[numbers=left,xleftmargin=5mm]
// C++ Program to initializ the std::vector from another vector
#include <bits/stdc++.h>
using namespace std;

int main() {
    vector<int> v1 = {11, 23, 45, 89};
	
    // initialize the vector v2 from vector v1
    vector<int> v2(v1.begin(), v1.end());
	
    for (auto i : v2)
        cout << i << " ";
    return 0;
}
\end{Verbatim}
Output: {\tt11 23 45 89}.

%------------------------------------------------------------------------------%

\subsubsection{Initialize vector in C++ by from any STL container}
Vectors are flexible containers that can be initialized by any other already existing containers e.g. set, multiset, map, etc. if they are of same type. Syntax:
\begin{verbatim}
vector<type> v(first, last);
\end{verbatim}
where {\tt first, last} are the iterator to the 1st element \& the element just after the last element in the range of STL container.

%------------------------------------------------------------------------------%

\subsubsection{Initialize vector in C++ by using {\tt std::fill()} function}
We can also use the \href{https://www.geeksforgeeks.org/fill-and-fill_n-functions-in-c-stl/}{\tt std::fill} function to initialize the whole or a part of a vector to the same value. Syntax:
\begin{verbatim}
fill(first, last, val);
\end{verbatim}
where {\tt first, last} are the iterator to the 1st element \& the element just after the last element in the range of STL container \& {\tt val} is the value to be initialized with, e.g.:
\begin{Verbatim}[numbers=left,xleftmargin=5mm]
// C++ Program to initialize the std::vector using std::fill() method
#include <bits/stdc++.h>
using namespace std;

int main() {
    vector<int> v(5);
	
    // initialize vector v with 11
    fill(v.begin(), v.end(), 11);
	
    for (auto i : v)
        cout << i << " ";
    return 0;
}
\end{Verbatim}
Output: {\tt11 11 11 11 11}.

%------------------------------------------------------------------------------%

\subsubsection{Initialize vector in C++ by using {\tt std::iota()} function}
The \href{https://www.geeksforgeeks.org/std-iota-in-cpp/}{\tt std::iota()} function from the {\tt<numeric>} library allows us to initialize a vector with consecutive values starting from the given value. Syntax:
\begin{verbatim}
std::iota(first, last, val);
\end{verbatim}
where {\tt first, last} are the iterator to the 1st element \& the element just after the last element in the range of the vector \& {\tt val} refers to the starting value, e.g.:
\begin{Verbatim}[numbers=left,xleftmargin=5mm]
// C++ Program to initializ the std::vector using std::iota()
#include <bits/stdc++.h>
using namespace std;

int main() {
    vector<int> v(5);
	
	// using std::iota() to initialize vector v with 11
    iota(v.begin(), v.end(), 11);
	
    for (auto i : v)
        cout << i << " ";
    return 0;
}
\end{Verbatim}
Output: {\tt11 12 13 14 15}.

%------------------------------------------------------------------------------%

\subsection{Insert elements -- Chèn phần tử}
An element can be inserted into a vector using \href{https://www.geeksforgeeks.org/vector-insert-function-in-cpp-stl}{vector insert()} method which takes linear time. But for the insertion at the end, the \href{https://www.geeksforgeeks.org/vectorpush_back-vectorpop_back-c-stl/}{vector {\tt push\_back()}} method can be used, which is much faster, taking only constant time.
\begin{Verbatim}[numbers=left,xleftmargin=5mm]
#include <bits/stdc++.h>
using namespace std;

int main() {
    vector<char> v = {'a', 'f', 'd'};
	
    // Inserting 'z' at the back
    v.push_back('z');
	
    // Inserting 'c' at index 1
    v.insert(v.begin() + 1, 'c');
	
    for (int i = 0; i < v.size(); i++)
        cout << v[i] << " ";
    return 0;
}
\end{Verbatim}
Output: {\tt a c f d z}.

%------------------------------------------------------------------------------%

\subsection{Access or update elements -- Tiếp cận hoặc cập nhật các phần tử}
Just like arrays, vector elements can be accessed using their index inside the \href{https://www.geeksforgeeks.org/vectoroperator-vectoroperator-c-stl/}{[] subscript operator}. While accessing elements, we can also update the value of that index using \href{https://www.geeksforgeeks.org/cpp-assignment-operators/}{assignment operator $=$}. The {\tt[] subscript operator} doesn't check whether the given index exists in the vector or not. So, there is another member method \href{https://www.geeksforgeeks.org/vector-at-in-cpp-stl/}{vector al()} for safely accessing or update elements.
\begin{Verbatim}[numbers=left,xleftmargin=5mm]
#include <bits/stdc++.h>
using namespace std;

int main() {
    vector<char> v = {'a', 'c', 'f', 'd', 'z'};
	
	// accessing & printing values
    cout << v[3] << endl;
    cout << v.at(2) << endl;
	
    // updating values using indexes 3 & 2
    v[3] = 'D';
    v.at(2) = 'F';
	
    cout << v[3] << endl;
    cout << v.at(2);
    return 0;
}
\end{Verbatim}

%------------------------------------------------------------------------------%

\subsection{Find vector size -- Tìm cỡ{\tt/}kích thước của vector}
1 of the common problems with arrays was to keep a separate variable to store the size information. Vector provides the solution to this problem by providing \href{https://www.geeksforgeeks.org/vector-size-in-cpp-stl/}{size()} method.
\begin{Verbatim}[numbers=left,xleftmargin=5mm]
#include <bits/stdc++.h>
using namespace std;

int main() {
    vector<char> v = {'a', 'c', 'f', 'd', 'z'};
	
    // finding size
    cout << v.size();
    return 0;
}
\end{Verbatim}
Output: {\tt5}.

%------------------------------------------------------------------------------%

\subsection{Traverse vector -- Duyệt vector}
Vector in C++ can be traversed using indexes in a loop. The indexes start from 0 \& go up to a vector size $- 1$. To iterate through this range, we can use a loop \& determine the size of the vector using the \href{https://www.geeksforgeeks.org/vectorempty-vectorsize-c-stl/}{vector size()} method.
\begin{Verbatim}[numbers=left,xleftmargin=5mm]
#include <bits/stdc++.h>
using namespace std;

int main() {
    vector<char> v = {'a', 'c', 'f', 'd', 'z'};
	
    // traversing vector using range based for loop
    for (int i = 0; i < v.size(); i++)
        cout << v[i] << " ";
    return 0;
}
\end{Verbatim}
Output: {\tt a c f d z}.

We can also use a range-based loop for simple traversal.

%------------------------------------------------------------------------------%

\subsection{Delete elements -- Xóa phần tử}
An element can be deleted from a vector using \href{https://www.geeksforgeeks.org/vector-erase-and-clear-in-cpp/}{vector erase()} but this method needs iterator to the element to be deleted. If only the value of the element is known, then {\tt find()} function is used to find the position of this element.

For the deletion at the end, the \href{https://www.geeksforgeeks.org/vector-pop-back-in-cpp-stl/}{vector {\tt pop\_back()}} method can be used, \& it is much faster, taking only constant time.
\begin{Verbatim}[numbers=left,xleftmargin=5mm]
#include <bits/stdc++.h>
using namespace std;

int main() {
    vector<char> v = {'a', 'c', 'f', 'd', 'z'};
	
    // deleting last element 'z'
    v.pop_back();
	
    // deleting element 'f'
    v.erase(find(v.begin(), v.end(), 'f'));
	
    for (int i = 0; i < v.size(); i++) {
        cout << v[i] << " ";
    }
    return 0;
}
\end{Verbatim}
Output:
\begin{verbatim}
a c f d 
a c d
\end{verbatim}

%------------------------------------------------------------------------------%

\subsection{Other operations -- Các thao tác khác}
Vector is 1 of the most frequently used containers in C++. It is used in many situations for different purposes. The following examples aim to help you master vector operations beyond the basics.

%------------------------------------------------------------------------------%

\section{2D Vector in C++}
\textbf{\textsf{Resources -- Tài nguyên.}}
\begin{enumerate}
	\item \href{https://www.geeksforgeeks.org/2d-vector-in-cpp-with-user-defined-size/}{Geeks4Geeks{\tt/}2D vector in C++}.
\end{enumerate}
A 2D vector is a vector of the vectors, i.e., each element is a vector in itself. It can be visualized as a matrix where each inner vector represents a row, \& the number of rows represents a row, \& the number of rows represents the maximum columns. A 2D vector is dynamically resizable in both dimensions. Syntax:
\begin{verbatim}
vector<vector<data_type>> v;
\end{verbatim}
where \verb|data_type| is the type of elements \& {\tt V} is the name assigned to the 2D vector.

%------------------------------------------------------------------------------%

\subsection{Creating a 2D vector -- Tạo 1 vector 2D}
In C++, we can create{\tt/}declare a 2D vector by using the vector container defined in the C++ Standard Template Library (STL). We can simply create a 2D vector by creating a vector with the vector data type.

Just like vectors, a 2D vector can be created \& initialized in multiple ways:
\begin{enumerate}
	\item {\bf Default.} An empty 2D vector can be created using the declaration:
	\begin{verbatim}
vector<vector<data_type>> v;
	\end{verbatim}
	It can be filled in later on in the program.
	\item {\bf With user defined size \& default value.} A vector of a specific size can also be declared \& initialized to the given value as default value.
	\begin{verbatim}
vector<vector<T>> v(n, vector<T>(m, value));
	\end{verbatim}
	where $n\in\mathbb{N}^\star$ is the number of rows, $m\in\mathbb{N}^\star$ is the number of columns, {\tt val} is the new default value for all of the elements of the vector.
	\item {\bf Using initializer list.} Vector can also be initialized using a list of values enclosed in {\tt\{\}} braces separated by comma. The list must be nested according to the 2 dimensions as it helps in determining the row size \& column size.
	\begin{verbatim}
vector<vector<T>> v = {{x1, x2, ...}, {y1, y2, ...}, ...};
	\end{verbatim}
	E.g.:
	\begin{Verbatim}[numbers=left,xleftmargin=5mm]
#include <bits/stdc++.h>
using namespace std;

void printV(vector<vector<int>>& v) {
    for (auto i: v) {
        for (auto j: i) {
            cout << j << " ";
        }
        cout << endl;
    }
    cout << endl;
}

int main() {
    // an empty 2D vector
    vector<vector<int>> v1;
	
    // 2D vector with initial size and value
	vector<vector<int>> v2(2, vector<int>(3, 11));
	
    // a 2D vector initialized with initializer list
    vector<vector<int>> v3 = {
        {1, 2, 3},
        {4, 5, 6},
    };
	
    printV(v1);
    printV(v2);
    printV(v3);
    return 0;
}
	\end{Verbatim}
\end{enumerate}
Output:
\begin{verbatim}
11 11 11
11 11 11

1 2 3
4 5 6
\end{verbatim}

%------------------------------------------------------------------------------%

Basic operations of 2D vector:
\begin{enumerate}
	\item Inserting elements in a 2D vector
	\item Accessing \& updating elements
	\item Deleting elements
	\item Traversing the vector
\end{enumerate}

%------------------------------------------------------------------------------%

\subsection{Inserting elements in a 2D vector}
In 2D vectors, there are 2 types of insertion:
\begin{enumerate}
	\item Insert a new row.
	\item Insert a value in an existing row.
\end{enumerate}
These can be inserted at any given position using \href{https://www.geeksforgeeks.org/vector-insert-function-in-cpp-stl/}{\tt vector\_insert()} \& at the end using \href{https://www.geeksforgeeks.org/vectorpush_back-vectorpop_back-c-stl/}{\tt vector push\_back()}. As vector can dynamically grow, each row can have different size like \href{https://www.geeksforgeeks.org/jagged-array-in-java/}{Java's jagged arrays}, e.g.:
\begin{Verbatim}[numbers=left,xleftmargin=5mm]
#include <bits/stdc++.h>
using namespace std;

int main() {
    vector<vector<int>> v = {{1, 2, 3}, {4, 5, 6}};
	
    // insert a new row at the end
    v.push_back({7, 8, 9});
	
    // insert value in 2nd row at 2nd position
    v[1].insert(v[1].begin() + 1, 10);
	
    for (int i = 0; i < v.size(); i++) {
        for (int j = 0; j < v[i].size(); j++) {
            cout << v[i][j] << " ";
        }
        cout << endl;
    }
    return 0;
}
\end{Verbatim}
Output:
\begin{verbatim}
1 2 3
4 10 5 6
7 8 9
\end{verbatim}

%------------------------------------------------------------------------------%

\subsection{Accessing \& uploading elements}
As 2D vectors are organized as matrices with row \& column, we need 2 indexes to access an element: 1 for the {\it row number} $i$ \& other for the {\it column number} $j$. We can then use any access method e.g. \href{https://www.geeksforgeeks.org/vectoroperator-vectoroperator-c-stl/}{[] operator} or \href{https://www.geeksforgeeks.org/vector-at-in-cpp-stl/}{vector at()} method.

The value of the accessed element can be changed by assigning a new value using {\tt=} operator, e.g.:
\begin{Verbatim}[numbers=left,xleftmargin=5mm]
#include <bits/stdc++.h>
using namespace std;

int main() {
    vector<vector<int>> v = {{1, 2, 3}, {4, 5, 6}};
	
    // access 3rd element in 2nd row
    cout << "3rd element in 2nd row: "<< v[1][2] << endl;
	
    // access 2nd element in 1st row
    cout << "2nd element in 1st row: "<<v[0][1]<<endl;
	
    // updating the 2nd element in 1st row
    v[0][1] = 9; 
    cout << "2nd element in 1st row after updating: " <<v[0][1]<<endl;

    return 0;
}
\end{Verbatim}
Output:
\begin{verbatim}
3rd element in 2nd row: 6
2nd element in 1st row: 2
2nd element in 1st row after updating: 9
\end{verbatim}

%------------------------------------------------------------------------------%

\subsection{Deleting elements from a 2D vector}
Similar to insertion, there are 2 types of deletion in 2D vector:
\begin{enumerate}
	\item Delete a row
	\item Delete a value in an existing row.
\end{enumerate}
Elements can be deleted using \href{https://www.geeksforgeeks.org/vector-erase-and-clear-in-cpp/}{vector erase()} for a specific position or range \& using \href{https://www.geeksforgeeks.org/vectorpush_back-vectorpop_back-c-stl/}{vector pop\_back()} to remove the last element, e.g.:
\begin{Verbatim}[numbers=left,xleftmargin=5mm]
#include <bits/stdc++.h>
using namespace std;

int main() {
    vector<vector<int>> v = {{1, 2, 3}, {4, 5, 6}};
	
    // delete the 2nd row
    v.erase(v.begin() + 1);
	
    // delete 2nd element in 1st row
    v[0].erase(v[0].begin() + 1);
	
    for (int i = 0; i < v.size(); i++) {
        for (int j = 0; j < v[i].size(); j++)
            cout << v[i][j] << " ";
        cout << endl;
    }
	
    return 0;
}
\end{Verbatim}
Output: {\tt1 3}.

%------------------------------------------------------------------------------%

\subsection{Traversing 2D vectors}
Traversing a 2D vector involves iterating through rows \& columns using nested loops \& access the elements by indexes, e.g.:
\begin{Verbatim}[numbers=left,xleftmargin=5mm]
#include <bits/stdc++.h>
using namespace std;

int main() {
    vector<vector<int>> v = {{1, 2, 3}, {4, 5, 6}};
	
    // loop through rows
    for (int i = 0; i < v.size(); i++) {
        // loop through columns
        for (int j = 0; j < v[i].size(); j++)
            cout << v[i][j] << " ";
        cout << endl;
    }
	
    return 0;
}
\end{Verbatim}
Output:
\begin{verbatim}
1 2 3
4 5 6
\end{verbatim}
C++ provides more methods to traverse 2D vector.

%------------------------------------------------------------------------------%

\subsection{Finding size of 2D vector}
Finding the size of a 2D vector involves finding its row size \& column size which can be done using the {\tt vector.size()} method. The size vector used on the outer vector gives the number of rows in the 2D vector while using them on the inner vector gives the number of columns in that row (as all rows can have different number of columns). Syntax:
\begin{verbatim}
//finding the number of rows
int rows = vec.size();

//finding the number of columns
int rows = vec[0].size();
\end{verbatim}
where {\tt vec} is the name of the vector for which the size is to be determined. Since each element of a 2D vector is a vector itself we can use the {\tt size()} method on the elements {\tt vec[0]} to find the size of each row separately, e.g.:
\begin{Verbatim}[numbers=left,xleftmargin=5mm]
#include <iostream>
#include <vector>
using namespace std;

int main() {
    // creating a 2D vector
    vector<vector<int>> vec = {
        {1, 2, 3},
        {4, 5, 6},
        {7, 8, 9}
    };
	
    // finding the number of rows  (size of the outer vector)
    int rows = vec.size();
    cout << "Number of rows: " << rows << endl;
	
    // finding the number of columns (size of any inner vector first row)
    int cols = vec[0].size();
    cout << "Number of columns: " << cols << endl;
	
    return 0;
}
\end{Verbatim}
Output:
\begin{verbatim}
Number of rows: 3
Number of columns: 3
\end{verbatim}

%------------------------------------------------------------------------------%

\subsection{Common operations \& applications}
Apart from the basic operations, there are many operations that can be performed on 2D vectors.

%------------------------------------------------------------------------------%

\section{Advantages of Vector Over Array in C++}
\textbf{\textsf{Resources -- Tài nguyên.}}
\begin{enumerate}
	\item \href{https://www.geeksforgeeks.org/advantages-of-vector-over-array-in-c/}{Geeks4Geeks{\tt/}advantages of vector over array in C++}.
\end{enumerate}
In C++, both vectors \& arrays are used to store collections of elements, but vector offers significant advantages over arrays in terms of flexibility, functionality, \& ease of use. This section explores the benefits of using vectors in C++ programming.

%------------------------------------------------------------------------------%

\subsection{Dynamic resizing}
Unlike arrays, vectors can dynamically resize themselves, i.e., you don't need to know the size of the vector in advance, it can grow \& shrink according to the number of elements present in it.
\begin{Verbatim}[numbers=left,xleftmargin=5mm]
#include <bits/stdc++.h>
using namespace std;

int main() {
    vector<int> v;
	
    // initial size
    cout << v.size() << endl;
	
    // add elements dynamically
    for (int i = 1; i <= 5; ++i)
        v.push_back(i);
	
    // size after inserting elements
    cout << v.size();
    return 0;
}
\end{Verbatim}
Output:
\begin{verbatim}
0
5
\end{verbatim}

%------------------------------------------------------------------------------%

\subsection{Built-in functions \& operations}
Vectors come with a variety of member functions, e.g. \verb|push_back(), pop_back(), insert(), erase()|, \& more, which simplify many operations. Apart from that, vectors can be easily copied from one to another using assignment operator.
\begin{Verbatim}[numbers=left,xleftmargin=5mm]
#include <bits/stdc++.h>
using namespace std;

int main() {
    vector<int> v = {1, 2, 3, 4, 5};
	
    // remove the last element
    v.pop_back();
	
    // insert a new element at the beginning
    v.insert(v.begin(), 0);
	
    for (auto i : v)
        cout << i << " ";
    return 0;
}
\end{Verbatim}
Output: {\tt0 1 2 3 4}.

%------------------------------------------------------------------------------%

\subsection{Memory management}
Vectors handle memory allocation \& deallocation automatically, whereas arrays require manual allocation \& deallocation.
\begin{Verbatim}[numbers=left,xleftmargin=5mm]
#include <bits/stdc++.h>
using namespace std;

int main() {
    vector<int> v = {1, 2, 3};
	
    // no manual reallocation needed
    v.push_back(4);
	
    for (auto i : v)
        cout << i << " ";
    return 0;
}
\end{Verbatim}
Output: {\tt1 2 3 4}.

%------------------------------------------------------------------------------%

\subsection{Bounds checking}
Vector supports bounds checking in {\tt at()} method \& throw an \verb|out_of_range| exception if the index is out of bounds, offering a safer way to access elements.
\begin{Verbatim}[numbers=left,xleftmargin=5mm]
#include <bits/stdc++.h>
using namespace std;

int main() {
    vector<int> v = {1, 2, 3, 4};
	
    try {
        // attempting to access out of range index
        cout << v.at(5) << endl;	
    } catch (const out_of_range& e) {
        cout << "Exception: " << e.what() << endl;
    }
	
    return 0;
}
\end{Verbatim}
Output:
\begin{verbatim}
Exception: vector::_M_range_check: __n (which is 5) >= this->size() (which is 4)
\end{verbatim}

%------------------------------------------------------------------------------%

\subsection{Standard Template Library (STL) integration}
Vectors are fully compatible with STL algorithms like sort, find, \verb|remove_if|, making it easier to make use of inbuilt functionality of the language.
\begin{Verbatim}[numbers=left,xleftmargin=5mm]
#include <bits/stdc++.h>
using namespace std;

int main() {
    vector<int> v = {1, 4, 3, 2, 5};
	
    // sort vector
    sort(v.begin(), v.end());
	
    // reverse sorted vector
    reverse(v.begin(), v.end());
	
    for (auto i : v)
        cout << i << " ";
    return 0;
}
\end{Verbatim}
Output: {\tt5 4 3 2 1}.

%------------------------------------------------------------------------------%

\subsection{Seamless working with functions}
When arrays are passed to a function, a separate parameter for size is also passed whereas in case of passing a vector to a function, there is no such need as vector maintains variables which keeps track of size of container at all times. Also, it can be easily passed \& returned as both value \& reference.

-- Khi mảng được truyền cho một hàm, một tham số riêng cho kích thước cũng được truyền trong khi trong trường hợp truyền một vector cho một hàm, không cần thiết vì vector duy trì các biến theo dõi kích thước của container mọi lúc. Ngoài ra, nó có thể dễ dàng được truyền \& trả về dưới dạng cả giá trị \& tham chiếu.
\begin{Verbatim}[numbers=left,xleftmargin=5mm]
#include <bits/stdc++.h> 
using namespace std;

// take vector as argument as reference but return by value
vector<int> rev(vector<int>& v) {
    reverse(v.begin(), v.end());
    return v;
}

int main()  { 
    vector<int> v1 = {1, 2, 3, 4, 5};
    vector<int> v2 = rev(v1);
    
    for (auto i: v2) cout << i << " ";
    return 0; 
}
\end{Verbatim}
Output: {\tt5 4 3 2 1}.

%------------------------------------------------------------------------------%

\section{Pair in C++ STL}
\textbf{\textsf{Resources -- Tài nguyên.}}
\begin{enumerate}
	\item \href{https://www.geeksforgeeks.org/pair-in-cpp-stl/}{Geeks4Geeks{\tt/}pair in C++ STL}.
\end{enumerate}
In C++, pair is used to combine together 2 values that may be of different data types of same data types as a single unit. The 1st element is stored as a data member with name {\tt first} \& the 2nd element as {\tt second}, e.g.:
\begin{Verbatim}[numbers=left,xleftmargin=5mm]
#include <bits/stdc++.h>
using namespace std;

int main() {
    // creating a pair of int & string
    pair<int, string> p1 = {1, "Geeks"};
	
    cout << p1.first << ": " << p1.second;
    return 0;
}
\end{Verbatim}
Output: {\tt 1: Geeks}. Explanation: In this program, we created a pair {\tt p1} of type {\tt int} \& {\tt string} with values \verb|{1, "Geeks"}|.

\noindent{\bf Syntax.} The pair container is defined in {\tt<utility>} header file.
\begin{verbatim}
pair <T1, T2> p;
\end{verbatim}
where {\tt T1, T2}: data types of the 1st- \& 2nd elements, respectively, {\tt p}: name assigned to the pair.

%------------------------------------------------------------------------------%

\subsection{Declaration \& initialization -- Khai báo \& khởi tạo}
In C++, pair can be declared and initialized in multiple ways as shown below:
\begin{enumerate}
	\item {\bf Default initialization.} We can declare an empty pair using the declaration
	\begin{verbatim}
pair <T1, T2> p;
	\end{verbatim}
	\item {\bf Declaration \& initialization with values.} We can initialize a pair directly by assigning values to 1st \& 2nd.
	\begin{verbatim}
pair<T1, T2> p = {v1, v2};
	\end{verbatim}
	\item {\bf Initialization with \verb|make_pair()|.} We can use \href{https://www.geeksforgeeks.org/std-make_pair-in-cpp/}{\tt make\_pair()} method to initialize pair.
	\begin{verbatim}
pair<T1, T2> p = make_pair(v1, v2);
	\end{verbatim}
\end{enumerate}

\begin{Verbatim}[numbers=left,xleftmargin=5mm]
#include <bits/stdc++.h>
using namespace std;

int main() {
    // creating an empty pair
    pair<int, string> p1;
	
    // insert values using curly braces {}
    pair<int, string> p2 = {1, "Geeks"};
	
    // insert values using make_pair method
    pair<int, string> p3 = make_pair(2, "ForGeeks");
	
    cout << p2.first << " " << p2.second << endl;
    cout << p3.first << " " << p3.second;
    return 0;
}
\end{Verbatim}
Output:
\begin{verbatim}
1 Geeks
2 ForGeeks
\end{verbatim}
Explanation: In the above program, we created 3 pairs:
\begin{enumerate}
	\item {\tt pair<int, string> p1} creates an empty pair of type {\tt int, string}.
	\item \verb|pair<int, string> p2 = {1, "Geeks"}| creates a pair \& initializes it with the values \verb|{1, "Geeks"}| using curly braces.
	\item \verb|pair<int, string> p3 = make_pair(2, "ForGeeks")| creates a pair \& initializes it with the value \verb|{2, "ForGeeks"}| using the \verb|make_pair| method.
\end{enumerate}
All the values should match the type of the pair. Otherwise, a compiler error will be displayed.

\begin{remark}
	If a pair is not initialized, the compiler automatically assigns the 1st \& 2nd members default values according to their types.
\end{remark}
The basic operations on pairs are as follows.

%------------------------------------------------------------------------------%

\subsection{Accessing values -- Tiếp cận giá trị}
In pair, 1st \& 2nd values are stored as data members. So, we can access them by using their name with {\tt.} operator, e.g.:
\begin{Verbatim}[numbers=left,xleftmargin=5mm]
#include <bits/stdc++.h>
using namespace std;

int main() {
    pair<int, string> p = {1, "Geeks"};
	
    // accessing the elements of the pair
    cout << p.first << " " << p.second;
	return 0;
}
\end{Verbatim}
Output: {\tt1 Geeks}. Explanation: In the above program, {\tt p.first} accesses the {\tt first} values of the pair, which is {\tt1}. {\tt p.second} accesses the {\tt second} element of the pair, which is {\tt"Geeks"}.

%------------------------------------------------------------------------------%

\subsection{Update values -- Cập nhật giá trị}
We update the elements of pair like accessing elements from pair but in place of access, we just assign new data using {\tt assignment} operator, e.g.:
\begin{Verbatim}[numbers=left,xleftmargin=5mm]
#include <bits/stdc++.h>
using namespace std;

int main() {
    pair<int, string> p = {1, "Geeks"};
	
    // update first and second value of pair
    p.first = 2;
    p.second = "ForGeeks";
    cout << p.first << " " << p.second;
    return 0;
}
\end{Verbatim}
Explanation: In the above code, {\tt p.first = 2} directly changes the 1st value of the pair to {\tt2}, \& {\tt p.second = "ForGeeks"}; directly changes the 2nd value of the pair to {\tt"ForGeeks"}.

%------------------------------------------------------------------------------%

\subsection{Compare pairs -- So sánh cặp}
Just like other data types, we can use relational operators with pairs. They initially compare the 1st value. If it does not give result, then 2nd value is compared. The following table describes the behavior of these operators for pairs:
\begin{table}[H]
	\centering
	\begin{tabular}{|c|l|}
		Operator & Description \\
		\hline
		{\tt==} & Return {\tt true} if both pairs are equal, otherwise {\tt false} \\
		\hline
		{\tt!=} & Return {\tt true} if pairs are not equal, otherwise {\tt false} \\
		\hline
		{\tt>} &  Return {\tt true} if the LHS pair is greater than the RHS pair, otherwise {\tt false} \\
		\hline
		{\tt<} & Return {\tt true} if the LHS pair is less than the RHS pair, otherwise {\tt false} \\
		\hline
		{\tt>=} & Return {\tt true} if the LHS pair is greater than or equal to the RHS pair, otherwise {\tt false} \\
		\hline
		{\tt<=} & Return {\tt true} if the LHS pair is less than or equal to the RHS pair, otherwise {\tt false} \\
		\hline
	\end{tabular}
\end{table}
\begin{Verbatim}[numbers=left,xleftmargin=5mm]
#include <iostream>
using namespace std;

int main() {
    pair<int, int> p1 = {3, 5};
    pair<int, int> p2 = {3, 7};
    pair<int, int> p3 = {2, 5};
	
    // printing result of comparision
    cout << boolalpha;
    cout << "p1 == p2: " << (p1 == p2) << endl;
    cout << "p1 != p3: " << (p1 != p3) << endl;
    cout << "p1 > p3: " << (p1 > p3) << endl;
    cout << "p1 < p2: " << (p1 < p2) << endl;
    cout << "p1 >= p3: " << (p1 >= p3) << endl;
    cout << "p3 <= p1: " << (p3 <= p1);
    return 0;
}
\end{Verbatim}
Output:
\begin{verbatim}
p1 == p2: false
p1 != p3: true
p1 > p3: true
p1 < p2: true
p1 >= p3: true
p3 <= p1: true
\end{verbatim}

%------------------------------------------------------------------------------%

\subsection{Unpacking a pair -- Tháo một cặp}
We can extract \& store the 2 values of the pair in 2 different variables of same type using {\tt tie()} function, e.g.:
\begin{Verbatim}[numbers=left,xleftmargin=5mm]
#include <bits/stdc++.h>
using namespace std;
int main() {
    pair<int, string> p = {1, "Geeks"};
	
    // variables to store extracted values
    int a;
    string s;
	
    // extracting values using tie()
    tie(a, s) = p;
	
    cout << "First value: " << a << endl;
    cout << "Second value: " << s;
    return 0;
}
\end{Verbatim}
Output:
\begin{verbatim}
First value: 1
Second value: Geeks
\end{verbatim}
Explanation: In this program, the 1st \& 2nd value of the pair {\tt p} is extracted into the variable {\tt a, s} using the function {\tt tie()}.

%------------------------------------------------------------------------------%

\subsection{Some common applications of pairs -- Vài ứng dụng phổ biến của cặp}
A pair is commonly used for the following purposes:
\begin{enumerate}
	\item Returning multiple values from functions.
	\item Storing key-value pairs in other containers, especially maps.
	\item Sorting containers on the basis of multiple criteria.
\end{enumerate}

%------------------------------------------------------------------------------%


\section{Set in C++ STL}
\textbf{\textsf{Resources -- Tài nguyên.}}
\begin{enumerate}
	\item \href{https://www.geeksforgeeks.org/set-in-cpp-stl/}{Geeks4Geeks{\tt/}set in C++ STL}.
	\item \href{https://www.geeksforgeeks.org/different-ways-to-initialize-an-set-in-cpp/}{Geeks4Geeks{\tt/}different ways to initialize an set in C++ STL}.
	\item \href{https://www.geeksforgeeks.org/different-ways-to-insert-elements-in-set-in-cpp-stl/}{Geeks4Geeks{\tt/}different ways to insert elements into set in C++ STL}.
\end{enumerate}
In C++, {\it sets} are associative container which stores unique elements in some sorted order. By default, it is sorted ascending order of the keys, but this can be changed as per requirement. It provides fast insertion, deletion, \& search operations, e.g.:
\begin{Verbatim}[numbers=left,xleftmargin=5mm]
#include <iostream>
#include <set>
using namespace std;

int main() {
    // creating a set of integers
    set<int> s = {3, 5, 2, 1};
	
    for (auto x : s)
        cout << x << " ";
    return 0;
}
\end{Verbatim}
Output: {\tt1 2 3 5}. Explanation: In the above program, we create a set with name {\tt s} values $\{3,5,2,1\}$.

\noindent{\bf Syntax.} The set container is defined as {\tt std::set} class template inside {\tt<set>} header file.
\begin{verbatim}
set<T, comp> s;
\end{verbatim}
where {\tt T}: data type of elements in the set, {\tt s}: name assigned to the set, {\tt comp}: a binary predicate function that tells set how to compare 2 elements, which is used to sort set in custom order \& is optional \& if not provided, set is sorted in increasing order.

%------------------------------------------------------------------------------%

\subsection{Declaration \& initialization -- Khai báo \& khởi tạo}
We can declare \& initialize a set in multiple ways, e.g.:
\begin{Verbatim}[numbers=left,xleftmargin=5mm]
#include <bits/stdc++.h>
using namespace std;

int main() {
    // creating an empty set
    set<int> s1;
	
    // creating a set from an initializer list
    set<int> s2 = {5, 1, 3, 2, 4};
	
    for (auto i : s2) 
        cout << i << " ";
    return 0;
}
\end{Verbatim}
Output: {\tt1 2 3 4 5}. Explanation: In this program, we create 2 sets: Statement {\tt set<int> s1} creates an empty set {\tt s1}, called {\tt default initialization}. Statement \verb|set<int> s2 = {5, 1, 3, 2}| creates a {\tt s2} with 4 elements using {\it initializer list}.

Some basic operations that can be performed on a set are as follows.

%------------------------------------------------------------------------------%

\subsection{Inserting elements -- chèn phần tử}
In set, elements are added using the \href{https://www.geeksforgeeks.org/set-insert-function-in-c-stl/}{insert()} or \href{https://www.geeksforgeeks.org/setemplace-c-stl/}{eplace()} function. If the element already exists in the set, it will not be added again. We cannot specify the position to insert the element as it is automatically decided according to the order, e.g.:
\begin{Verbatim}[numbers=left,xleftmargin=5mm]
#include <bits/stdc++.h>
using namespace std;

int main() {
    set<int> s = {1, 4, 2};
	
    // insert elements into set
    s.insert(5);
    s.emplace(3);
    s.insert(5);
	
    for (auto x: s) cout << x << " ";
    return 0;
}
\end{Verbatim}
Output: {\tt1 2 3 4 5}.

%------------------------------------------------------------------------------%

\subsection{Accessing elements}
We can't access elements of a set by index like in an array or vector. In set, we have to increment or decrement iterator obtained from \href{https://www.geeksforgeeks.org/access-element-in-set-in-cpp/}{begin()} or \href{https://www.geeksforgeeks.org/setbegin-setend-c-stl/}{end()} methods respectively to access the element by position. This can also be done with the help of \href{https://www.geeksforgeeks.org/stdnext-in-cpp/}{next()} or \href{https://www.geeksforgeeks.org/stdadvance-in-cpp/}{advance()} function, e.g.:
\begin{Verbatim}[numbers=left,xleftmargin=5mm]
#include <bits/stdc++.h>
using namespace std;

int main() {
    set<int> s = {1, 4, 2, 3, 5};
	
    // accessing first element
    auto it1 = s.begin();
	
    // accessing third element
    auto it2 = next(it1, 2);
	
    cout << *it1 << " " << *it2;
    return 0;
}
\end{Verbatim}
Output: {\tt1 3}. Explanation: In the above program, {\tt s.begin()} returns an iterator to the 1st element of the set which is stored in {\tt it1}. To access the 3rd element, {\tt next()} is used to move the iterator {\tt it1} by 2 positions \& store it in {\tt it2}. The {\tt*it1, *it2} dereference the iterators to access the values at those positions.

%------------------------------------------------------------------------------%

\subsection{Updating elements -- Cập nhật phần tử}
We cannot change the value of elements once they are stored in the set.

-- Chúng ta không thể thay đổi giá trị của các phần tử sau khi chúng được lưu trữ trong tập hợp.

%------------------------------------------------------------------------------%

\subsection{Finding elements -- Tìm phần tử}
Set provides fast search by value operation using the \href{https://www.geeksforgeeks.org/set-find-function-in-c-stl/}{\tt find()} member function. This function returns iterator the element if found, otherwise returns {\tt end()} iterator, e.g.:
\begin{Verbatim}[numbers=left,xleftmargin=5mm]
#include <bits/stdc++.h>
using namespace std;

int main() {
    set<int> s = {1, 4, 2, 3, 5};
	
    // finding 3
    auto it = s.find(3);
	
    if (it != s.end()) cout << *it;
    else cout << "Element not Found!";
    return 0;
}
\end{Verbatim}
Output: 3.

%------------------------------------------------------------------------------%

\subsection{Traversing -- Duyệt}
Just like other containers, sets can be easily traversed using {\it range-based for loop} or using {\tt begin(), end()} iterators, e.g.:
\begin{Verbatim}[numbers=left,xleftmargin=5mm]
#include <bits/stdc++.h>
using namespace std;

int main() {
    set<int> s = {5, 1, 4, 3, 2};
	
    // traversing using range based for loop
    for(auto it = s.begin(); it != s.end(); it++)
        cout << *it << " ";
    return 0;
}
\end{Verbatim}
Output: {\tt1 2 3 4 5}.

%------------------------------------------------------------------------------%

\subsection{Deleting elements -- Xóa phần tử}
In set, elements are removed from a set using the \href{https://www.geeksforgeeks.org/seterase-c-stl/}{erase()} function. We can erase elements either by value or by position, e.g.:
\begin{Verbatim}[numbers=left,xleftmargin=5mm]
#include <bits/stdc++.h>
using namespace std;

int main() {
    set<int> s = {1, 4, 2, 3, 5};
	
    // deleting elements by value
    s.erase(5);
	
    // deleting first element by iterator
    s.erase(s.begin());
	
    for (auto x: s) cout << x << " ";
    return 0;
}
\end{Verbatim}
Output: {\tt2 3 4}.

%------------------------------------------------------------------------------%

\subsection{Time complexity}
The below table lists the time complexity of the above operations on set:
\begin{table}[H]
	\centering
	\begin{tabular}{|l|c|}
		\hline
		Operation & Time complexity \\
		\hline
		Insert an element & $O(\log n)$ \\
		\hline
		Delete an element & $O(\log n)$ \\
		\hline
		Find the largest element & $O(1)$ \\
		\hline
		Find smallest element & $O(1)$ \\
		\hline
		Find element by value & $O(\log n)$ \\
		\hline
		Traverse the set & $O(n)$ \\
		\hline
	\end{tabular}
\end{table}

%------------------------------------------------------------------------------%

\subsection{Other common operations on sets}
\begin{enumerate}
	\item Check if the Set is Empty
	\item Find the Size of a Set
	\item Traverse Set in Reverse
	\item Change Sorting Order in a Set
	\item Swap Two Sets
	\item Create Set of Pairs
	\item Create Set of User Defined Datatype
\end{enumerate}

%------------------------------------------------------------------------------%

\subsection{Internal working}
In C++, set is an associative container that provides the implementation of \href{https://www.geeksforgeeks.org/red-black-tree-in-cpp/}{Red-Black Tree}. This data structure makes sure that elements are always stored in a sorted order. It also makes sure that insertion, deletion, \& access operations take logarithmic time.

***

%------------------------------------------------------------------------------%

\section{Struct}
\textbf{\textsf{Resources -- Tài nguyên.}}
\begin{enumerate}
	\item \href{https://en.wikipedia.org/wiki/Struct_(C_programming_language)}{Wikipedia{\tt/}struct (C programming language)}.
	\item \href{https://www.geeksforgeeks.org/structures-in-cpp/}{Geeks4Geeks{\tt/}structures in C++}.
\end{enumerate}
C++ structures are used to create user defined data types which are used to store group of items of different data types.

\noindent{\bf Syntax.} Before using structure, we have to 1st define the structure using the {\tt struct} keyword as shown:
\begin{verbatim}
struct name {
    type1 mem1;
    type2 mem2;
    ...
};
\end{verbatim}
where structure name is {\tt name, mem1, mem2, mem3} are the items it groups. They are also called its {\it members} or {\it fields}, e.g.:
\begin{verbatim}
struct point { // structure name
    int x; // member or fields of structure
    int y;
};
\end{verbatim}
The above is also called {\it structure definition}. It is not allocated any memory \& cannot be used in the program directly. We have to create its variables to use it.

%------------------------------------------------------------------------------%

\subsection{Structure variable -- Biến cấu trúc}
Once the structure is defined, its variable can be created in a similar way as basic data type variables.
\begin{verbatim}
struct_name var_name;
\end{verbatim}
where \verb|struct_name| is the name of the structure \& \verb|var_name| is the name of the variable.

A variable can also be declared with the definition of the structure:
\begin{verbatim}
struct name {
    type1 mem1;
    type2 mem2;
} var1, var2;
\end{verbatim}

%------------------------------------------------------------------------------%

\subsection{Initialize structure members}
Structure members cannot be initialized with declaration, e.g., the following C++ program fails in compilation.
\begin{verbatim}
struct Point {
    int x = 0;
    int y = 0;
};
\end{verbatim}
Structure members can be initialized to values provided in the curly braces {\tt\{\}}, e.g.:
\begin{Verbatim}[numbers=left,xleftmargin=5mm]
struct Point {
    int x, y;
};

int main() {
    // initialize data members of structure using curly braces
    struct Point p1 = { 0, 1 };
	
    return 0;
}
\end{Verbatim}
The values provided in the curly braces $\{\}$ are {\it sequentially} assigned to the members of the structure. In the above example, {\tt0} is assigned to member {\tt x}m \& {\tt1} is assigned to member {\tt y}.

Since C++20, we can also use \href{https://www.geeksforgeeks.org/designated-initializers-in-cpp-20/}{designated initializers} to initialize the structure members.

%------------------------------------------------------------------------------%

\subsection{Access \& modify members}


%------------------------------------------------------------------------------%

\section{Miscellaneous}

%------------------------------------------------------------------------------%

\printbibliography[heading=bibintoc]
	
\end{document}