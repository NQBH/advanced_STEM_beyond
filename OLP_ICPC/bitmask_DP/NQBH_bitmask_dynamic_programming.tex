\documentclass{article}
\usepackage[backend=biber,natbib=true,style=alphabetic,maxbibnames=50]{biblatex}
\addbibresource{/home/nqbh/reference/bib.bib}
\usepackage[utf8]{vietnam}
\usepackage{tocloft}
\renewcommand{\cftsecleader}{\cftdotfill{\cftdotsep}}
\usepackage[colorlinks=true,linkcolor=blue,urlcolor=red,citecolor=magenta]{hyperref}
\usepackage{amsmath,amssymb,amsthm,enumitem,fancyvrb,float,graphicx,mathtools,tikz}
\usetikzlibrary{angles,calc,intersections,matrix,patterns,quotes,shadings}
\allowdisplaybreaks
\newtheorem{assumption}{Assumption}
\newtheorem{baitoan}{Bài toán}
\newtheorem{cauhoi}{Câu hỏi}
\newtheorem{conjecture}{Conjecture}
\newtheorem{corollary}{Corollary}
\newtheorem{dangtoan}{Dạng toán}
\newtheorem{definition}{Definition}
\newtheorem{dinhly}{Định lý}
\newtheorem{dinhnghia}{Định nghĩa}
\newtheorem{example}{Example}
\newtheorem{ghichu}{Ghi chú}
\newtheorem{hequa}{Hệ quả}
\newtheorem{hypothesis}{Hypothesis}
\newtheorem{lemma}{Lemma}
\newtheorem{luuy}{Lưu ý}
\newtheorem{nhanxet}{Nhận xét}
\newtheorem{notation}{Notation}
\newtheorem{note}{Note}
\newtheorem{principle}{Principle}
\newtheorem{problem}{Problem}
\newtheorem{proposition}{Proposition}
\newtheorem{question}{Question}
\newtheorem{remark}{Remark}
\newtheorem{theorem}{Theorem}
\newtheorem{vidu}{Ví dụ}
\usepackage[left=1cm,right=1cm,top=5mm,bottom=5mm,footskip=4mm]{geometry}
\def\labelitemii{$\circ$}
\DeclareRobustCommand{\divby}{%
    \mathrel{\vbox{\baselineskip.65ex\lineskiplimit0pt\hbox{.}\hbox{.}\hbox{.}}}%
}
\setlist[itemize]{leftmargin=*}
\setlist[enumerate]{leftmargin=*}

\title{Bitmask Dynamic Programming -- Quy Hoạch Động Bitmask}
\author{Nguyễn Quản Bá Hồng\footnote{A scientist- {\it\&} creative artist wannabe, a mathematics {\it\&} computer science lecturer of Department of Artificial Intelligence {\it\&} Data Science (AIDS), School of Technology (SOT), UMT Trường Đại học Quản lý {\it\&} Công nghệ TP.HCM, Hồ Chí Minh City, Việt Nam.\\E-mail: {\sf nguyenquanbahong@gmail.com} {\it\&} {\sf hong.nguyenquanba@umt.edu.vn}. Website: \url{https://nqbh.github.io/}. GitHub: \url{https://github.com/NQBH}.}}
\date{\today}

\begin{document}
 \maketitle
\begin{abstract}
    This text is a part of the series {\it Some Topics in Advanced STEM \& Beyond}:

    {\sc url}: \url{https://nqbh.github.io/advanced_STEM/}.

    Latest version:
    \begin{itemize}
        \item {\it Bitmask Dynamic Programming -- Quy Hoạch Động Bitmask}.

        PDF: {\sc url}: \url{https://github.com/NQBH/advanced_STEM_beyond/blob/main/OLP_ICPC/bitmask_DP/NQBH_bitmask_dynamic_programming.pdf}.

        \TeX: {\sc url}: \url{https://github.com/NQBH/advanced_STEM_beyond/blob/main/OLP_ICPC/bitmask_DP/NQBH_bitmask_dynamic_programming.tex}.
    \end{itemize}
    Mục tiêu của bài viết này là tổng hợp 1 số bài viết về quy hoạch động bitmask bằng tiếng Việt \& dịch 1 số trang về bitmask DP viết bằng tiếng Anh, \& bổ sung các giải thích mang tính cá nhân của tác giả để chuẩn bị cho kỳ thi Olympic Tin học Sinh viên OLP \& ICPC.
\end{abstract}
\tableofcontents

%------------------------------------------------------------------------------%

\section{Preliminaries}

%------------------------------------------------------------------------------%

\subsection{Notation -- Ký hiệu}

\begin{itemize}
    \item $\overline{m,n}\coloneqq\{m,m + 1,\ldots,n - 1, n\}$, $\forall m,n\in\mathbb{Z}$, $m\le n$. Hence the notation ``for $i\in\overline{m,n}$'' means ``for $i = m,m + 1,\ldots,n$'', i.e., chỉ số{\tt/}biến chạy $i$ chạy từ $m\in\mathbb{Z}$ đến $n\in\mathbb{Z}$. Trong trường hợp $a,b\in\mathbb{R}$, ký hiệu $\overline{a,b}\coloneqq\overline{\lceil a\rceil,\lfloor b\rfloor}$ có nghĩa như định nghĩa trước đó với $m\coloneqq\lceil a\rceil,n\coloneqq\lfloor b\rfloor\in\mathbb{Z}$; khi đó ký hiệu ``for $i\in\overline{a,b}$'' với $a,b\in\mathbb{R}$, $a\le b$ có nghĩa là ``for $i = \lceil a\rceil,\lceil a\rceil + 1,\ldots,\lfloor b\rfloor - 1,\lfloor b\rfloor$, i.e., chỉ số{\tt/}biến chạy $i$ chạy từ $\lceil a\rceil$ đến $\lfloor b\rfloor\in\mathbb{Z}$.
    \item $\lfloor x\rfloor,\{x\}$ lần lượt được gọi là {\it phần nguyên \& phần lẻ} (integer- \& fractional parts) của $x\in\mathbb{R}$, see, e.g., \href{https://en.wikipedia.org/wiki/Floor_and_ceiling_functions}{Wikipedia{\tt/}floor \& ceiling functions}, \href{https://en.wikipedia.org/wiki/Fractional_part}{Wikipedia{\tt/}fractional part}.
    \item $x_+\coloneqq\max\{x,0\}$, $x_-\coloneqq\max\{-x,0\} = -\min\{x,0\}$ lần lượt được gọi là {\it phần dương \& phần âm} (positive- \& negative parts) của $x\in\mathbb{R}$.
    \item s.t.: abbreviation of `such that'.
    \item w.l.o.g.: abbreviation of `without loss of generality'.
    \item $|A|$ or $\#A$: the number of elements of a set $A$ -- số phần tử của 1 tập hợp $A$ hữu hạn.
    \item ${\rm card}(A)$: cardinality of a set $A$ (finite or infinite) -- lực lượng của 1 tập hợp $A$ (hữu hạn hoặc vô hạn).
    \item $[n]\coloneqq\{1,2,\ldots,n\}$: the set of 1st $n\in\mathbb{N}^\star$ positive integers, which serves as 1 of prototypical example of a finite set with $n$ elements -- tập hợp $n\in\mathbb{N}^\star$ số nguyên dương  đầu tiên, đóng vai trò là 1 trong ví dụ nguyên mẫu của 1 tập hợp hữu hạn với $n$ phần tử. Quy ước $[0] = \emptyset$ ký hiệu tập rỗng, i.e., tập hợp không chứa bất cứ phần tử nào.

    Note: $[n]$ là ký hiệu ưa thích của dân Tổ hợp vì tập $[n]$ xuất hiện xuyên suốt trong các bài toán Tổ hợp với vai trò tập mẫu để biểu đạt số phần tử cần thiết.
    \item $A_n^k = \dfrac{n!}{(n - k)!}$: Chỉnh hợp chập $k$ phần tử từ 1 tập hợp có $n$ phần tử.
    \item $C_n^k = \binom{n}{k} = \dfrac{n!}{k!(n - k)!}$: Tổ hợp chập $k$ phần tử từ 1 tập hợp có $n$ phần tử.
    \item $P_n = n!$, $\forall n\in\mathbb{N}$: the number of permutations.
    \item O: Olympiad problem -- Bài tập định hướng ôn luyện Olympic Toán Hoặc Olympic Tin.
    \item R: Research-oriented problems -- Bài tập định hướng nghiên cứu. tBài tập hay các câu hỏi nhãn R, (R-labeled problems \& R-labeled questions) thường sẽ có các bài báo nghiên cứu khoa học liên quan đính kèm.
\end{itemize}

%------------------------------------------------------------------------------%

Chiến thuật về cấu trúc nội dung: \fbox{bitwise operators $+$ dynamic programming $\Rightarrow$ bitwise dynamic programming} (kiểu như hợp thể tiến hóa của Pokemon hoặc Dragon Balls -- 7 Viên Ngọc Rồng).

\section{Bitwise Operators -- Toán Tử Bitwise}
\textbf{\textsf{Resources -- Tài nguyên.}}
\begin{enumerate}
    \item {\sc Siyong Huang, Chongtian Ma, Mihnea Brebenel}. \href{https://usaco.guide/silver/intro-bitwise}{USACO Guide{\tt/}intro to bitwise operators}.

    {\sf Abstract.} 6 bitwise operators \& some of their common usages.

    \item \href{https://en.wikipedia.org/wiki/Bitwise_operation}{Wikipedia{\tt/}bitwise operation}.
\end{enumerate}

\begin{problem}[\href{https://codeforces.com/contest/1556/problem/D?locale=en}{CodeForces{\tt/}take a guess}]
    This is an interactive task: {\sc William} has a certain sequence of integers $a_1,\ldots,a_n$ in his mind, but due to security concerns, he does not want to reveal it to you completely. {\sc William} is ready to respond to no more than $2n$ of the following questions:
    \begin{itemize}
        \item What is the result of a bitwise {\tt AND} of 2 items with indices $i\ne j$.
        \item What is the result of a bitwise {\tt OR} of 2 items with indices $i\ne j$.
    \end{itemize}
    You can ask {\sc William} these questions \& you need to find the $k$th smallest number of the sequence. Formally the $k$th smallest number is equal to the number at the $k$th place in a $1$-indexed array sorted in non-decreasing order, e.g., in array $[5,3,3,10,1]$ $4$th smallest number is equal to $5$, \& 2nd \& 3rd are $3$.
    \item {\sf Input.} It is guaranteed that for each element in a sequence the condition $0\le a_i\le10^9$ is satisfied.
    \item {\sf Interaction.} In the 1st line you will be given 2 integers $n\in\overline{3,10^4},k\in[n]$, which are the number of items in the sequence $a$ \& the number $k$. After that, you can ask no more than $2n$ questions (not including {\tt finish} operation). Each line of your output may be of 1 of the following types:
    \begin{itemize}
        \item {\tt or i j} with $i,j\in[n],i\ne j$, where $i,j$ are indices of items for which you want to calculate the bitwise {\tt OR}.
        \item {\tt and i j} with $i,j\in[n],i\ne j$, where $i,j$ are indices of items for which you want to calculate the bitwise {\tt AND}.
        \item {\tt finish res}, where {\tt res} is the $k$th smallest number in the sequence. After outputting this line the program execution must conclude.
    \end{itemize}
    In response to the 1st 2 types of queries, you will get an integer $x$, the result of the operation for the numbers you have selected. After outputting a line do not forget to output a new line character \& flush the output buffer. Otherwise you will get the {\tt Idleness limit exceeded}. To flush the buffer use:
    \begin{itemize}
        \item {\tt fflush(stdout)} in C++
        \item {\tt System.out.flush()} in Java
        \item {\tt stdout.flush()} in Python
        \item {\tt flush(output)} in Pascal
        \item for other languages refer to documentation
    \end{itemize}
    If you perform an incorrect query the response will be $-1$. After receiving response $-1$ you must immediately halt your program in order to receive an {\tt Incorrect answer} verdict.
    \item {\sf Hacking.} To perform a hack you will need to use the following format: The 1st line must contain 2 integers $n\in\overline{3,10^4},k\in[n]$, which are the number of items in the sequence $a$ \& the number $k$. The 2nd line must contain $n$ integers $a_1,a_2,\ldots,a_n$ with $a_i\in\overline{0,10^9}$, $\forall i\in[n]$, the sequence $a$.
    \item {\sf Sample.}
    \begin{table}[H]
        \centering
        \begin{tabular}{|l|l|}
            \hline
            \verb|take_guess.inp| & \verb|take_guess.out| \\
            \hline
            7 6 & and 2 5 \\
            2 & or 5 6 \\
            7 & finish 5 \\
            \hline
        \end{tabular}
    \end{table}
    \item {\sf Explanation.} The hidden sequence is $[1,6,4,2,3,5,4]$.
\end{problem}

\begin{baitoan}[Đoán]
    Đây là 1 nhiệm vụ tương tác: {\sc William} có 1 dãy số nguyên $a_1,\ldots,a_n$ trong đầu, nhưng vì lý do bảo mật, anh ấy không muốn tiết lộ toàn bộ dãy số đó cho bạn. {\sc William} chỉ sẵn sàng trả lời tối đa $2n$ câu hỏi sau:

    \begin{itemize}
        \item Kết quả của phép toán {\tt AND} trên bitwise của 2 phần tử có chỉ số $i\ne j$ là bao nhiêu?
        \item Kết quả của phép toán {\tt OR} trên bitwise của 2 phần tử có chỉ số $i\ne j$ là bao nhiêu?
    \end{itemize}
    Bạn có thể hỏi {\sc William} những câu hỏi này \& bạn cần tìm số nhỏ nhất thứ $k$ của dãy số. Về mặt hình thức, số nhỏ nhất thứ $k$ bằng số ở vị trí $k$ trong 1 mảng $1$ được sắp xếp theo thứ tự không giảm, ví dụ: trong mảng $[5,3,3,10,1]$, số nhỏ nhất thứ $4$ bằng $5$, \& số thứ 2 \& số thứ 3 là $3$.
    \item {\sf Input.} Đảm bảo rằng với mỗi phần tử trong 1 dãy, điều kiện $0\le a_i\le10^9$ được thỏa mãn.
    \item {\sf Interaction.} Dòng đầu tiên, bạn sẽ được cung cấp 2 số nguyên $n\in\overline{3,10^4},k\in[n]$, là số phần tử trong dãy $a$ \& số $k$. Sau đó, bạn có thể hỏi không quá $2n$ câu hỏi (không bao gồm thao tác {\tt finish}). Mỗi dòng đầu ra của bạn có thể thuộc 1 trong các kiểu sau:
    \begin{itemize}
        \item {\tt or i j} với $i,j\in[n],i\ne j$, trong đó $i,j$ là chỉ số của các mục mà bạn muốn tính toán {\tt OR} theo bit.
        \item {\tt and i j} với $i,j\in[n],i\ne j$, trong đó $i,j$ là chỉ số của các mục mà bạn muốn tính toán {\tt AND} theo bit.
        \item {\tt finish res}, trong đó {\tt res} là số nhỏ thứ $k$ trong chuỗi. Sau khi xuất dòng này, chương trình phải kết thúc thực thi.
    \end{itemize}
    Đáp lại 2 kiểu truy vấn đầu tiên, bạn sẽ nhận được 1 số nguyên $x$, kết quả của phép toán cho các số bạn đã chọn. Sau khi xuất 1 dòng, đừng quên xuất 1 ký tự xuống dòng \& xóa bộ đệm đầu ra. Nếu không, bạn sẽ nhận được thông báo {\tt Idleness limit exceeded}. Để xóa bộ đệm, hãy sử dụng:
    \begin{itemize}
        \item {\tt fflush(stdout)} trong C++
        \item {\tt System.out.flush()} trong Java
        \item {\tt stdout.flush()} trong Python
        \item {\tt flush(output)} trong Pascal
        \item để biết các ngôn ngữ khác, vui lòng tham khảo tài liệu
    \end{itemize}
    Nếu bạn thực hiện 1 truy vấn không chính xác, phản hồi sẽ là $-1$. Sau khi nhận được phản hồi $-1$, bạn phải dừng chương trình ngay lập tức để nhận được kết quả {\tt Câu trả lời không chính xác}.
    \item {\sf Hacking.} Để thực hiện hack, bạn cần sử dụng định dạng sau: Dòng đầu tiên phải chứa 2 số nguyên $n\in\overline{3,10^4},k\in[n]$, là số phần tử trong chuỗi $a$ \& số $k$. Dòng thứ 2 phải chứa $n$ số nguyên $a_1,a_2,\ldots,a_n$ với $a_i\in\overline{0,10^9}$, $\forall i\in[n]$, dãy số $a$.
\end{baitoan}

\begin{proof}[Solution]
    We can figure out the sum of 2 numbers using just their {\tt AND, OR}, \& {\tt XOR} values by the following property:

    \begin{lemma}
        $a + b = 2\cdot(a\&b) + a\oplus b$.
    \end{lemma}

    \begin{proof}[Proof]
        $a\oplus b$ is essentially just $a + b$ in base 2 but we never carry over to the next bit. Recall a bit in $a\oplus b$ is 1 iff the bit in $a$ is different from the bit in $b$, thus 1 of them must be a 1. However, when we add 2 1 bits, we yield a 0, but we do not carry that 1 to the next bit. This is where $a\&b$ comes in. $a\&b$ is just the carry bits themselves, since a bit is 1 only if it's a 1 in both $a$ \& $b$, which is exactly what we need. We multiply this by 2 to shift all the bits to the left by 1, so every value carries over to the next bit. To acquire the XOR values of the 2 numbers, we can use the following:
        \begin{equation*}
            a\oplus b = \neg(a\&b)\&(a|b).
        \end{equation*}
        The proof is as follows. Recall a bit in $a\oplus b$ is 1 iff the bit in $a$ is different from the bit in $b$. By negating $a\&b$, the bits that are left on are in the following format: (i) if it's 1 in $a$ \& 0 in $b$, or (ii) if it's 0 in $a$ \& $1$ in $b$, or (iii) if it's 0 in $a$ \& 0 in $b$. But we need to get rid of the 3rd case. By taking the bitwise {\tt AND} with $a|b$, the ones that are left on is only if there is a 1 in either a or b. Obviously, the 3rd case isn't included in $a|b$ since both bits are off, \& we successfully eliminate that case.

        -- $a\oplus b$ về cơ bản chỉ là $a + b$ trong cơ số 2 nhưng chúng ta không bao giờ chuyển sang bit tiếp theo. Hãy nhớ lại 1 bit trong $a\oplus b$ là 1 nếu và chỉ khi bit trong $a$ khác với bit trong $b$, do đó 1 trong số chúng phải là 1. Tuy nhiên, khi chúng ta cộng 2 bit 1, chúng ta sẽ thu được 0, nhưng chúng ta không chuyển 1 đó sang bit tiếp theo. Đây là lúc $a\&b$ xuất hiện. $a\&b$ chỉ là bản thân các bit nhớ, vì 1 bit chỉ là 1 nếu nó là 1 trong cả $a$ \& $b$, đó chính xác là những gì chúng ta cần. Chúng ta nhân số này với 2 để dịch chuyển tất cả các bit sang trái 1, vì vậy mọi giá trị đều được chuyển sang bit tiếp theo. Để có được các giá trị XOR của 2 số, chúng ta có thể sử dụng lệnh sau:
        \begin{equation*}
            a\oplus b = \neg(a\&b)\&(a|b).
        \end{equation*}
        Chứng minh như sau. Nhớ lại 1 bit trong $a\oplus b$ là 1 nếu và chỉ khi bit trong $a$ khác với bit trong $b$. Bằng cách phủ định $a\&b$, các bit còn lại sẽ có định dạng sau: (i) nếu 1 trong $a$ \& 0 trong $b$, hoặc (ii) nếu 0 trong $a$ \& 1 trong $b$, hoặc (iii) nếu 0 trong $a$ \& 0 trong $b$. Nhưng ta cần loại bỏ trường hợp thứ 3. Bằng cách thực hiện phép toán {\tt AND} bitwise với $a|b$, các bit còn lại chỉ được xem xét nếu có 1 trong a hoặc b. Rõ ràng, trường hợp thứ 3 không được bao gồm trong $a|b$ vì cả hai bit đều bị tắt, \& ta đã loại bỏ thành công trường hợp đó.
    \end{proof}
    Now that we can acquire the sum of any 2 numbers in 2 queries, we can easily solve the problem now. We can find the values of the 1st 3 numbers of the array using a system of equations involving their sum (note $n\ge3$). Once we have acquired their independent values, we can loop through the rest of the array.

    -- Bây giờ, khi đã có thể tính tổng của 2 số bất kỳ trong 2 truy vấn, chúng ta có thể dễ dàng giải quyết vấn đề. Chúng ta có thể tìm giá trị của 3 số đầu tiên trong mảng bằng cách sử dụng hệ phương trình liên quan đến tổng của chúng (lưu ý $n\ge3$). Sau khi đã tính được các giá trị độc lập của chúng, chúng ta có thể lặp qua phần còn lại của mảng.

    C++: \url{https://usaco.guide/silver/intro-bitwise?lang=cpp}.
    \begin{Verbatim}[numbers=left,xleftmargin=5mm]
#include <iostream>
#include <algorithm>
#include <vector>
using namespace std;

int ask(string s, int a, int b) {
    cout << s << ' ' << a << ' ' << b << '\n';
    int res;
    cin >> res;
    return res;
}

/** @return the sum of the elements at a and b (0-indexed) */
int sum(int a, int b) {
    int and_ = ask("and", ++a, ++b);
    int or_ = ask("or", a, b);
    int xor_ = ~and_ & or_; // a ^ b = ~(a & b) & (a | b)
    return 2 * and_ + xor_; // a + b = 2(a & b) + a ^ b
}

int main() {
    int n, k;
    cin >> n >> k;
    // acquire 1st 3 elements
    int a_plus_b = sum(0, 1);
    int a_plus_c = sum(0, 2);
    int b_plus_c = sum(1, 2);

    // get actual values by solving equations
    vector<int> arr{(a_plus_b + a_plus_c + b_plus_c) / 2};
    arr.push_back(a_plus_b - arr[0]);
    arr.push_back(a_plus_c - arr[0]);

    // get rest of array
    for (int i = 3; i < n; ++i) arr.push_back(sum(i - 1, i) - arr.back());
    sort(arr.begin(), arr.end());
    cout << "finish " << arr[k - 1] << '\n';
}
    \end{Verbatim}
\end{proof}

\begin{problem}
    Implement addition \& multiplication using only bitwise operators.

    -- Thực hiện phép cộng \& phép nhân chỉ sử dụng các toán tử bit.
\end{problem}

\begin{proof}[Solution]
    If we perform addition without carrying, then we are simply performing the \verb|XOR ^| operator. Then, the bits that we carry over are those equivalent to 1 in both numbers: $a\&b$.

    -- Nếu chúng ta thực hiện phép cộng mà không nhớ, thì chúng ta chỉ đơn giản thực hiện phép toán \verb|XOR ^|. Khi đó, các bit được nhớ là các bit tương đương với 1 trong cả hai số: $a\&b$.
    \begin{Verbatim}[numbers=left,xleftmargin=5mm]
int add(int a, int b) {
    while (b > 0) {
        int carry = a & b;
        a ^= b;
        b = carry << 1;
    }
    return a;
}
    \end{Verbatim}
    For simplicity, we will use the {\tt sum} function defined above. If we divide up $b$ into $\sum_{i=1}^n 2^{b_i} = 2^{b_1} + 2^{b_2} + \cdots + 2^{b_n}$, we get the following
    \begin{equation*}
        a\times b = a\times\sum_{i=1}^n 2^{b_i} = a(2^{b_1} + 2^{b_2} + \cdots + 2^{b_n}) a2^{b_1} + a2^{b_2} + \cdots + a2^{b_n} = \sum_{{\rm bits\ in\ }b} a << b_i.
    \end{equation*}
    Implementation:
    \begin{Verbatim}[numbers=left,xleftmargin=5mm]
int prod(int a, int b) {
    int c = 0;
    while ( b > 0) {
        if ((b & 1) == 1) c = add(c, a);
        a <<= 1;
        b >>= 1;
    }
    return c;
}
    \end{Verbatim}
    This same idea is used in binary exponentiation.
\end{proof}

%------------------------------------------------------------------------------%

\subsection{XOR operation -- Thao tác XOR}
Perhaps 1 of the most common binary operations in practice is bitwise {\tt xor}. The special property that differentiates it from the other bitwise operations is that {\tt xor} is its own inverse, i.e., $x\oplus x = 0$.

-- Có lẽ 1 trong những phép toán nhị phân phổ biến nhất trong thực tế là phép toán bitwise {\tt xor}. Tính chất đặc biệt phân biệt nó với các phép toán bitwise khác là {\tt xor} là phép toán nghịch đảo của chính nó, tức là $x\oplus x = 0$.

\begin{problem}[\href{https://atcoder.jp/contests/abc365/tasks/abc365_e}{AtCoder{\tt/}Toyota Programming Contest 2024\#8{\tt/}E: Xor Sigma Problem}]
    You are given an integer sequence $a = \{a_i\}_{i=1}^n$ of length $n\in\mathbb{N}^\star$. Find the value of the following expression:
    \begin{equation*}
        \sum_{i=1}^n\sum_{j = i + 1}^n a_i\oplus a_{i+1}\oplus\cdots\oplus a_j.
    \end{equation*}
    \item {\sf Constraints.} $n\in\overline{2,2\cdot10^5},a_i\in[10^8]$, $\forall i\in[n]$. All input values are integers.
    \item {\sf Input.} The input is given from Standard Input in the following format:
    \begin{verbatim}
n
a_1 a_2 ... a_n
    \end{verbatim}
    \item {\sf Output.} Print the answer.
    \item {\sf Sample.}
    \begin{table}[H]
        \centering
        \begin{tabular}{|l|l|}
            \hline
            \verb|xor_sigma.inp| & \verb|xor_sigma.out| \\
            \hline
            3 & 3 \\
            1 3 2 & \\
            \hline
            7 & 83 \\
            2 5 6 5 2 1 7 & \\
            \hline
        \end{tabular}
    \end{table}
    \item {\sf Explanation.} For testcase 1, $a_1\oplus a_2 = 2,a_1\oplus a_2\oplus a_3 = 0,a_2\oplus a_3 = 1$, so the answer is $2 + 0 + 1 = 3$.
\end{problem}

\begin{baitoan}[]
    Bạn được cho 1 dãy số nguyên $a = \{a_i\}_{i=1}^n$ có độ dài $n\in\mathbb{N}^\star$. Tìm giá trị của biểu thức sau:
    \begin{equation*}
        \sum_{i=1}^n\sum_{j = i + 1}^n a_i\oplus a_{i+1}\oplus\cdots\oplus a_j.
    \end{equation*}
    \item {\sf Constraints.} $n\in\overline{2,2\cdot10^5}, a_i\in[10^8]$, $\forall i\in[n]$. Tất cả các giá trị đầu vào đều là số nguyên.
    \item {\sf Input.} Dữ liệu đầu vào được cung cấp từ Đầu vào Chuẩn theo định dạng sau:
    \begin{verbatim}
n
a_1 a_2 ... a_n
    \end{verbatim}
    \item {\sf Output.} In ra đáp án.
\end{baitoan}

\begin{proof}[Solution]
    We analyze the bits of each xor-sum independently. In this case, we will check for every bit position, i.e., for every power of 2, whether or not it's set in the xor-sum of every contiguous subsequence. This way, we transformed the problem into counting the number of subsequences with nonzero xor-sum; this will be applied on the array form by the bits on the same position in all the values.

    -- Chúng ta phân tích các bit của mỗi tổng xor 1 cách độc lập. Trong trường hợp này, chúng ta sẽ kiểm tra xem vị trí bit, tức là với mọi lũy thừa của 2, có nằm trong tổng xor của mọi chuỗi con liền kề hay không. Bằng cách này, chúng ta đã chuyển đổi bài toán thành việc đếm số lượng chuỗi con có tổng xor khác 0; điều này sẽ được áp dụng trên dạng mảng bởi các bit ở cùng vị trí trong tất cả các giá trị.

    Implementation: Time complexity: $O(n)$
    \begin{Verbatim}[numbers=left,xleftmargin=5mm]
#include <iostream>
#include <numeric>
#include <vector>
using namespace std;

int main() {
    int n;
    cin >> n;
    vector<int> v(n);
    for (int &a : v) cin >> a;
    long long ans = -accumulate(v.begin(), v.end(), 0LL);
    // for every bit position, check if it is set on in the xor-sum of every subsequence
    for (int i = 0; i < 30; ++i) {
        int s = 0;
        // count the prefix sums
        // the # of 0 xor-sum prefixes starts from 1 to count the prefixes with xor-sum 1
        vector<int> pref = {1, 0};
        for (int a : v) {
            s ^= (a >> i) & 1;
            /*
            * Count the # of sequences ending at this position with xor-sum
            * non-zero by counting the prefixes of the inversed bit, i.e.
            * pref[i] ^ pref[j] = 1. Update the answer by adding the # of such
            * sequences multiplied by the respective power of two.
            */
            ans += pref[s ^ 1] * 1LL << i;
            ++pref[s]; // update prefixes
        }
    }
    cout << ans;
}
    \end{Verbatim}
\end{proof}
Some useful operations:
\begin{enumerate}
    \item \verb|x &= (1 << k)| will set the number to $1{\tt<<}k$ if the $k$th bit was true, \& 0 if the $k$bit was false.

    -- \verb|x &= (1 << k)| sẽ đặt số thành $1{\tt<<}k$ nếu bit thứ $k$ là đúng, \& 0 nếu bit $k$ là sai.

    \item \verb!x |= (1 << k)! will set the $k$th bit to true regardless of what it currently is.

    -- \verb!x |= (1 << k)! sẽ đặt bit thứ $k$ thành true bất kể bit đó hiện tại là gì.

    \item If the $k$th bit is already true, \verb|x += (1 << k)| will make the $k$th bit false \& mess up the rest of $x$.

    -- Nếu bit thứ $k$ đã đúng, \verb|x += (1 << k)| sẽ làm cho bit thứ $k$ sai \& làm hỏng phần còn lại của $x$.

    \item \verb|1 << n| will give $2^n$, which is the number of subsets for an array of size $n\in\mathbb{N}$ including $\emptyset$.

    -- \verb|1 << n| sẽ cho kết quả $2^n$, là số tập hợp con của 1 mảng có kích thước $n\in\mathbb{N}$ bao gồm $\emptyset$.

    \item \verb|x & ( 1 << k)| will check if the $k$th bit in {\tt int} $x$ is true.

    -- \verb|x & ( 1 << k)| sẽ kiểm tra xem bit thứ $k$ trong {\tt int} $x$ có đúng không.
\end{enumerate}

%------------------------------------------------------------------------------%

\section{Introduction to Dynamic Programming -- Giới Thiệu Quy Hoạch Động}
\textbf{\textsf{Resources -- Tài nguyên.}}
\begin{enumerate}
    \item {\sc Michael Cao, Benjamin Qi, Neo Wang, Daniel Zhu}. \href{https://usaco.guide/gold/intro-dp}{USACO Guide{\tt/}introduction to DP}.

    {\sf Abstract.} Speeding up naive recursive solutions with memoization.

    \item \href{https://en.wikipedia.org/wiki/Dynamic_programming}{Wikipedia{\tt/}dynamic programming}.
\end{enumerate}
{\it Dynamic Programming} (DP) is an important algorithmic technique in Competitive Programming from the gold division to competitions like the International Olympiad of Informatics (abbr., IOI). By breaking down the full task into subproblem, DP avoids the redundant computations of brute force solutions. Although it is not too difficult to grasp the general ideas behind DP, the technique can be used in a diverse range of problems \& is a must-know idea for competitors in the USACO Gold division.

-- Lập trình Động (DP) là một kỹ thuật thuật toán quan trọng trong Lập trình Cạnh tranh, từ hạng Vàng đến các cuộc thi như Olympic Tin học Quốc tế (viết tắt là IOI). Bằng cách chia nhỏ toàn bộ bài toán thành các bài toán con, DP tránh được việc tính toán dư thừa của các giải pháp dùng vũ lực. Mặc dù không quá khó để nắm bắt các ý tưởng chung đằng sau DP, nhưng kỹ thuật này có thể được sử dụng trong nhiều bài toán khác nhau \& là một kiến thức bắt buộc phải biết đối với các thí sinh ở hạng Vàng USACO.

\begin{note}
    ``It is usually a good idea to write a slower solution 1st. E.g., if the complexity required for full points is $O(n)$ \& you come up with a simple $O(n^2)$ solution, then you should definitely type that up 1st \& earn some partial credit. Afterwards, you can rewrite parts of your slow solution until it is of the desired complexity. The slow solution might also serve as something to \href{https://usaco.guide/general/basic-debugging#stress-testing}{stress test} against.''

    -- Thông thường, viết một giải pháp chậm hơn trước là một ý tưởng hay. Ví dụ, nếu độ phức tạp cần thiết cho điểm đầy đủ là $O(n)$ \& bạn đưa ra một giải pháp đơn giản $O(n^2)$, thì bạn chắc chắn nên viết giải pháp đó trước \& được cộng một phần điểm. Sau đó, bạn có thể viết lại các phần của giải pháp chậm cho đến khi đạt được độ phức tạp mong muốn. Giải pháp chậm này cũng có thể được dùng để kiểm tra ứng suất.
\end{note}

\begin{problem}[\href{https://atcoder.jp/contests/dp/tasks/dp_a}{AtCoder{\tt/}educational DP contest{\tt/}A: frog 1}]
    There are $n$ stones, numbered $1,2,\ldots,n$. For each $i\in[n]$, the height of stone $i$ is $h_i$. There is a frog who is initially on stone 1. He will repeat the following actions some number of times to reach stone $n$: If the frog is currently on stone $i$, jump to stone $i + 1$ or stone $i + 2$. Here, a cost of $|h_i - h_j|$ is incurred, where $j$ is the stone to land on. Find the minimum possible total cost incurred before the frog reaches stone $n$.
    \item {\sf Constraints.} All values in input are integers. $n\in\overline{2,10^5},h_i\in[10^4]$, $\forall i\in[n]$.
    \item {\sf Input.} Input is given from Standard Input in the following format:
    \begin{verbatim}
n
h_1 h_2 ... h_n
    \end{verbatim}
    \item {\sf Output.} Print the minimum possible total cost incurred.
    \item {\sf Sample.}
    \begin{table}[H]
        \centering
        \begin{tabular}{|l|l|}
            \hline
            \verb|frog_1.inp| & \verb|frog_1.out| \\
            \hline
            4 & 30 \\
            10 30 40 20 & \\
            \hline
            2 & 0 \\
            10 10 & \\
            \hline
            6 & 40 \\
            30 10 60 10 60 50 & \\
            \hline
        \end{tabular}
    \end{table}
    \item {\sf Explanation.} For testcase 1, if we follow the path $1\to2\to4$, the total cost incurred would be $|10 - 30| + |30 - 20| = 30$. For testcase 2, if we follow the path $1\to2$, the total cost incurred would be $|10 - 10| = 0$. For testcase 3, if we follow the path $1\to3\to5\to6$, the total cost incurred would be $|30 - 60| + |60 - 60| + |60 - 50| = 40$
\end{problem}

\begin{baitoan}[Ếch 1]
    Có $n$ viên đá, được đánh số $1, 2,\ldots, n$. Với mỗi $i\in[n]$, độ cao của Viên đá $i$ là $h_i$. Có một con ếch ban đầu ở trên Viên đá 1. Nó sẽ lặp lại các hành động sau một số lần để đến được Viên đá $n$: Nếu con ếch hiện đang ở trên Viên đá $i$, hãy nhảy đến Viên đá $i + 1$ hoặc Viên đá $i + 2$. Ở đây, chi phí là $|h_i - h_j|$, trong đó $j$ là viên đá để đáp xuống. Tìm tổng chi phí nhỏ nhất có thể phát sinh trước khi con ếch đến được Viên đá $n$.
    \item {\sf Ràng buộc.} Tất cả các giá trị trong đầu vào là số nguyên. $n\in\overline{2,10^5}, h_i\in[10^4]$, $\forall i\in[n]$.
    \item {\sf Đầu vào.} Đầu vào được cung cấp từ Đầu vào Chuẩn theo định dạng sau:
    \begin{verbatim}
n
h_1 h_2 ... h_n
    \end{verbatim}
    \item {\sf Đầu ra.} In ra tổng chi phí phát sinh nhỏ nhất có thể.
\end{baitoan}
The problem asks us to compute the minimum total cost it takes for a frog to travel from stone 1 to stone $n\le10^5$ given that the frog can only jump a distance of 1 or 2. The cost to travel between any 2 stones $i,j$ is given by $c(i,j)\coloneqq|h_i - h_j|$, where $h_i$ represents the height of stone $i$.

-- Bài toán yêu cầu chúng ta tính tổng chi phí tối thiểu để một con ếch di chuyển từ hòn đá 1 đến hòn đá $n\le10^5$ biết rằng con ếch chỉ có thể nhảy được quãng đường là 1 hoặc 2. Chi phí để di chuyển giữa 2 hòn đá $i,j$ bất kỳ được xác định bởi $c(i,j)\coloneqq|h_i - h_j|$, trong đó $h_i$ biểu thị chiều cao của hòn đá $i$.

\begin{proof}[1st solution: Without DP. Time complexity: $O(2^n)$]
    Since there are only 2 options, we can use recursion to compute what would happen if we jumped either 1 stone or 2 stones. There are 2 possibilities, so recursively computing would require computing both a left \& right subtree. Therefore, for every additional jump, each branch splits into 2, which results in an exponential time complexity.

    -- Vì chỉ có 2 lựa chọn, chúng ta có thể sử dụng đệ quy để tính toán điều gì sẽ xảy ra nếu chúng ta nhảy 1 hoặc 2 viên đá. Có 2 khả năng, vì vậy tính toán đệ quy sẽ yêu cầu tính toán cả cây con trái \& cây con phải. Do đó, với mỗi lần nhảy bổ sung, mỗi nhánh sẽ tách thành 2, dẫn đến độ phức tạp thời gian theo cấp số nhân.

    However, this can be sped up with dynamic programming by keeping track of ``optimal states'' in order to avoid calculating states multiple times. E.g., recursively calculating jumps of length $1,2,1$ \& $2,1,2$ reuses the state of stone 3. Dynamic programming provides the mechanism to cache such states.

    -- Tuy nhiên, điều này có thể được tăng tốc bằng lập trình động bằng cách theo dõi ``trạng thái tối ưu'' để tránh phải tính toán trạng thái nhiều lần. Ví dụ: tính toán đệ quy các bước nhảy có độ dài $1,2,1$ \& $2,1,2$ sẽ tái sử dụng trạng thái của viên đá 3. Lập trình động cung cấp cơ chế lưu trữ đệm các trạng thái như vậy.
\end{proof}

\begin{proof}[2nd solution: With DP. Time complexity: $O(n)$]
    There are 2 main DP approaches:
    \begin{enumerate}
        \item {\it Push DP}, where we update future states based on the current state;
        \item {\it Pull DP}, where we calculate the current state based on past states.
    \end{enumerate}
    -- Có 2 phương pháp DP chính:
    \begin{enumerate}
        \item {\it Push DP}, trong đó chúng ta cập nhật các trạng thái tương lai dựa trên trạng thái hiện tại;
        \item {\it Pull DP}, trong đó chúng ta tính toán trạng thái hiện tại dựa trên các trạng thái trước đó.
    \end{enumerate}
    \item(a) {\bf Push DP.} There are only 2 options: jumping once, or jumping twice. Define ${\rm dp}[i]$ as the minimum cost to reach stone $i$. Then, our transitions are as follows:
    \begin{itemize}
        \item Jump 1 stone, incurring a cost of $|h_i - h_{i+1}|$:
        \begin{equation*}
            {\rm dp}[i + 1] = \min\{{\rm dp}[i + 1],{\rm dp}[i] + |h_i - h_{i+1}|\}.
        \end{equation*}
        \item Jump 2 stones, incurring a cost of $|h_i - h_{i+2}$:
        \begin{equation*}
            {\rm dp}[i + 2] = \min\{{\rm dp}[i + 2],{\rm dp}[i] + |h_i - h_{i+2}|\}.
        \end{equation*}
    \end{itemize}
    We can start with the base case that ${\rm dp}[0] = 0$, since the frog is already on that square, \& proceed to calculate ${\rm dp}[1],{\rm dp}[2],\ldots,{\rm dp}[n - 1]$.

    -- {\bf DP đẩy.} Chỉ có 2 lựa chọn: nhảy một lần hoặc nhảy hai lần. Xác định ${\rm dp}[i]$ là chi phí tối thiểu để đến được hòn đá $i$. Sau đó, các bước chuyển tiếp của chúng ta như sau:
    \begin{itemize}
        \item Nhảy 1 hòn đá, với chi phí là $|h_i - h_{i+1}|$:
        \begin{equation*}
            {\rm dp}[i + 1] = \min\{{\rm dp}[i + 1],{\rm dp}[i] + |h_i - h_{i+1}|\}.
        \end{equation*}
        \item Nhảy 2 viên đá, tốn $|h_i - h_{i+2}$:
        \begin{equation*}
            {\rm dp}[i + 2] = \min\{{\rm dp}[i + 2],{\rm dp}[i] + |h_i - h_{i+2}|\}.
        \end{equation*}
    \end{itemize}
    Ta có thể bắt đầu với trường hợp cơ sở là ${\rm dp}[0] = 0$, vì con ếch đã ở trên ô đó, \& tiến hành tính ${\rm dp}[1],{\rm dp}[2],\ldots,{\rm dp}[n - 1]$.
    \begin{Verbatim}[numbers=left,xleftmargin=5mm]
#include <iostream>
#include <vector>
#include <climits>
using namespace std;

int main() {
    int n;
    cin >> n;
    vector<int> height(n);
    for (int i = 0; i < n; ++i) cin >> height[i];
    // dp[i] is the minimum cost to get to the i-th stone
    vector<int> dp(n, INT_MAX);
    dp[0] = 0; // base case since we are already at the 1st stone
    for (int i = 0; i < n - 1; ++i) { // for each state, calculate the states it leads to
        dp[i + 1] = min(dp[i + 1], dp[i] + abs(height[i] - height[i + 1])); // jump 1 stone
        if (i + 2 < n) dp[i + 2] = min(dp[i + 2], dp[i] + abs(height[i] - height[i + 2])); // jump 2 stones
    }
    cout << dp[n - 1];
}
    \end{Verbatim}
    \item {\bf Pull DP.} There are 2 ways to get to stone $i$: from stone $i - 1$ \& stone $i - 2$:
    \begin{itemize}
        \item Jump from stone $i - 1$, incurring a cost of $|h_i - h_{i-1}|$:
        \begin{equation*}
            {\rm dp}[i] = \min\{{\rm dp}[i],{\rm dp}[i - 1] + |h_i - h_{i-1}|\}.
        \end{equation*}
        \item Jump from stone $i - 2$, incurring a cost of $|h_i - h_{i-2}|$:
        \begin{equation*}
            {\rm dp}[i] = \min\{{\rm dp}[i],{\rm dp}[i - 2] + |h_i - h_{i-2}|\}.
        \end{equation*}
    \end{itemize}
    We can start with the base case that ${\rm dp}[0] = 0$, since the frog is already on that square, \& proceed to calculate ${\rm dp}[1],{\rm dp}[2],\ldots,{\rm dp}[n - 1]$.

    -- {\bf DP kéo.} Có 2 cách để đến hòn đá $i$: từ hòn đá $i - 1$ \& hòn đá $i - 2$:
    \begin{itemize}
        \item Nhảy từ hòn đá $i - 1$, tốn $|h_i - h_{i-1}|$:
        \begin{equation*}
            {\rm dp}[i] = \min\{{\rm dp}[i],{\rm dp}[i - 1] + |h_i - h_{i-1}|\}.
        \end{equation*}
        \item Nhảy từ hòn đá $i - 2$, chịu chi phí $|h_i - h_{i-2}|$:
        \begin{equation*}
            {\rm dp}[i] = \min\{{\rm dp}[i],{\rm dp}[i - 2] + |h_i - h_{i-2}|\}.
        \end{equation*}
    \end{itemize}
    Ta có thể bắt đầu với trường hợp cơ sở là ${\rm dp}[0] = 0$, vì con ếch đã ở trên ô vuông đó, \& tiến hành tính ${\rm dp}[1],{\rm dp}[2],\ldots,{\rm dp}[n - 1]$.
    \begin{Verbatim}[numbers=left,xleftmargin=5mm]
#include <iostream>
#include <vector>
#include <climits>
using namespace std;

int main() {
    int n;
    cin >> n;
    vector<int> height(n);
    for (int i = 0; i < n; ++i) cin >> height[i];
    // dp[i] is the minimum cost to get to the i-th stone
    vector<int> dp(n, INT_MAX);
    dp[0] = 0; // base case since we are already at the 1st stone
    for (int i = 1; i < n; ++i) { // for each state, calculate the states it leads to
        if (i >= 1) dp[i] = min(dp[i], dp[i - 1] + abs(height[i] - height[i - 1])); // jump 1 stone
        if (i >= 2) dp[i] = min(dp[i], dp[i - 2] + abs(height[i] - height[i - 2])); // jump 2 stones
    }
    cout << dp[n - 1];
}
    \end{Verbatim}
\end{proof}

%------------------------------------------------------------------------------%

\section{Introduction to Bitmask Dynamic Programming -- Giới Thiệu Quy Hoạch Động Bitmask}
\textbf{\textsf{Resources -- Tài nguyên.}}
\begin{enumerate}
    \item {\sc Michael Cao, Siyong Huang, Peng Bai}. \href{https://usaco.guide/gold/dp-bitmasks}{USACO Guide{\tt/}bitmask DP}.

    \item \href{https://codedream.edu.vn/bitmask_1/}{CodeDream{\tt/}quy hoạch động xử lý bit (DP bitmask) phần 1}.
\end{enumerate}
Bitmask dynamic programming (abbr., bitmask DP) attacks DP problems that require iterating over subsets.

\begin{problem}[\href{https://cses.fi/problemset/task/1690}{CSES Problem Set{\tt/}Hamiltonian flights}]
    There are $n\in\mathbb{N}^\star$ cities \& $m\in\mathbb{N}^\star$ flight connections between them. You want to travel from Syrjälä to Lehmälä so that you visit each city exactly once. How many possible routes are there?
    \item {\sf Input.} The 1st input line has $2$ integers $n,m\in\mathbb{N}^\star$: the number of cities \& flights. The cities are numbered $1,2,\ldots,n$. City $1$ is Syrjälä, \& city $n$ is Lehmälä. Then, there are $m$ lines describing the flights. Each line has $2$ integers $a,b\in\mathbb{N}^\star$: there is a flight from city $a$ to city $b$. All flights are $1$-way flights.
    \item {\sf Output.} Print $1$ integer: the number of routes modulo $10^9 + 7$.
    \item {\sf Constraints.} $n\in\overline{2,20},m\in[n^2],a,b\in[n]$.
    \item {\sf Sample.}
    \begin{table}[H]
        \centering
        \begin{tabular}{|l|l|}
            \hline
            \verb|Hamiltonian_flight.inp| & \verb|Hamiltonian_flight.out| \\
            \hline
            4 6 & 2\\
            1 2 & \\
            1 3 & \\
            2 3 & \\
            3 2 & \\
            2 4 & \\
            3 4 & \\
            \hline
        \end{tabular}
    \end{table}
\end{problem}

\begin{baitoan}[Chuyến bay Hamiltonian]
    Có $n\in\mathbb{N}^\star$ thành phố \& $m\in\mathbb{N}^\star$ chuyến bay nối liền chúng. Bạn muốn đi từ Syrjälä đến Lehmälä sao cho bạn ghé thăm mỗi thành phố đúng 1 lần. Có bao nhiêu tuyến đường khả thi?
    \item {\sf Input.} Dòng đầu vào thứ nhất chứa $2$ số nguyên $n,m\in\mathbb{N}^\star$: số lượng thành phố \& chuyến bay. Các thành phố được đánh số $1,2,\ldots,n$. Thành phố $1$ là Syrjälä, \& thành phố $n$ là Lehmälä. Sau đó, có $m$ dòng mô tả các chuyến bay. Mỗi dòng chứa $2$ số nguyên $a,b\in\mathbb{N}^\star$: có 1 chuyến bay từ thành phố $a$ đến thành phố $b$. Tất cả các chuyến bay đều là chuyến bay 1 chiều.
    \item {\sf Output.} In ra $1$ số nguyên: số tuyến đường theo modulo $10^9 + 7$.
    \item {\sf Ràng buộc.} $n\in\overline{2,20},m\in[n^2],a,b\in[n]$.
\end{baitoan}

\begin{proof}[Solution]
    Let ${\rm dp}[S][i]$ be the number of routes that visit all the cities in the subset $S\subset[n]$ \& end at city $i$. The transitions will be
    \begin{equation*}
        {\rm dp}[S][i] = \sum_{x\in {\rm adj}[i]} {\rm dp}[S\backslash\{i\}][x]\mbox{ if } x\in S.
    \end{equation*}
    Time complexity: $O(2^nn^2)$.

    -- Giả sử ${\rm dp}[S][i]$ là số tuyến đường đi qua tất cả các thành phố trong tập con $S\subset[n]$ \& kết thúc tại thành phố $i$. Các phép chuyển tiếp sẽ là
    \begin{equation*}
        {\rm dp}[S][i] = \sum_{x\in {\rm adj}[i]} {\rm dp}[S\backslash\{i\}][x]\mbox{ nếu } x\in S.
    \end{equation*}
    Độ phức tạp thời gian: $O(2^nn^2)$.

    C++: \url{https://usaco.guide/gold/dp-bitmasks?lang=cpp}.
    \begin{Verbatim}[numbers=left,xleftmargin=5mm]
#include <iostream>
#include <vector>
using namespace std;
using ll = long long;
const int MAX_N = 20;
const ll MOD = (ll)1e9 + 7;

ll dp[1 << MAX_N][MAX_N];
vector<int> come_from[MAX_N]; // come_from[i] contains the cities that can fly to i

int main() {
    int city_num, flight_num;
    cin >> city_num >> flight_num;
    for (int f = 0; f < flight_num; ++f) {
        int start, end;
        cin >> start >> end;
        come_from[--end].push_back(--start);
    }

    dp[1][0] = 1;
    for (int s = 2; s < 1 << city_num; ++s) {
        // only consider subsets that have the 1st city
        if ((s & (1 << 0)) == 0) continue;
        // also only consider subsets with the last city if it's the full subset
        if ((s & (1 << (city_num - 1))) && s != ((1 << city_num) - 1)) continue;
        for (int end = 0; end < city_num; ++end) {
            if ((s & (1 << end)) == 0) continue;
            // the subset that doesn't include the current end
            int prev = s - (1 << end);
            for (int j : come_from[end]) {
                if ((s & (1 << j))) {
                    dp[s][end] += dp[prev][j];
                    dp[s][end] %= MOD;
                }
            }
        }
    }
    cout << dp[(1 << city_num) - 1][city_num - 1] << '\n';
}
    \end{Verbatim}
\end{proof}

%------------------------------------------------------------------------------%

\subsection{Merging subsets -- Gộp tập con}

\begin{definition}[Proper{\tt/}strict subset]
    Let $A$ be a set. A subset $B$ is called a {\rm proper subset} (also {\rm strict subset}) of $A$ iff $B\subset A$ \& $B\ne A$, denoted by $B\subsetneq A$ (or $B\subsetneqq A$).
\end{definition}

\begin{dinhnghia}[Tập con ngặt]
    Cho $A$ là 1 tập hợp. Tập con $B$ được gọi là {\rm tập con thực sự} (cũng là {\rm tập con nghiêm ngặt}) của $A$ nếu và chỉ $B\subset A$ \& $B\ne A$, ký hiệu là $B\subsetneq A$ (hoặc $B\subsetneqq A$).
\end{dinhnghia}

\begin{baitoan}
    Cho $n\in\mathbb{N}$ \& 1 tập hợp $A = \{a_1,a_2,\ldots,a_n\}$ có $n$ phần tử. Đếm: (a) Số tập con của $A$. (b) Số tập con ngặt của $A$.
\end{baitoan}

\begin{proof}[1st solution]
    (a) Vì mỗi phần tử $a_i$ của tập $A$ có thể thuộc hoặc không thuộc 1 tập con $B\subset A$, theo quy tắc nhân, số tập con của $A$ bằng $\prod_{i=1}^n 2 = 2^n$. (b) Trong $2^n$ tập con của $A$, chỉ có duy nhất tập con $A$ không phải là tập con ngặt, nên số tập con ngặt của $A$ bằng $2^n - 1$.
\end{proof}

\begin{proof}[2nd solution]
    (a) Với mỗi $i\in\overline{0,n}$, có $C_n^i = \binom{n}{i}$ tập con của $A$ có đúng $i$ phần tử, nên tổng số tập con của $A$ bằng $\sum_{i=0}^n \binom{n}{i} = (1 + 1)^n = 2^n$ (theo định lý nhị thức Newton). (b) Ta loại ra bản thân tập hợp $A$, với mỗi $i\in\overline{0,n - 1}$, có $C_n^i = \binom{n}{i}$ tập con của $A$ có đúng $i$ phần tử, nên tổng số tập con của $A$ bằng $\sum_{i=0}^{n-1} \binom{n}{i} = (1 + 1)^n - C_n^n = 2^n - 1$ (theo định lý nhị thức Newton).
\end{proof}
In some problems, for a set $S$, it is insufficient to transition from $S\backslash\{i\}$. Instead, it is necessary to transition from all strict subsets (also proper subset) of $S$. Though it may seem like we have to do $O(2^n2^n) = O(4^n)$ transitions, there's really only $O(3^n)$ transitions. Indeed, we count the number of ordered pairs $(T,S)$ where $T\subset S\subset[n]$. Instead of counting directly, notice that each element $x$ is either: (i) in $T$ \& $S$, i.e., $x\in S\cap T$; (ii) in either, i.e., $x\notin S\cup T$; (iii) in $S$ but not in $T$, i.e., $x\in S\backslash T$. If $x$ is in $T$ but not in $S$, i.e., $x\in T\backslash S$, $T$ is not a valid subset. Given that each element can be in 3 possible states, our overall complexity is actually $O(3^n)$. To implement this, we can do some bitwise tricks:

-- Trong 1 số bài toán, đối với tập $S$, việc chuyển đổi từ $S\backslash\{i\}$ là không đủ. Thay vào đó, cần phải chuyển đổi từ tất cả các tập con nghiêm ngặt của $S$. Mặc dù có vẻ như chúng ta phải thực hiện $O(2^n2^n) = O(4^n)$ chuyển đổi, nhưng thực ra chỉ có $O(3^n)$ chuyển đổi. Thật vậy, chúng ta đếm số cặp có thứ tự $(T,S)$ trong đó $T\subset S\subset[n]$. Thay vì đếm trực tiếp, hãy lưu ý rằng mỗi phần tử $x$ là: (i) trong $T$ \& $S$, tức là $x\in S\cap T$; (ii) trong 1 trong hai trường hợp, tức là $x\notin S\cup T$; (iii) trong $S$ nhưng không trong $T$, tức là $x\in S\backslash T$. Nếu $x$ nằm trong $T$ nhưng không nằm trong $S$, tức là $x\in T\backslash S$, thì $T$ không phải là 1 tập con hợp lệ. Vì mỗi phần tử có thể ở 3 trạng thái, nên độ phức tạp tổng thể của chúng ta thực tế là $O(3^n)$. Để thực hiện điều này, chúng ta có thể thực hiện 1 số thủ thuật bitwise:
\begin{Verbatim}[numbers=left,xleftmargin=5mm]
for (int mask = 0; mas < (1 << n); ++mask)
    for (int submask = mask; submask != 0; submask = (submask - 1) & mask) {
        int subset = mask ^ submask;
        // do whatever you need to do here
    }
\end{Verbatim}
When we subtract 1 from {\tt submask}, the rightmost bit flips to a 0 \& all bits to the right of it will become 1. Applying the bitwise {\tt AND} with {\tt mask} removes all extra bits not in {\tt mask}. From this process, we can get all strict subsets in increasing order by calculating ${\tt mask}\oplus{\tt submask}$, which does set subtraction $S\backslash T$.

-- Khi chúng ta trừ 1 khỏi {\tt submask}, bit ngoài cùng bên phải sẽ chuyển thành 0 \& tất cả các bit bên phải nó sẽ trở thành 1. Áp dụng phép toán {\tt AND} bitwise với {\tt mask} sẽ loại bỏ tất cả các bit thừa không nằm trong {\tt mask}. Từ quy trình này, chúng ta có thể lấy tất cả các tập con nghiêm ngặt theo thứ tự tăng dần bằng cách tính toán ${\tt mask}\oplus{\tt submask}$, điều này sẽ thực hiện phép trừ tập hợp $S\backslash T$.

\begin{baitoan}
    Cho $n\in\mathbb{N}$. Đếm số cặp $(S,T)$ thỏa: (a) $T\subset S\subset[n]$. (b) $T\subsetneq S\subsetneq[n]$. (c) $T\subset S\subsetneq[n]$. (d) $T\subsetneq S\subset[n]$.
\end{baitoan}

\begin{proof}[Solution]
    (a) Có $\binom{n}{i}$ tập con $S\subset[n]$ có đúng $i$ phần tử, $\forall i\in\overline{0,n}$, tiếp theo với mỗi bộ $i$ phần tử được chọn, có $\binom{i}{j}$ tập con $T\subset S$ có đúng $j$ phần tử, $\forall j\in\overline{0,i}$, nên theo quy tắc cộng \& quy tắc nhân, số cặp $(S,T)$ thỏa $T\subset S\subset[n]$ bằng
    \begin{equation*}
        \sum_{i=0}^n\sum_{j=0}^i \binom{n}{i}\binom{i}{j} = \sum_{i=0}^n\sum_{j=0}^i \frac{n!}{j!(i - j)!(jn - i)!} = 3^n.
    \end{equation*}
    (b)
    \begin{equation*}
        \sum_{i=1}^{n-1}\sum_{j=0}^{i-1} \binom{n}{i}\binom{i}{j} =
    \end{equation*}
    (c)
    \begin{equation*}
        \sum_{i=0}^{n-1}\sum_{j=0}^i \binom{n}{i}\binom{i}{j} =
    \end{equation*}
    (d)
    \begin{equation*}
        \sum_{i=1}^n\sum_{j=0}^{i-1} \binom{n}{i}\binom{i}{j} =
    \end{equation*}
\end{proof}

\begin{problem}[\href{https://atcoder.jp/contests/abc187/tasks/abc187_f}{AtCoder{\tt/}close group}]
    Given a simple undirected graph with $n\in\mathbb{N}^\star$ vertices \& $m\in\mathbb{N}$ edges. The vertices are numbered $1,2,\ldots,n$, \& the $i$th edge connects vertices $a_i$ \& $b_i$. Find the minimum possible number of connected components in the graph after removing zero or more edges so that the following condition will be satisfied: For every pair of vertices $(a,b)$ such that $1\le a < b \le n$, if vertices $a,b$ belong to the same connected component, there is an edge that directly connects vertices $a$ \& $b$.
    \item {\sf Constraints.} All values in input are integers. $n\in[18],0\le m\le\binom{n}{2} =\dfrac{n(n - 1)}{2},1\le a_i < b_i\le n,(a_i,b_i)\ne(a_j,b_j)$ for $i\ne j$.
    \item {\sf Input.} Input is given from Standard Input in the following format:
    \begin{verbatim}
n m
a_1 b_1
...
a_m b_m
    \end{verbatim}
    \item {\sf Output.} Print the answer.
    \item {\sf Sample.}
    \begin{table}[H]
        \centering
        \begin{tabular}{|l|l|}
            \hline
            \verb|close_group.inp| & \verb|close_group.out| \\
            \hline
            3 2 & 2 \\
            1 2 & \\
            1 3 & \\
            \hline
            4 6 & 1 \\
            1 2 & \\
            1 3 & \\
            1 4 & \\
            2 3 & \\
            2 4 & \\
            3 4 & \\
            \hline
            10 11 & 5 \\
            9 10 & \\
            2 10 & \\
            8 9 & \\
            3 4 & \\
            5 8 & \\
            1 8 & \\
            5 6 & \\
            2 5 & \\
            3 6 & \\
            6 9 & \\
            1 9 & \\
            \hline
            18 0 & 18 \\
            \hline
        \end{tabular}
    \end{table}
    \item {\sf Explanation.} For testcase 1, without removing edges, the pair $(2,3)$ violates the condition. Removing 1 of the edges disconnects vertices 2 \& 3 (i.e., after removing an edge, the graph has 2 connected components $\{1,2\},\{3\}$ if removing the edge $(1,3)$, or $\{1,3\},\{2\}$ if removing the edge $(1,2)$), satisfying the condition.
\end{problem}

\begin{baitoan}[Nhóm đóng]
    Cho 1 đồ thị vô hướng đơn giản với $n\in\mathbb{N}^\star$ đỉnh \& $m\in\mathbb{N}$ cạnh. Các đỉnh được đánh số $1, 2, \ldots, n$, \& cạnh $i$ nối các đỉnh $a_i$ \& $b_i$. Tìm số lượng thành phần liên thông nhỏ nhất có thể có trong đồ thị sau khi loại bỏ không hoặc nhiều cạnh sao cho điều kiện sau được thỏa mãn: Với mọi cặp đỉnh $(a,b)$ such that $1\le a < b \le n$, nếu các đỉnh $a,b$ thuộc cùng 1 thành phần liên thông, thì tồn tại 1 cạnh nối trực tiếp các đỉnh $a$ \& $b$.
    \item {\sf Ràng buộc.} Tất cả các giá trị trong đầu vào đều là số nguyên. $n\in[18],0\le m\le\binom{n}{2} =\dfrac{n(n - 1)}{2},1\le a_i < b_i\le n,(a_i,b_i)\ne(a_j,b_j)$ với $i\ne j$.
    \item {\sf Input.} Đầu vào được cung cấp từ Đầu vào Chuẩn theo định dạng sau:
    \begin{verbatim}
n m
a_1 b_1
...
a_m b_m
    \end{verbatim}
    \item {\sf Output.} In ra đáp án.
\end{baitoan}

\begin{proof}[Solution]
    The goal of this problem is to partition the nodes into sets such that the nodes in each set from a complete graph. Let ${\rm dp}[S]$ be the minimum number of partitions such that in each partition, the graph formed is a complete graph. We can 1st find which sets $T$ form a complete graph, setting ${\rm dp}[T]= 1$ \& $\infty$ otherwise. This can be done naively in $O(n^22^n)$ or $O(n2^n)$ by setting the adjacency list as a bitmask \& using bit manipulations if a set of nodes is a complete graph. Then we can transition as follows:
    \begin{equation*}
        {\rm dp}[S] = \min_{T\subset S} {\rm dp}[T] + dp[S\backslash T].
    \end{equation*}
    -- Mục tiêu của bài toán này là phân hoạch các nút thành các tập hợp sao cho các nút trong mỗi tập hợp là 1 đồ thị hoàn chỉnh. Giả sử ${\rm dp}[S]$ là số phân hoạch nhỏ nhất sao cho trong mỗi phân hoạch, đồ thị được tạo thành là 1 đồ thị hoàn chỉnh. Trước tiên, ta tìm các tập hợp $T$ tạo thành 1 đồ thị hoàn chỉnh, đặt ${\rm dp}[T]= 1$ \& $\infty$ trong các trường hợp còn lại. Điều này có thể được thực hiện 1 cách đơn giản trong $O(n^22^n)$ hoặc $O(n2^n)$ bằng cách đặt danh sách kề là 1 mặt nạ bit \& sử dụng các thao tác bit nếu 1 tập hợp các nút là 1 đồ thị hoàn chỉnh. Sau đó, ta có thể chuyển đổi như sau:
    \begin{equation*}
        {\rm dp}[S] = \min_{T\subset S} {\rm dp}[T] + dp[S\backslash T].
    \end{equation*}
    C++: \url{https://usaco.guide/gold/dp-bitmasks?lang=cpp}.
    \begin{Verbatim}[numbers=left,xleftmargin=5mm]
#include <iostream>
#include <cstdint>
#include <vector>
using namespace std;

int main() {
    int n, m;
    cin >> n >> m;
    vector<int> adj(n);
    for (int i = 0; i < m; ++i) {
        int u, v;
        cin >> u >> v;
        --u; --v; // 0-based indexing
        // adjacency list represented as a bitmask
        adj[u] |= (1 << v);
        adj[v] |= (1 << u);
    }
    vector<int> dp(1 << n, INT32_MAX);
    for (int mask = 0; mask < (1 << n); ++mask) {
        bool connected = true;
        for (int u = 0; u < n; ++u)
            if (((mask >> u) & 1) != 0)
                // check if u is connected to all other nodes in mask
                if (((adj[u] | (1 << u)) & mask) != mask) {
                    connected = false;
                    break;
                }
        if (connected) dp[mask] = 1;
    }
    for (int mask = 0; mask < (1 << n); ++mask)
        for (int submask = mask; submask; submask = (submask - 1) & mask) {
            int subset = mask ^ submask;
            // submask has everything in mask but not in subset
            if (dp[subset] != INT32_MAX && dp[submask] != INT32_MAX)
                dp[mask] = min(dp[mask], dp[subset] + dp[submask]);
        }
    cout << dp[(1 << n) - 1] << '\n';
}
    \end{Verbatim}
\end{proof}

%------------------------------------------------------------------------------%

\section{Some Applications of Bitmask Dynamic Programming -- Vài Ứng Dụng của Quy Hoạch Động Bitmask}
In some number theory problems, it helps to represent each number with a bitmask of its prime divisors, e.g., the set $\{6,10,15\}$ can be represented by $\{0b011,0b101,0b110\}$ (in binary, where the $0b$ prefix means that the number is binary), where the bits correspond to divisibility by $[2,3,5]$. Then, here are some equivalent operations between masks \& these integers:
\begin{enumerate}
    \item Bitwise {\tt AND} is gcd.
    \item Bitwise {\tt OR} is lcm.
    \item Iterating over bits is iterating over prime divisors.
    \item Iterating over submasks is iterating over divisors.
\end{enumerate}
Choosing a set with gcd $= 1$ is equivalent to choosing a set of bitmasks that {\tt AND} to 0. E.g., we can see that $\{6,10\}$ has ${\rm gcd}\{6,10\}\ne1$ since \verb|0b011&0b101 = 0b001| $\ne 0$. On the other hand, $\{6,10,15\}$ has ${\rm gcd}\{6,10,15\} = 1$ since \verb|0b011&0b101&0b110 = 0b000 = 0|.

-- Trong 1 số bài toán lý thuyết số, việc biểu diễn mỗi số bằng 1 mặt nạ bit của các ước số nguyên tố của nó sẽ hữu ích. Ví dụ, tập hợp $\{6,10,15\}$ có thể được biểu diễn bằng $\{0b011,0b101,0b110\}$ (ở dạng nhị phân, tiền tố $0b$ có nghĩa là số ở dạng nhị phân), trong đó các bit tương ứng với khả năng chia hết cho $[2,3,5]$. Sau đó, đây là 1 số phép toán tương đương giữa các mặt nạ \& các số nguyên này:

\begin{enumerate}
    \item Bitwise {\tt AND} là gcd.
    \item Bitwise {\tt OR} là lcm.
    \item Lặp qua các bit là lặp qua các ước số nguyên tố.
    \item Lặp qua các mặt nạ con là lặp qua các ước số.
\end{enumerate}
Việc chọn 1 tập hợp có UCLN $= 1$ tương đương với việc chọn 1 tập hợp các mặt nạ bit {\tt AND} bằng 0. Ví dụ, ta thấy $\{6,10\}$ có ${\rm UCLN}\{6,10\}\ne1$ vì \verb|0b011&0b101 = 0b001| $\ne 0$. Mặt khác, $\{6,10,15\}$ có ${\rm UCLN}\{6,10,15\} = 1$ vì \verb|0b011&0b101&0b110 = 0b000 = 0|.

%------------------------------------------------------------------------------%

\section{Miscellaneous}

%------------------------------------------------------------------------------%

\printbibliography[heading=bibintoc]

\end{document}