\documentclass[11pt,a4paper,center,notitlepage]{article}
\usepackage[backend=biber]{biblatex}

% Use Natbib reference style
%\usepackage{natbib}
 %\bibliographystyle{abbrvnat}

%\usepackage[backend=biber,style=authoryear,natbib=true]{biblatex} % Use the bibtex backend with the authoryear citation style (which resembles APA)

\addbibresource{mybib.bib} % The filename of the bibliography
% For tabular
\usepackage{tabularx}
%\usepackage{arydshln,leftidx,mathtools}
%
%\setlength{\dashlinedash}{.4pt}
%\setlength{\dashlinegap}{.8pt}

\usepackage[autostyle=true]{csquotes} % Required to generate language-dependent quotes in the bibliography

\usepackage{algorithm}
\usepackage{algpseudocode}
\usepackage[utf8]{inputenc} 
%\usepackage[T1]{fontenc}
\usepackage[english]{babel} 
\usepackage{color}
\usepackage{textcomp,multicol,enumerate,amsmath,amssymb,amsthm,eufrak,latexsym,makeidx}
\newcommand{\vertiii}[1]{{\left\vert\kern-0.25ex\left\vert\kern-0.25ex\left\vert #1 
    \right\vert\kern-0.25ex\right\vert\kern-0.25ex\right\vert}}
% For insert figure
\usepackage{subfig}
\usepackage{graphicx,epstopdf}

%% Color Reference
\usepackage[usenames,dvipsnames,svgnames,table]{xcolor}
\usepackage[colorlinks=true,
            linkcolor=blue,
            urlcolor=gray,
            citecolor=magenta]{hyperref}
            
\allowdisplaybreaks
% No page break in Bibliography
\numberwithin{equation}{section}
\addto{\captionsenglish}{%
  \renewcommand{\bibname}{References}
}


\textwidth=16 cm
\textheight=22 cm
\topmargin= -1 cm
\oddsidemargin=0 cm
\evensidemargin=1 cm
\parindent=0.6 cm
\parskip=1.5 mm
\newtheorem{lemma}{Lemma}[section]
\newtheorem{corollary}{Corollary}[section]
\newtheorem{definition}{Definition}[section]
\newtheorem{prop}{Proposition}[section]
\newtheorem{theorem}{Theorem}[section]
\newtheorem{prob}{Problem}[section]
\newtheorem{notation}{Notation}[section]
\newtheorem{remark}{Remark}[section]
\newtheorem{example}{Example}[section]
\newtheorem{ques}{Question}[section]
\newtheorem{sol}{Solution}[section]
\renewcommand{\thenotation}{}
\renewcommand{\thesection}{\arabic{section}}
\renewcommand{\thesubsection}
{\arabic{section}.\arabic{subsection}}
\pagestyle{plain}

% Reference
\newcommand{\er}{\eqref}

%\newtheorem{theorem}{Theorem}[section]
%\newtheorem{corollary}[theorem]{Corollary}
%\newtheorem{lemma}[theorem]{Lemma}
%\newtheorem{proposition}[theorem]{Proposition}

%\theoremstyle{definition}
%\newtheorem{definition}[theorem]{Definition}
%\newtheorem{remark}{Remark}
%\newtheorem{properties}{Properties}
%\newtheorem*{notation}{Notation}
%\newtheorem{counter}{Counter-example}
%\newtheorem{open}{Open problem}
%\newtheorem{conjecture}{Conjecture}


%% FONT commands
\newcommand{\txt}[1]{\;\text{ #1 }\;}%% Used in math only
\newcommand{\tbf}{\textbf}%% Bold face. Usage: \tbf{...}
\newcommand{\tit}{\textit}%% Italic
\newcommand{\tsc}{\textsc}%% Small caps
\newcommand{\trm}{\textrm}
\newcommand{\mbf}{\mathbf}%% Math bold
\newcommand{\mrm}{\mathrm}%% Math Roman
\newcommand{\bsym}{\boldsymbol}%% Bold math symbol
%%Macros for changing font size in math.
\newcommand{\scs}{\scriptstyle}%% as in subscript
\newcommand{\sss}{\scriptscriptstyle}%% as in sub-subscript
\newcommand{\txts}{\textstyle}
\newcommand{\dsps}{\displaystyle}
%%Macros for changing font size in text.
\newcommand{\fnz}{\footnotesize}
\newcommand{\scz}{\scriptsize}
%%\tiny<\scz<\fsz<\small<\large<\Large<\huge<\Huge
%%%%%%%%%%%%
%%%%%%%%%%%%
%% EQUATION commands
\newcommand{\be}{\begin{equation}}
\newcommand{\bel}[1]{\begin{equation}\label{#1}}
\newcommand{\ee}{\end{equation}}
%% This macro does not work with amstex.
\newcommand{\eqnl}[2]{\begin{equation}\label{#1}{#2}\end{equation}}
%%use not advisable; confusing
\newcommand{\barr}{\begin{eqnarray}}
\newcommand{\earr}{\end{eqnarray}}
\newcommand{\bars}{\begin{eqnarray*}}
\newcommand{\ears}{\end{eqnarray*}}
\newcommand{\nnu}{\nonumber \\}
%%%%%%%%%%%%%%%
%% Unnumbered THEOREM env.
%% New env. to be used for unnumbered theorem, lemma etc.
%%(but with specified name)

\newtheorem{subn}{\name}
\renewcommand{\thesubn}{}
\newcommand{\bsn}[1]{\def\name{#1}\begin{subn}}
\newcommand{\esn}{\end{subn}}
%%%%%%%%%%%%%%
%% NUMBERED THEOREM env.
%% Environments: theorem, lemma, corollary defintion and
%%related commands,
%% designed to provide consecutive numbering of these forms.


\newtheorem{sub}{\name}[section]
\newcommand{\dn}[1]{\def\name{#1}}

%%used in conjuction with sub or subn.

\newcommand{\bs}{\begin{sub}}
\newcommand{\es}{\end{sub}}
\newcommand{\bsl}[1]{\begin{sub}\label{#1}}
	
%% the above must be preceeded by \dn (name definition),
%% however this is superceded by the list of commands bth etc. below.
%%%%%%%%%%%%
%% NUMBERED THEOREM env. (cont.)
%% List of commands derived from 'sub' env. for theorem, lemma etc.
%% designed to provide consecutive numbering of these forms.
\newcommand{\bth}[1]{\def\name{Theorem}\begin{sub}\label{t:#1}}
\newcommand{\blemma}[1]{\def\name{Lemma}\begin{sub}\label{l:#1}}
\newcommand{\bcor}[1]{\def\name{Corollary}\begin{sub}\label{c:#1}}	
\newcommand{\bdef}[1]{\def\name{Definition}\begin{sub}\label{d:#1}}
\newcommand{\bprop}[1]{\def\name{Proposition}\begin{sub}\label{p:#1}}	
%% ARRAY commands.%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% RERERENCE commands.
%% \newcommand{\R}[1]{(\ref{#1})}

\newcommand{\R}{\eqref}
\newcommand{\re}{\eqref}
\newcommand{\rth}[1]{Theorem~\ref{t:#1}}
\newcommand{\rlemma}[1]{Lemma~\ref{l:#1}}
\newcommand{\rcor}[1]{Corollary~\ref{c:#1}}
\newcommand{\rdef}[1]{Definition~\ref{d:#1}}
\newcommand{\rprop}[1]{Proposition~\ref{p:#1}}
%%%%%%%%%%%
\newcommand{\BA}{\begin{array}}
\newcommand{\EA}{\end{array}}
\newcommand{\BAN}{\renewcommand{\arraystretch}{1.2}
\setlength{\arraycolsep}{2pt}\begin{array}}
\newcommand{\BAV}[2]{\renewcommand{\arraystretch}{#1}
\setlength{\arraycolsep}{#2}\begin{array}}
%Note: The first variable gives the amount of stretching:
%(#1) x default.
%For instance #1=1.2 means a 20% stretching.
%The second variable should be
%written for instance in the form  4pt ; here the default is 5pt
%\newcommand{\EAN}{\end{array}\setlength{\arraycolsep}{5pt}}
\newcommand{\BSA}{\begin{subarray}}
\newcommand{\ESA}{\end{subarray}}	
%Note: These are used in subscripts as well as superscripts.
%They work essentially like 'array'.

\newcommand{\BAL}{\begin{aligned}}
	\newcommand{\EAL}{\end{aligned}}
\newcommand{\BALG}{\begin{alignat}}
	\newcommand{\EALG}{\end{alignat}}
%% the abbrev. does not work with latex2e
\newcommand{\BALGN}{\begin{alignat*}}
	\newcommand{\EALGN}{\end{alignat*}}
%% the abbrev. does not work with latex2e
%% The 'aligned' environment must be placed inside an 'equation' env.
%% in the same way as the array.
%% One could use also the 'align' env. or the 'alignat' env.
%% However in this case each line is numbered, unless '\notag' is used.
%% The 'alignat'
%% has a slightly different format (the number of columns must be %%specified in advance)
%% but it has the advantage that the distance between columns
%%is at our disposition.
%% (The default would be zero distance.) Using 'alignat*' we can have %%the advantages
%% of alignat plus the situation where separate lines are not numbered.
%% However in this case there is no numbering at all
%%(unless we provide a tag).
%%%%%%%%%%
%% PROOF, REMARK etc.
\newcommand{\note}[1]{\noindent\textit{#1.}\hspace{2mm}}
\newcommand{\Proof}{\note{Proof}}
%\newcommand{\qed}{\hspace{10mm}\hfill $\square$}
%\newcommand{\qed}{\\${}$ \hfill $\square$}
\newcommand{\Remark}{\note{Remark}}
%%%%%%%% Style command.
\newcommand{\modin}{$\,$\\[-4mm] \indent}
%% To be used after \section in order to start new line with \indent.
%%%%%%%%%%%%
%% MATHEMATICAL symbols
\newcommand{\forevery}{\quad \forall}
\newcommand{\set}[1]{\{#1\}}
\newcommand{\setdef}[2]{\{\,#1:\,#2\,\}}
\newcommand{\setm}[2]{\{\,#1\mid #2\,\}}
%% Arrows
\newcommand{\mt}{\mapsto}
\newcommand{\lra}{\longrightarrow}
\newcommand{\lla}{\longleftarrow}
\newcommand{\llra}{\longleftrightarrow}
\newcommand{\Lra}{\Longrightarrow}
\newcommand{\Lla}{\Longleftarrow}
\newcommand{\Llra}{\Longleftrightarrow}
\newcommand{\warrow}{\rightharpoonup}

%% Brackets, delimiters
\newcommand{\paran}[1]{\left (#1 \right )}
%% adjustable parantheses
\newcommand{\sqbr}[1]{\left [#1 \right ]}
%% adjustable square brackets
\newcommand{\curlybr}[1]{\left \{#1 \right \}}
%% adjustable curly brackets
\newcommand{\abs}[1]{\left |#1\right |}

%% adjustable vertical delimiters
\newcommand{\norm}[1]{\left \|#1\right \|}

%% adjustable norm
\newcommand{\paranb}[1]{\big (#1 \big )}

%% non-adjustable parantheses (big)
\newcommand{\lsqbrb}[1]{\big [#1 \big ]}

%% non-adjustable square brackets (big)
\newcommand{\lcurlybrb}[1]{\big \{#1 \big \}}

%% non-adjustable curly brackets(big)
\newcommand{\absb}[1]{\big |#1\big |}

%% non-adjustable vertical delimiters(big)
\newcommand{\normb}[1]{\big \|#1\big \|}

%% non-adjustable norm (big)
\newcommand{	\paranB}[1]{\Big (#1 \Big )}

%% non-adjustable parantheses (Big)
\newcommand{\absB}[1]{\Big |#1\Big |}

%% non-adjustable vertical delimiters(Big)
\newcommand{\normB}[1]{\Big \|#1\Big \|}%% non-adjustable norm (Big)
\newcommand{\produal}[1]{\langle #1 \rangle}%% the pairing of X' and X
%%%%%%%%%%%%%%%%%
%% Adjustable parantheses etc. in a different DEFINITION format.
%\def\adp(#1){\left (#1 \right )}%% adjustable parantheses
%\def\adsb(#1){\left [#1\right ]}%% adjustable square brackets
%\def\adcb(#1){\left \{#1\right \}}%% adjustable curly brackets
%\def\abs|#1|{\left |#1\right |}%% adjustable vertical delimiters
%%%%%%%%%%%%%%%%
%% More mathematical symbols
\newcommand{\thkl}{\rule[-.5mm]{.3mm}{3mm}}
\newcommand{\thknorm}[1]{\thkl #1 \thkl\,}
\newcommand{\trinorm}[1]{|\!|\!| #1 |\!|\!|\,}
\newcommand{\bang}[1]{\langle #1 \rangle}%% angle bracket
\def\angb<#1>{\langle #1 \rangle}%% angle bracket
%% The two last lines yield the same result.
%% The second is used as follows: \angb<a,b>
\newcommand{\vstrut}[1]{\rule{0mm}{#1}}
\newcommand{\rec}[1]{\frac{1}{#1}}
%% OPERATOR names.
%% OPERATOR names.
\newcommand{\opname}[1]{\mbox{\rm #1}\,}
\newcommand{\supp}{\opname{supp}}
\newcommand{\dist}{\opname{dist}}
\newcommand{\myfrac}[2]{{\displaystyle \frac{#1}{#2} }}
\newcommand{\myint}[2]{{\displaystyle \int_{#1}^{#2}}}
\newcommand{\mysum}[2]{{\displaystyle \sum_{#1}^{#2}}}
\newcommand {\dint}{{\displaystyle \myint\!\!\myint}}%%%%%%%%%%
%%%%%%% SPACE commands
\newcommand{\q}{\quad}
\newcommand{\qq}{\qquad}
\newcommand{\hsp}[1]{\hspace{#1mm}}
\newcommand{\vsp}[1]{\vspace{#1mm}}
%%%%%%%%%%%
%% ABREVIATIONS
\newcommand{\ity}{\infty}
\newcommand{\prt}{\partial}
\newcommand{\sms}{\setminus}
\newcommand{\ems}{\emptyset}
\newcommand{\ti}{\times}
\newcommand{\pr}{^\prime}
\newcommand{\ppr}{^{\prime\prime}}
\newcommand{\tl}{\tilde}
\newcommand{\sbs}{\subset}
\newcommand{\sbeq}{\subseteq}
\newcommand{\nind}{\noindent}
\newcommand{\ind}{\indent}
\newcommand{\ovl}{\overline}
\newcommand{\unl}{\underline}
\newcommand{\nin}{\not\in}
\newcommand{\pfrac}[2]{\genfrac{(}{)}{}{}{#1}{#2}}

%% frac with parantheses.
%%%%%%%%%%%
%%%%%%%%%%%%%

%%Macros for Greek letters.
\def\ga{\alpha}     \def\gb{\beta}       \def\gg{\gamma}
\def\gc{\chi}       \def\gd{\delta}      \def\gep{\epsilon}
\def\gth{\theta}                         \def\vge{\varepsilon}
\def\gf{\varphi}       \def\vgf{\varphi}    \def\gh{\eta}
\def\gi{\iota}      \def\gk{\kappa}      \def\gl{\lambda}
\def\gm{\mu}        \def\gn{\nu}         \def\gp{\pi}
\def\vgp{\varpi}    \def\gr{\gd}        \def\vgr{\varrho}
\def\gs{\sigma}     \def\vgs{\varsigma}  \def\gt{\tau}
\def\gu{\upsilon}   \def\gv{\vartheta}   \def\gw{\omega}
\def\gx{\xi}        \def\gy{\psi}        \def\gz{\zeta}
\def\Gg{\Gamma}     \def\Gd{\Delta}      \def\Gf{\Phi}
\def\Gth{\Theta}
\def\Gl{\Lambda}    \def\Gs{\Sigma}      \def\Gp{\Pi}
\def\Gw{\Omega}     \def\Gx{\Xi}         \def\Gy{\Psi}

%%Macros for calligraphic letters.
\def\CS{{\mathcal S}}   \def\CM{{\mathcal M}}   \def\CN{{\mathcal N}}
\def\CR{{\mathcal R}}   \def\CO{{\mathcal O}}   \def\CP{{\mathcal P}}
\def\CA{{\mathcal A}}   \def\CB{{\mathcal B}}   \def\CC{{\mathcal C}}
\def\CD{{\mathcal D}}   \def\CE{{\mathcal E}}   \def\CF{{\mathcal F}}
\def\CG{{\mathcal G}}   \def\CH{{\mathcal H}}   \def\CI{{\mathcal I}}
\def\CJ{{\mathcal J}}   \def\CK{{\mathcal K}}   \def\CL{{\mathcal L}}
\def\CT{{\mathcal T}}   \def\CU{{\mathcal U}}   \def\CV{{\mathcal V}}
\def\CZ{{\mathcal Z}}   \def\CX{{\mathcal X}}   \def\CY{{\mathcal Y}}
\def\CW{{\mathcal W}} \def\CQ{{\mathcal Q}}
%%%%%
%%Macros for 'blackboard' letters (See (27) for display.)
\def\BBA {\mathbb A}   \def\BBb {\mathbb B}    \def\BBC {\mathbb C}
\def\BBD {\mathbb D}   \def\BBE {\mathbb E}    \def\BBF {\mathbb F}
\def\BBG {\mathbb G}   \def\BBH {\mathbb H}    \def\BBI {\mathbb I}
\def\BBJ {\mathbb J}   \def\BBK {\mathbb K}    \def\BBL {\mathbb L}
\def\BBM {\mathbb M}   \def\BBN {\mathbb N}    \def\BBO {\mathbb O}
\def\BBP {\mathbb P}   \def\BBR {\mathbb R}    \def\BBS {\mathbb S}
\def\BBT {\mathbb T}   \def\BBU {\mathbb U}    \def\BBV {\mathbb V}
\def\BBW {\mathbb W}   \def\BBX {\mathbb X}    \def\BBY {\mathbb Y}
\def\BBZ {\mathbb Z}

%%Macros for Ghotic (Fraktur) letters.
\def\GTA {\mathfrak A}   \def\GTB {\mathfrak B}    \def\GTC {\mathfrak C}
\def\GTD {\mathfrak D}   \def\GTE {\mathfrak E}    \def\GTF {\mathfrak F}
\def\GTG {\mathfrak G}   \def\GTH {\mathfrak H}    \def\GTI {\mathfrak I}
\def\GTJ {\mathfrak J}   \def\GTK {\mathfrak K}    \def\GTL {\mathfrak L}
\def\GTM {\mathfrak M}   \def\GTN {\mathfrak N}    \def\GTO {\mathfrak O}
\def\GTP {\mathfrak P}   \def\GTR {\mathfrak R}    \def\GTS {\mathfrak S}
\def\GTT {\mathfrak T}   \def\GTU {\mathfrak U}    \def\GTV {\mathfrak V}
\def\GTW {\mathfrak W}   \def\GTX {\mathfrak X}    \def\GTY {\mathfrak Y}
\def\GTZ {\mathfrak Z}   \def\GTQ {\mathfrak Q}
\def\sign{\mathrm{sign\,}}
\def\bdw{\prt\Gw\xspace}
\def\nabu{|\nabla u|}
\def\tr{\mathrm{tr\,}}
\def\gap{{\ga_+}}
\def\gan{{\ga_-}}

\def\N{\mathbb{N}}
\def\Z{\mathbb{Z}}
\def\Q{\mathbb{Q}}
\def\R{\mathbb{R}}


\def\Proof.{{\bf{Proof. }}}
\def\End{\hspace{1cm} $\Box$\\}


\renewcommand{\baselinestretch}{1.1}

\let\e=\varepsilon
\let\vp=\varphi
\let\t=\tilde
\let\ol=\overline
\let\ul=\underline
\let\.=\cdot
\let\0=\emptyset
\let\mc=\mathcal
\def\ex{\exists\;}
\def\fa{\forall\;}
\def\se{\ \Leftarrow\ }
\def\solose{\ \Rightarrow\ }
\def\sse{\ \Leftrightarrow\ }
\def\meno{\,\backslash\,}
\def\pp{,\dots,}
\def\D{\mc{D}}
\def\O{\Omega}


\def\loc{\text{\rm loc}}
\def\diam{\text{\rm diam}}
\def\dist{\text{\rm dist}}
\def\dv{\text{\rm div}}
\def\sign{\text{\rm sign}}
\def\supp{\text{\rm supp}}
\def\tr{\text{\rm Tr}}
\def\vec{\text{\rm vec}}
\def\inter{\text{\rm int\,}}
\def\norma#1{\|#1\|_\infty}

\newcommand{\esssup}{\mathop{\rm ess{\,}sup}}
\newcommand{\essinf}{\mathop{\rm ess{\,}inf}}
\newcommand{\su}[2]{\genfrac{}{}{0pt}{}{#1}{#2}}

\def\eq#1{{\rm(\ref{eq:#1})}}
\def\thm#1{Theorem \ref{thm:#1}}
\def\seq#1{(#1_n)_{n\in\N}}
\def\limn{\lim_{n\to\infty}}


\def\PP{\mc{P}}
\def\pe{principal eigenvalue}
\def\MP{maximum principle}
\def\SMP{strong maximum principle}
\def\l{\lambda_1}

\def\bq{\begin{equation}}
\def\eq{\end{equation}}

\def\l{\label}

\newenvironment{formula}[1]{\begin{equation}\label{eq:#1}}	{\end{equation}\noindent}

\title{Notes $\star$ Analyse Num\'erique - Part II: Implementation of the Finite Elements $\star$ Finite-Element Calculation}
\author{Nguyen Quan Ba Hong\footnote{Master 2 student at UFR math\'ematiques, Universit\'e de Rennes 1, Beaulieu - B\^atiment 22 et 23, 263 avenue du G\'en\'eral Leclerc, 35042 Rennes CEDEX, France.\newline
E-mail: \texttt{nguyenquanbahong@gmail.com} \newline
Blog: \texttt{\url{www.nguyenquanbahong.com}} \newline 
Copyright \copyright\ 2016-2018 by Nguyen Quan Ba Hong. This document may be copied freely for the purposes of education and non-commercial research. Visit my site to get more.}}
\begin{document}
\maketitle
\begin{abstract}
This context includes the materials given in the course \textit{Finite Element Method} in the Master 2 Fundamental Mathematics program 2018-2019, with my \textsc{Matlab} scripts provided.
\end{abstract}
%\textbf{Mathematics Subject Classification (2010):} 
%
%\noindent
%\textbf{Keywords:} \emph{}
\maketitle
\textbf{Brief introduction.} ``This lecture is a numerical counterpart to \textit{Sobolev spaces \& elliptic equations}. In the first part, after some reminders on linear elliptic partial differential equations, the approximation of the associated solutions by the finite element methods is investigated. Their construction \& their analysis are described in one \& two dimensions. The second part of the lectures consists in defining a generic strategy for the implementation of the method based on the variational formulation. A program is written in \textsc{Matlab} (implementable with \textsc{Matlab} or \textsc{Octave}).''
\newpage
\tableofcontents
\newpage

\section{Mathematical Framework}
We consider the elliptic problem of order 2, written in variational form
\begin{align}
\forall v \in V, \hspace{2mm} a\left( {u,v} \right) = l\left( v \right).
\end{align}
The bilinear form $a$ \& the linear form $l$ involve integrals of the form
\begin{align}
\int_\Omega  {\alpha \left( x \right)A\left( {u\left( x \right),Du\left( x \right)} \right)B\left( {v\left( x \right),Dv\left( x \right)} \right)dx} \mbox{ or } \int_\Omega  {\alpha \left( x \right)F\left( {v\left( x \right),Dv\left( x \right)} \right)dx} ,
\end{align}
(some integrals on the boundary $\partial \Omega$ may also be involved) where $A$, $B$, \& $F$ are linear operators. For example, the Laplace problem $-\Delta u = f$ leads to
\begin{align}
\int_\Omega  {{A_1}\left( {u,Du} \right){B_1}\left( {v,Dv} \right)}  + \int_\Omega  {{A_2}\left( {u,Du} \right){B_2}\left( {v,Dv} \right)}  = \int_\Omega  {\alpha F\left( {v,Dv} \right)} ,
\end{align}
with
\begin{itemize}
\item ${A_1}\left( {w\left( x \right),Dw\left( x \right)} \right) = {B_1}\left( {w\left( x \right),Dw\left( x \right)} \right) = {\partial _{{x_1}}}w\left( x \right)$,
\item ${A_2}\left( {w\left( x \right),Dw\left( x \right)} \right) = {B_2}\left( {w\left( x \right),Dw\left( x \right)} \right) = {\partial _{{x_2}}}w\left( x \right)$,
\item $\alpha \left( x \right) = f\left( x \right)$,
\item $F\left( {w\left( x \right),Dw\left( x \right)} \right) = w\left( x \right)$.
\end{itemize}
On a practical point of view, if $\left(\varphi _1,\ldots,\varphi _N\right)$ is a basis of the discrete space of approximation $V_h$, we have to calculate the quantities
\begin{align}
\int_\Omega  {\alpha \left( x \right)A\left( {{\varphi _J}\left( x \right),D{\varphi _J}\left( x \right)} \right)B\left( {{\varphi _I}\left( x \right),D{\varphi _I}\left( x \right)} \right)dx} \mbox{ or } \int_\Omega  {\alpha \left( x \right)F\left( {{\varphi _I}\left( x \right),D{\varphi _I}\left( x \right)} \right)dx} .
\end{align}
To this aim, we split the integrals on the elements of the triangulation: for the first one
\begin{align}
\sum\limits_{K \in {T_h}} {\int_K {\alpha \left( x \right)A\left( {{\varphi _J}\left( x \right),D{\varphi _J}\left( x \right)} \right)B\left( {{\varphi _I}\left( x \right),D{\varphi _I}\left( x \right)} \right)dx} } ,
\end{align}
\& each integral on one element $K$ is changed to an integral on the reference element $\widehat{K}$ by a change of variable $x = {F_K}\left( {\widehat x} \right)$.

\section{Quadrature Formulas}
The calculation of an integral over the reference element is defined by a quadrature formula
\begin{align}
\int_{\widehat K} {f\left( {\widehat x} \right)d\widehat x}  = \sum\limits_{q = 0}^Q {{w_q}f\left( {{{\widehat x}_q}} \right)} .
\end{align}
The point ${\widehat x}_q$ \& the weights $w_q$ are given once at the beginning of the finite-element procedure. We give here, as an example, a nodal formula which is exact for $\mathbb{P}_1$ functions, \& a nodal formula exact for $\mathbb{P}_3$ functions using the node of a $\mathbb{P}_2$ interpolation plus the iso-barycenter of the triangle, i.e.,
\begin{align}
\label{2.2}
\int_{\widehat K} {f\left( {\widehat x} \right)d\widehat x}  =&\ \frac{1}{6}\left( {f\left( {0,0} \right) + f\left( {1,0} \right) + f\left( {0,1} \right)} \right),\hspace{2mm}\forall f \in {\mathbb{P}_1}\left( {\widehat K} \right),\\
\int_{\widehat K} {f\left( {\widehat x} \right)d\widehat x}  =&\ \frac{1}{{40}}\left( {f\left( {0,0} \right) + f\left( {1,0} \right) + f\left( {0,1} \right)} \right) \nonumber\\
& + \frac{1}{{15}}\left( {f\left( {\frac{1}{2},0} \right) + f\left( {\frac{1}{2},\frac{1}{2}} \right) + f\left( {0,\frac{1}{2}} \right)} \right) + \frac{9}{{40}}f\left( {\frac{1}{3},\frac{1}{3}} \right),\hspace{2mm} \forall f \in {\mathbb{P}_2}\left( {\widehat K} \right). \label{2.3}
\end{align}

\begin{prob}
Write a \textsc{Matlab} function which defines the two quadrature formulas. Its head is 
\begin{verbatim}
function [points, weights] = quadrature(number)
\end{verbatim}
where the entry \verb|number| is an arbitrary number used to reference the requested formula. The output vectors are respectively of size $\left(Q+1\right) \times 2$ \& $\left(Q+1\right) \times 1$.
\end{prob}

\begin{proof}[Solution]
It is straightforward to carry out the (nodal) quadrature formulas defined by \eqref{2.2} and \eqref{2.3}, see Sec. \ref{sec8.1}.
\end{proof}
We also give a \textsc{Matlab} script which defines some Gaussian quadrature formulas. The high precision of these formulas will help us approximate the finite-element right hand side vector (in the assembling procedures) better.
\section{Basis Functions}
For the elementary calculation, we use only the basis functions of the reference element. The basis functions are then defined on the effective element $K$ thanks to the geometric function $F_K$.
\begin{prob}
Write a \textsc{Matlab} function which evaluates the nodal basis functions $\mathbb{P}_k$ ($k=1,2$) of the reference element at a given point:
\begin{verbatim}
function [vals, dervals] = shape_fcts(xh, k)
\end{verbatim}
The entries are \verb|xh|, the point where we want to evaluate the functions, and \verb|k|, degree of the finite element. The output is a table \verb|vals| of the values of the basis functions at \verb|xh| (table of size $NbRefNodes \times 1$, in the order of the local numbering of the reference element, where $NbRefNodes$ denotes the number of nodes on the reference element), \& the table \verb|dervals| of the values of the corresponding derivatives in both directions (table of size $NbRefNodes \times 2$).
\end{prob}

\begin{proof}[Solution]
The nodal basis functions $\mathbb{P}_1$ of the reference element are given by ${\widehat \lambda _1}\left( {\widehat x} \right) = {\widehat x_1}$, ${\widehat \lambda _2}\left( {\widehat x} \right) = {\widehat x_2}$, ${\widehat \lambda _3}\left( {\widehat x} \right) = 1 - {\widehat x_1} - {\widehat x_2}$ and the nodal basis functions basis functions $\mathbb{P}_2$ of the reference element are given by ${\widehat \varphi _i} = {\widehat \lambda _i}\left( {2{{\widehat \lambda }_i} - 1} \right)$ and ${\widehat \varphi _{i + 3}} = 4{\widehat \lambda _i}{\widehat \lambda _{i + \bmod \left( {i,3} \right)}}$, for all $i = 1,2,3$. It is straightforward to evaluate these nodal basis functions and their gradients, see Sec. \ref{sec8.3}. 
\end{proof}

\section{Geometric Calculation}
The elementary integrals require the evaluation of the quantities ${\varphi _I}\left( x \right)$ \& ${\partial _{{x_l}}}{\varphi _I}\left( x \right)$. They are expressed from the finite-element interpolation basis functions of the reference element, \& the geometric function $x = {F_K}\left( {\widehat x} \right)$. If the vertex $i$ of the effective element $K$ has the global number $I$, we have the relations
\begin{itemize}
\item ${\varphi _I}\left( x \right) = \widehat {{\varphi _i}}\left( {\widehat x} \right)$, 
\item ${\partial _{{x_l}}}{\varphi _I}\left( x \right) = \sum\limits_{k = 1}^2 {{\partial _{{{\widehat x}_k}}}\widehat {{\varphi _i}}\left( {\widehat x} \right){{\left[ {J{F_K}{{\left( {\widehat x} \right)}^{ - 1}}} \right]}_{k,l}}}$, or equivalently ${\nabla _x}{\varphi _I}\left( x \right) = J{F_K}{\left( {\widehat x} \right)^{ - T}}{\nabla _{\widehat x}}\widehat {{\varphi _i}}\left( {\widehat x} \right)$.
\end{itemize}
Moreover, the Jacobian matrix of the geometric function $F_K$ is evaluated thanks to the geometric basis functions (= shape functions) ${\widehat \psi _i}$:
\begin{align}
\label{4.1}
{\left[ {J{F_K}\left( {\widehat x} \right)} \right]_{k,l}} = \sum\limits_{i = 1}^{{n_{\rm geo}}} {{{\left( {{V_i}} \right)}_k}{\partial _{{{\widehat x}_l}}}\widehat {{\psi _i}}\left( {\widehat x} \right)} ,
\end{align}
where $V_i$ are the nodes (the vertices in $\mathbb{P}_1$) of the effective element $K$.
\begin{prob}
Write a \textsc{Matlab} function which evaluates the Jacobian matrix of the geometric function ${F_K}\left( {\widehat x} \right)$ at the point $\widehat x$:
\begin{verbatim}
function jacob = compute_jacobian(vertices, dervals_psi)
\end{verbatim}
The entries are the coordinates of the nodes \verb|vertices| \& the values \verb|dervals_psi| of the derivatives of the geometric basis functions at the point $\widehat x$.
\end{prob}

\begin{proof}[Solution]
It is straightforward to carry out \eqref{4.1} into a script, see Sec. \ref{sec8.4}.
\end{proof}

\section{Assembling Procedure}
The assembling procedure consists in the calculation of a matrix of the form
\begin{align}
\int_\Omega  {\alpha \left( x \right)A\left( {{\varphi _J}\left( x \right),D{\varphi _J}\left( x \right)} \right)B\left( {{\varphi _I}\left( x \right),D{\varphi _I}\left( x \right)} \right)dx} ,
\end{align}
by a summation of all the elementary contributions. The scheme of this procedure is the following: 
\begin{verbatim}
Loop on the elements of the mesh
   Loop on the quadrature points
      Geometric calculation at point xq.
      Loop on the nodes i of the element K
         I = global number of i
         Loop on the nodes j of the element K
            J = global number of j 
            A(I,J) = A(I,J) + contribution of (i,j) at xq      
         end
      end
   end
end
\end{verbatim}

\begin{prob}
Write a \textsc{Matlab} function which assemblies the finite-element matrix. Its head is 
\begin{verbatim}
function A = assemble_matrix(str_integrand_unknown, str_integrand_test, 
                             ... str_cofvar, mesh_geo, degree_FE, number)
\end{verbatim}
The entries are:
\begin{itemize}
\item \verb|str_integrand_unknown|, \verb|str_integrand_test|: character strings identifying the operators $A$ and $B$ (see function \verb|diff_op.m| in annex),
\item \verb|str_cofvar|: character string identifying the function $\alpha \left(x\right)$,
\item \verb|mesh_geo|: mesh structure defining the geometry,
\item \verb|degree_FE|: degree of the finite-element interpolation,
\item \verb|number|: identification number of the quadrature formula.
\end{itemize}
A function \verb|assemble_vector| will be written for the calculation of the finite-element right hand side, on the same model.
\end{prob}

\begin{proof}[Solution]
See Sec. \ref{sec8.5} and \ref{sec8.6}.
\end{proof}
\section{Essential Conditions (Optional)}
To take in consideration the essential conditions (Dirichlet) one requires the identification of the nodes (or edges) of the boundary of the domain where the condition is imposed.

\begin{prob}
Using the function \verb|build_edge_connectivity| from the mesh-design exercises, build the set of edges defining the subdomain $\partial \Omega$.
\end{prob}

\begin{proof}
See Sec. \ref{sec8.7} and \ref{sec8.8}.
\end{proof}

\begin{prob}
Write a procedure \emph{elimination}, which consists of - for a given node $I$ on the Dirichlet boundary - vanishing the $I^{\rm th}$ component of the right hand side and all the entries of the $I^{\rm th}$ line of the matrix except the diagonal one. You may choose the head function
\begin{verbatim}
function [Aout, Bout] = Dirichlet_elimination(Ain, Bin, boundary_nodes)
\end{verbatim}
The table entry \verb|boundary_nodes| contains the global numbers of the nodes on the Dirichlet boundary.
\end{prob}

\section{Resolution and Post-Treatment}
For the resolution and the post-treatment, you may use the following \textsc{Matlab} functions
\begin{itemize}
\item \verb|A\b| to solve the linear system $Ax=b$,
\item \verb|trisurf(triangles, coords(:,1), coords(:,2), X)|; to plot the solution $X$ at the node of the mesh.
\end{itemize}


\section{Appendices: MATLAB Scripts}
\subsection{Nodal Quadrature Formulas}\label{sec8.1}
The following \textsc{Matlab} script is used to define the two (nodal) quadrature formulas given by \eqref{2.2}-\eqref{2.3}. These quadrature formulas are used to calculate an integral over the reference element.
\begin{verbatim}
function [points, weights] = quadrature(number)
% Define the following two quadrature formulas to calculate an integral over
% the reference element
% number = 1: a nodal formula which is exact for all P_1 functions
% number = 2: a nodal formula which is exact for all P_3 functions by using
% the nodes of a P_2 interpolation plus the iso-barycenter of the triangle
% Author: Nguyen Quan Ba Hong
% Date: 12/10/2018
% Last Update: 12/10/2018
% Input:
% + number: take values 1 or 2, indicate which nodal formula will be used
% Outputs:
% + points: corresponding nodes in the reference element used for
% the nodal formula chosen
% + weights: corresponding weights used for the nodal formula chosen

if (number == 1) % P_1 Quadrature Formula
    points = [1,0; 0,1; 0,0]; % Nodes
    weights = [1/6; 1/6; 1/6]; % Weights
elseif (number == 2) % P_3 Quadrature Formula
    points = [0,0; 1,0; 0,1; .5,0; .5,.5; 0,.5; 1/3,1/3]; % Nodes
    weights = [1/40; 1/40; 1/40; 1/15; 1/15; 1/15; 9/40]; % Weights
else
    disp('Invalid Input');
end
\end{verbatim}

\subsection{Gaussian Quadrature Formulas}\label{sec8.2}
The following \textsc{Matlab} script is used to define some Gaussian quadrature formulas.
\begin{verbatim}
function [points, weights] = Gaussian_quadrature(number)
% Define some Gaussian quadrature formulas to calculate an integral over
% the reference triangle
% Author: Nguyen Quan Ba Hong
% Date: 7/11/2018
% Last Update: 7/11/2018
% Input:
% + number: take values 1, 2, 3 or 4, indicate which Gaussian quadrature
% formula will be used
% Outputs:
% + points: the corresponding Gaussian quadrature nodes in the reference
% element used for the Gaussian quadrature formula chosen
% + weights: the corresponding Gaussian quadrature weights used for the
% Gaussian quadrature formula chosen

switch number
    case 1
        weights = 1;
        points = [1/3 1/3];
    case 2
        weights = [1/3 1/3 1/3];
        points = [1/6 1/6;
            2/3 1/6;
            1/6 2/3];
    case 3
        weights = [-27/48 25/48 25/48 25/48];
        points = [1/3 1/3;
            0.2 0.2;
            0.6 0.2;
            0.2 0.6];
    case 4
        weights = [0.223381589678011
            0.223381589678011
            0.223381589678011
            0.109951743655322
            0.109951743655322
            0.109951743655322];
        points = [0.445948490915965 0.445948490915965;
            0.445948490915965 0.108103018168070;
            0.108103018168070 0.445948490915965;
            0.091576213509771 0.091576213509771;
            0.091576213509771 0.816847572980459;
            0.816847572980459 0.091576213509771];
    otherwise
        error('Invalid Input')
end
\end{verbatim}

\subsection{Evaluate Nodal Basic Functions}\label{sec8.3}
The following \textsc{Matlab} script is used to evaluate the values and the derivatives of the nodal basis functions $\mathbb{P}_k$ ($k=1,2$) of the reference element $\widehat{K}$ at a given point.
\begin{verbatim}
function [vals, dervals] = shape_fcts(xh,k)
% Evaluate the nodal basis functions P_k (k = 1,2) of the reference element
% at a given point
% Author: Nguyen Quan Ba Hong
% Date: 12/10/2018
% Last Update: 12/10/2018
% Inputs:
% + xh: the point where we want to evaluate the functions
% + k: the degree of the finite element, k = 1 or 2
% Outputs:
% + vals: a table of the values of the basis functions at the point xh, size:
% NbRefNodes x 1
% + dervals: a table of the values of the corresponding derivatives in both
% directions, size: NbRefNodes x 2

if (k == 1) % First-Order Finite Element
    vals = [xh(1); xh(2); 1 - xh(1) - xh(2)]; % Values of Nodal Basis Functions P_1
    dervals = [1,0; 0,1; -1,-1]; % Derivatives of Nodal Basis Function P_1
elseif (k == 2) % Second-Order Finite Element
    [a, b] = shape_fcts(xh, 1); % Reuse the Nodal Basis Functions P_1
    vals = a.*(2*a - 1); % First 3 Nodal Basis Functions P_2
    % Add 3 Nodal Basis Functions P_2
    vals = [vals; 4*a(1)*a(2); 4*a(2)*a(3); 4*a(3)*a(1)];
    % Derivatives of Nodal Basis Functions P_2
    dervals = [(4*a(1) - 1)*b(1,:); (4*a(2) - 1)*b(2,:);
        (4*a(3) - 1)*b(3,:); 4*(a(2)*b(1,:) + a(1)*b(2,:));
        4*(a(2)*b(3,:) + a(3)*b(2,:)); 4*(a(3)*b(1,:) + a(1)*b(3,:))];
else
    disp('Invalid Input');
end
\end{verbatim}

\subsection{Jacobian Matrix of the Geometric Function}\label{sec8.4}
The following \textsc{Matlab} script is used to evaluate the Jacobian matrix of the geometric function $F_K\left(\widehat{\bf x}\right)$ at the point $\widehat{\bf x}$.
\begin{verbatim}
function jacob = compute_jacobian(vertices, dervals_psi)
% Evaluate the Jacobian matrix of the geometric function at a given point
% Author: Nguyen Quan Ba Hong
% Date: 15/10/2018
% Last Update: 15/10/2018
% Inputs:
% + vertices: the coordinates of the main (in P_1) nodes of a triangle, size: 3x2
% + dervals_psi: the values of the derivatives of the geometric basis
% functions at the point hat(x)
% Output:
% + jacob: the value of Jacobian matrix of the geometric function F_K(hat(x))
% at the given point hat(x)

jacob = zeros(2); % Initialize
for k = 1:2
    for l = 1:2
        jacob(k,l) = dot(vertices(:,k), dervals_psi(:,l));
    end
end
\end{verbatim}

\subsection{Assembly the Finite-Element Matrix}\label{sec8.5}
The following \textsc{Matlab} script is used to assembly the finite-element matrix.
\begin{verbatim}
function A = assemble_matrix(str_integrand_unknown, str_integrand_test, ...
    str_cofvar, mesh_geo, degree_FE, number)
% Assembly the finite-element matrix
% Author: Nguyen Quan Ba Hong
% Date: 15/10/2018
% Last Update: 6/11/2018
% Inputs:
% + str_integrand_unknown, str_integrand_test: character strings
% identifying the operators A & B (see function diff_op.m)
% + str_cofvar: character string identifying the function alpha(x)
% + mesh_geo: a mesh structure defining the geometry, if degree_FE = 1,
% this mesh structure must be a P_1 mesh structure, if degree_FE = 2, it
% must be modified into a P_2 mesh structure, before running this script
% + degree_FE: degree of the finite-element interpolation
% + number: identification number of the quadrature formula
% Output:
% + A: the assembled finite-element matrix

%% Points & Weights of Quadrature Formulas for the Reference Element
[points, weights] = quadrature(number); % Nodal Quadrature Formulas
% [points, weights] = Gausspoints(2); % Gaussian Quadrature Formulas

%% Main Loops
A = zeros(size(mesh_geo.coords,1)); % Initialzie
for K = 1:size(mesh_geo.triangles,1) % Loop on All Triangles of the Mesh Given
    % Coordinates of the Vertices of the K-th Triangle in the Mesh
    % the Vertices in P_K of this Triangle
    vertices = mesh_geo.coords(mesh_geo.triangles(K,:),:);
    % the Vertices in P_1 of this Triangle
    main_vertices = vertices([1,2,3],:);
    for q = 1:size(points,1) % Loop on All Quadrature Points
        % Evaluate the Nodal Basis Functions of the Reference Element at
        % the Quadrature Points
        [vals_hatphi, dervals_hatphi] = shape_fcts(points(q,:), degree_FE);
        % Evaluate the Geometric Basis Functions at the Quadrature Points
        [vals_hatpsi, dervals_hatpsi] = shape_fcts(points(q,:), 1); %P_1 Isoparametric
        % Evaluate the Geometric Function at the Quadrature Point
        geo_func = [dot(vals_hatpsi, main_vertices(:,1)), ...
            dot(vals_hatpsi, main_vertices(:,2))];
        % Evaluate the Jacobian Matrix of the Geometric Function at the
        % Quadrature Point
        jacob = compute_jacobian(main_vertices, dervals_hatpsi);
        % Compute the Gradient of the Function phi(x)
        dervals_phi = dervals_hatphi/jacob;
        for i = 1:size(mesh_geo.triangles,2) % Loop on the Node i of the Element K
            % Global Index of the Node i of the Element K
            I = mesh_geo.triangles(K, i);
            for j = 1:size(mesh_geo.triangles,2) % Loop on the Node j of the Element K
                % Global Index of the Node j of the Element K
                J = mesh_geo.triangles(K, j);
                % Add Contribution of (i,j) at the Quadrature Points
                A(I,J) = A(I,J) + weights(q)*feval(str_cofvar, geo_func)*...
                    diff_op(str_integrand_unknown, vals_hatphi(j), dervals_phi(j,:))*...
                    diff_op(str_integrand_test, vals_hatphi(i), dervals_phi(i,:))...
                    *abs(det(jacob));
            end
        end
    end
end
\end{verbatim}

\subsection{Assemble the Finite-Element Right Hand Side Vector}\label{sec8.6}
The following \textsc{Matlab} script is used to assembly the finite-element right hand side vector.
\begin{verbatim}
function b = assemble_vector(str_integrand_test, str_cofvar, mesh_geo, degree_FE, number)
% Assembly the finite-element right hand side vector
% Author: Nguyen Quan Ba Hong
% Date: 15/10/2018
% Last Update: 6/11/2018
% Inputs:
% + str_integrand_test: character string identifying the operator B
% + str_cofvar: character string identifying the function alpha(x)
% + mesh_geo: a mesh structure defining the geometry, if degree_FE = 1,
% this mesh structure must be a P_1 mesh structure, if degree_FE = 2, it
% must be modified into a P_2 mesh structure, before running this script
% + degree_FE: degree of the finite-element interpolation
% + number: identification number of the quadrature formula
% Output:
% + assemble_vector: assembled finite-element RHS vector

%% Points & Weights of Quadrature Formulas for the Reference Element
[points, weights] = quadrature(number); % Nodal Quadrature Formulas
% [points, weights] = Gaussian_quadrature(4); % Gaussian Quadrature Fofmulas

%% Main Loops
b = zeros(size(mesh_geo.coords,1),1); % Initialize
for K = 1:size(mesh_geo.triangles,1) % Loop on All Triangles of the Mesh Given
    % Coordinates of Vertices of the K-th Triangle in the Mesh
    % the Vertices in P_K of this Triangle
    vertices = mesh_geo.coords(mesh_geo.triangles(K,:),:); 
    main_vertices = vertices([1,2,3],:); % the Vertices in P_1 of this Triangle
    for q = 1:size(points,1) % Loop on All Quadrature Points
        % Evaluate the Nodal Basis Functions of the Reference Element at 
        % the Quadrature Points
        [vals_hatphi, dervals_hatphi] = shape_fcts(points(q,:), degree_FE);
        % Evaluate the Geometric Basis Functions at the Quadrature Points
        [vals_hatpsi, dervals_hatpsi] = shape_fcts(points(q,:), 1); %P_1 Isoparametric
        % Evaluate the Geometric Function at the Quadrature Point
        geo_func = [dot(vals_hatpsi, main_vertices(:,1)), ...
            dot(vals_hatpsi, main_vertices(:,2))];
        % Evaluate the Jacobian Matrix of the Geometric Function at the 
        % Quadrature Point
        jacob = compute_jacobian(main_vertices, dervals_hatpsi);
        % Compute the Gradient of the Function phi(x)
        dervals_phi = dervals_hatphi/jacob;
        for i = 1:size(mesh_geo.triangles,2) % Loop on the Node i of the Element K
            % Global Index of the Node i of the Element K
            I = mesh_geo.triangles(K, i); 
            % Add Contribution of (i,j) at the Quadrature Point
            b(I) = b(I) + weights(q)*feval(str_cofvar, geo_func)*...
                diff_op(str_integrand_test, vals_hatphi(i), dervals_phi(i,:))...
                *abs(det(jacob));
        end
    end
end
\end{verbatim}

\subsection{Boundary Edges}\label{sec8.7}
The following \textsc{Matlab} script is used to build the set of edges defining the subdomain $\partial \Omega$.
\begin{verbatim}
function boundary_edges = boundary_edges(mesh)
% Build the set of edges defining the boundary of a given mesh
% Author: Nguyen Quan Ba Hong
% Date: 17/10/2018
% Last Update: 17/10/2018
% Input:
% + mesh: a P_1 mesh structure
% Output:
% + boundary_edges: the set of edges defining the boundary of the mesh
% given

%% Construct the Tables edges & edges_triangles of the Given Mesh
[edges, edges_triangles] = build_edge_connectivity(mesh);

%% Determine the Boundary of the Given Mesh
boundary_edges = []; % Initialize
for i = 1:size(edges,1) % Loop on All Edges of the Mesh Given
    if (size(edges_triangles{i},1) == 1) % This is a Boundary Edge
        % Store this Boundary Edge
        boundary_edges = [boundary_edges; edges(i,:)]; 
    end
end
\end{verbatim}

\subsection{Elimination Procedure for Dirichlet Boundary Conditions}\label{sec8.8}
The following \textsc{Matlab} script is used to carry out the Dirichlet elimination procedure.
\begin{verbatim}
function [Aout, Bout] = Dirichlet_elimination(Ain, Bin, boundary_nodes)
% An elimination procedure, which consists of - for a given node I on the
% Dirichlet boundary - vanishing the I-th component of the right hand side
% and all entries of the I-th line of the matrix except the diagonal one. 
% Author: Nguyen Quan Ba Hong
% Date: 17/10/2018
% Last Update: 17/10/2018
% Inputs:
% + Ain: the assembled matrix
% + Bin: the assembled vector
% + boundary_nodes: the table entry boundary_nodes contains the global
% numbers of the nodes on the Dirichlet boundary
% Outputs:
% + Aout: the assembled matrix after the Dirichlet elimination procedure
% + Bout: the assembled vector after the Dirichlet elimination procedure

for i = 1:size(boundary_nodes,1)
    % Vanish the i-th component of the right hand side
    Bin(i) = 0;
    % Vanish all the entries of the i-th line of the matrix except the diagonal one
    temp = Ain(i,i);
    Ain(i,:) = zeros(1,size(Ain,1)); % Vanish all entries of A(i,:)
    Ain(i,i) = temp; % Except the diagonal entry A(i,i)    
end
Aout = Ain;
Bout = Bin;
\end{verbatim}

\subsection{Differential Operators}\label{sec8.9}
We give here the source code of the function \verb|diff_op| which defines the differential operators involved in the variational formulation
\begin{verbatim}
function g = diff_op(type, u, Du)
% Differentiel operator
% Author: G.Vial
% Date: 16/09/2010
% Last update: 17/11/10
%
% usage: g = diff_op(type,u,Du)
%
% input:
% 	type : type of operator (string)
% 	u    : value of function (scalar)
% 	Du   : value of function derivative (1 by 2 array)
%
% output:
%	g : value of operator

switch (type)
   case 'Id'
      g=u;
   case 'D1'
      g=Du(1);
   case 'D2'
      g=Du(2);
   otherwise
      error(['Operator ',type,' not defined -- :-((( --'])
end
\end{verbatim}

\newpage
\begin{thebibliography}{999}
\bibitem {1} \url{https://perso.univ-rennes1.fr/eric.darrigrand-lacarrieu/Teaching/M2RFEorganisation.html}
\end{thebibliography}

%\section*{Appendix A. Supplementary notes}



%\section*{Acknowledgment}

\printbibliography
%\Addresses
\end{document}