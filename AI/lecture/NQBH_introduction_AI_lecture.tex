\documentclass{article}
\usepackage[backend=biber,natbib=true,style=alphabetic,maxbibnames=50]{biblatex}
\addbibresource{/home/nqbh/reference/bib.bib}
\usepackage[utf8]{vietnam}
\usepackage{tocloft}
\renewcommand{\cftsecleader}{\cftdotfill{\cftdotsep}}
\usepackage[colorlinks=true,linkcolor=blue,urlcolor=red,citecolor=magenta]{hyperref}
\usepackage{amsmath,amssymb,amsthm,enumitem,float,graphicx,mathtools,tikz}
\usetikzlibrary{angles,calc,intersections,matrix,patterns,quotes,shadings}
\allowdisplaybreaks
\newtheorem{assumption}{Assumption}
\newtheorem{baitoan}{Bài toán}
\newtheorem{cauhoi}{Câu hỏi}
\newtheorem{conjecture}{Conjecture}
\newtheorem{corollary}{Corollary}
\newtheorem{dangtoan}{Dạng toán}
\newtheorem{definition}{Definition}
\newtheorem{dinhly}{Định lý}
\newtheorem{dinhnghia}{Định nghĩa}
\newtheorem{example}{Example}
\newtheorem{ghichu}{Ghi chú}
\newtheorem{hequa}{Hệ quả}
\newtheorem{hypothesis}{Hypothesis}
\newtheorem{lemma}{Lemma}
\newtheorem{luuy}{Lưu ý}
\newtheorem{nhanxet}{Nhận xét}
\newtheorem{notation}{Notation}
\newtheorem{note}{Note}
\newtheorem{principle}{Principle}
\newtheorem{problem}{Problem}
\newtheorem{proposition}{Proposition}
\newtheorem{question}{Question}
\newtheorem{remark}{Remark}
\newtheorem{theorem}{Theorem}
\newtheorem{vidu}{Ví dụ}
\usepackage[left=1cm,right=1cm,top=5mm,bottom=5mm,footskip=4mm]{geometry}
\def\labelitemii{$\circ$}
\DeclareRobustCommand{\divby}{%
	\mathrel{\vbox{\baselineskip.65ex\lineskiplimit0pt\hbox{.}\hbox{.}\hbox{.}}}%
}
\setlist[itemize]{leftmargin=*}
\setlist[enumerate]{leftmargin=*}

\title{Lecture Note: Introduction to Artificial Intelligence\\Bài Giảng: Nhập Môn Trí Tuệ Nhân Tạo}
\author{Nguyễn Quản Bá Hồng\footnote{A scientist- {\it\&} creative artist wannabe, a mathematics {\it\&} computer science lecturer of Department of Artificial Intelligence {\it\&} Data Science (AIDS), School of Technology (SOT), UMT Trường Đại học Quản lý {\it\&} Công nghệ TP.HCM, Hồ Chí Minh City, Việt Nam.\\E-mail: {\sf nguyenquanbahong@gmail.com} {\it\&} {\sf hong.nguyenquanba@umt.edu.vn}. Website: \url{https://nqbh.github.io/}. GitHub: \url{https://github.com/NQBH}.}}
\date{\today}

\begin{document}
\maketitle
\begin{abstract}
	This text is a part of the series {\it Some Topics in Advanced STEM \& Beyond}:
	
	{\sc url}: \url{https://nqbh.github.io/advanced_STEM/}.
	
	Latest version:
	\begin{itemize}
		\item {\it Lecture Note: Introduction to Artificial Intelligence -- Bài Giảng: Nhập Môn Trí Tuệ Nhân Tạo}.
		
		PDF: {\sc url}: \url{https://github.com/NQBH/advanced_STEM_beyond/blob/main/AI/lecture/NQBH_introduction_AI_lecture.pdf}.
		
		\TeX: {\sc url}: \url{https://github.com/NQBH/advanced_STEM_beyond/blob/main/AI/lecture/NQBH_introduction_AI_lecture.tex}.
		\item {\it Codes}:
		\begin{itemize}
			\item C++: \url{https://github.com/NQBH/advanced_STEM_beyond/tree/main/AI/C++}.
			\item Python: \url{https://github.com/NQBH/advanced_STEM_beyond/tree/main/AI/Python}.
		\end{itemize}
	\end{itemize}
\end{abstract}
\tableofcontents

%------------------------------------------------------------------------------%

\section{Some Basic Concepts -- Vài Khái Niệm Cơ Bản}

\subsection{Some search problems -- Vài bài toán tìm kiếm}
\textbf{\textsf{Resources -- Tài nguyên.}}
\begin{enumerate}
	\item \href{https://en.wikipedia.org/wiki/Search_problem}{Wikipedia{\tt/}search problem}.
\end{enumerate}
In \href{https://en.wikipedia.org/wiki/Computational_complexity_theory}{computational complexity theory} \& \href{https://en.wikipedia.org/wiki/Computability_theory}{computability theory}, a {\it search problem} is a \href{https://en.wikipedia.org/wiki/Computational_problem}{computational problem} of finding an {\it admissible} answer for a given input value, provided that such an answer exists. In fact, a search problem is specified by a \href{https://en.wikipedia.org/wiki/Binary_relation}{binary relation} $R$ where $xRy$ iff ``$y$ is an admissible answer given $x$''. Search problems frequently occur in graph theory \& \href{https://en.wikipedia.org/wiki/Combinatorial_optimization}{combinatorial optimization}, e.g. searching for \href{https://en.wikipedia.org/wiki/Matching_(graph_theory)}{matchings}, optional \href{https://en.wikipedia.org/wiki/Clique_(graph_theory)}{cliques}, \& \href{https://en.wikipedia.org/wiki/Independent_set_(graph_theory)}{stable sets} in a given undirected graph.

-- Trong lý thuyết độ phức tạp tính toán và lý thuyết khả năng tính toán, 1 bài toán tìm kiếm là 1 bài toán tính toán tìm 1 câu trả lời có thể chấp nhận được cho 1 giá trị đầu vào nhất định, với điều kiện là câu trả lời như vậy tồn tại. Trên thực tế, 1 bài toán tìm kiếm được chỉ định bởi 1 quan hệ nhị phân R trong đó xRy nếu và chỉ nếu ``$y$ là 1 câu trả lời có thể chấp nhận được cho $x$''. Các bài toán tìm kiếm thường xảy ra trong lý thuyết đồ thị và tối ưu hóa tổ hợp, ví dụ như tìm kiếm các phép khớp, các nhóm tùy chọn và các tập ổn định trong 1 đồ thị vô hướng nhất định.

An algorithm is said to solve a search problem if, for every input value $x$, it returns an admissible answer $y$ for $x$ when such an answer exists; otherwise, it returns any appropriate output, e.g., ``not found'' for $x$ with no such answer.

\begin{definition}[Search problem]
	If $R$ is a binary relation s.t. ${\rm field}(R)\subseteq\Gamma^+$ \& $T$ is a \href{https://en.wikipedia.org/wiki/Turing_machine}{Turing machine}, then $T$ calculates $f$ if:
	\begin{itemize}
		\item if $x$ is s.t. there is some $y$ s.t. $R(x,y)$ then $T$ accepts $x$ with output $z$ s.t. $R(x,z)$ (there may be multiple $y$, \& $T$ need only find 1 of them).
		\item If $x$ is s.t. there is no $y$ s.t. $R(x,y)$ then $T$ rejects $x$.
	\end{itemize}
\end{definition}
The graph of a \href{https://en.wikipedia.org/wiki/Partial_function}{partial function} is a binary relation, \& if $T$ calculates a partial function then there is at most 1 possible output.

A $R$ can be viewed as a {\it search problem}, \& a Turing machine which calculates $R$ is also said to solve it. Every search problem has a corresponding \href{https://en.wikipedia.org/wiki/Decision_problem}{decision problem}, namely $L(R) = \{x;\exists y,\ R(x,y)\}$. This definition can be generalized to $n$-ary relations by any suitable encoding which allows multiple strings to be compressed into 1 string (e.g., by listing them consecutively with a \href{https://en.wikipedia.org/wiki/Delimiter}{delimiter}).

%------------------------------------------------------------------------------%

\subsection{Search algorithms -- Các thuật toán tìm kiếm}
\textbf{\textsf{Resources -- Tài nguyên.}}
\begin{enumerate}
	\item \href{https://en.wikipedia.org/wiki/Search_algorithm}{Wikipedia{\tt/}search algorithm}.
\end{enumerate}
In CS, a {\it search algorithm} is an algorithm designed to solve a \href{https://en.wikipedia.org/wiki/Search_problem}{search problem}. Search algorithms work to retrieve information stored within particular \href{https://en.wikipedia.org/wiki/Data_structure}{data structure}, or calculated in the \href{https://en.wikipedia.org/wiki/Feasible_region}{search space{\tt/}feasible region} of a problem domain, with \href{https://en.wikipedia.org/wiki/Continuous_or_discrete_variable}{either discrete or continuous values}.

-- Trong khoa học máy tính, thuật toán tìm kiếm là thuật toán được thiết kế để giải quyết vấn đề tìm kiếm. Thuật toán tìm kiếm hoạt động để truy xuất thông tin được lưu trữ trong cấu trúc dữ liệu cụ thể hoặc được tính toán trong không gian tìm kiếm của miền vấn đề, với các giá trị rời rạc hoặc liên tục.

Although \href{https://en.wikipedia.org/wiki/Search_engine_(computing)}{search engines} use search algorithms, they belong to the study of \href{https://en.wikipedia.org/wiki/Information_retrieval}{information retrieval}, not algorithmics.

-- Mặc dù công cụ tìm kiếm sử dụng thuật toán tìm kiếm nhưng chúng thuộc về lĩnh vực nghiên cứu về truy xuất thông tin chứ không phải thuật toán.

The appropriate search algorithm to use often depends on the data structure being searched, \& may also include prior knowledge about the data. Search algorithms can be made faster or more efficient by specially constructed database structures, e.g. \href{https://en.wikipedia.org/wiki/Search_tree}{search trees}, \href{https://en.wikipedia.org/wiki/Hash_map}{hash maps}, \& \href{https://en.wikipedia.org/wiki/Database_index}{database indexes}.

-- Thuật toán tìm kiếm phù hợp để sử dụng thường phụ thuộc vào cấu trúc dữ liệu đang được tìm kiếm và cũng có thể bao gồm kiến thức trước đó về dữ liệu. Thuật toán tìm kiếm có thể được thực hiện nhanh hơn hoặc hiệu quả hơn bằng các cấu trúc cơ sở dữ liệu được xây dựng đặc biệt, chẳng hạn như cây tìm kiếm, bản đồ băm và chỉ mục cơ sở dữ liệu.

Search algorithms can be classified based on their mechanism of searching into 3 types of algorithms: linear, binary, \& hashing. \href{https://en.wikipedia.org/wiki/Linear_search}{Linear search} algorithms check every record for the one associated with a target key in a linear fashion. \href{https://en.wikipedia.org/wiki/Binary_search_algorithm}{Binary, or half-interval, searches} repeatedly target the center of the search structure \& divide the search space in half. Comparison search algorithms improve on linear searching by successively eliminating records based on comparisons of the keys until the target record is found, \& can be applied on data structures with a defined order. Digital search algorithms work based on the properties of digits in data structures by using numerical keys. Finally, \href{https://en.wikipedia.org/wiki/Hash_table}{hashing} directly maps keys to records based on a \href{https://en.wikipedia.org/wiki/Hash_function}{hash function}.

-- Thuật toán tìm kiếm có thể được phân loại dựa trên cơ chế tìm kiếm của chúng thành ba loại thuật toán: tuyến tính, nhị phân, \& băm. Thuật toán tìm kiếm tuyến tính kiểm tra mọi bản ghi để tìm bản ghi được liên kết với khóa mục tiêu theo cách tuyến tính. Tìm kiếm nhị phân hoặc nửa khoảng, liên tục nhắm mục tiêu vào tâm của cấu trúc tìm kiếm và chia đôi không gian tìm kiếm. Thuật toán tìm kiếm so sánh cải thiện tìm kiếm tuyến tính bằng cách loại bỏ liên tiếp các bản ghi dựa trên các phép so sánh khóa cho đến khi tìm thấy bản ghi mục tiêu và có thể được áp dụng trên các cấu trúc dữ liệu có thứ tự được xác định. Thuật toán tìm kiếm kỹ thuật số hoạt động dựa trên các thuộc tính của chữ số trong cấu trúc dữ liệu bằng cách sử dụng các khóa số. Cuối cùng, băm trực tiếp ánh xạ khóa thành các bản ghi dựa trên hàm băm.

Algorithms are often evaluated by their \href{https://en.wikipedia.org/wiki/Computational_complexity}{computational complexity}, or maximum theoretical run time. Binary search functions, e.g., have a maximum complexity of $O(\log n)$, or logarithmic time. In simple terms, the maximum number of operations needed to find the search target is a logarithmic function of the size of the search space.

-- Thuật toán thường được đánh giá theo độ phức tạp tính toán hoặc thời gian chạy lý thuyết tối đa. E.g., hàm tìm kiếm nhị phân có độ phức tạp tối đa là $O(\log n)$ hoặc thời gian logarith. Nói 1 cách đơn giản, số lượng thao tác tối đa cần thiết để tìm mục tiêu tìm kiếm là hàm logarit của kích thước không gian tìm kiếm.

%------------------------------------------------------------------------------%

\subsubsection{Applications of search algorithms -- Ứng dụng của thuật toán tìm kiếm}
Specific applications of search algorithms include:
\begin{itemize}
	\item Problems in \href{https://en.wikipedia.org/wiki/Combinatorial_optimization}{combinatorial optimization}, e.g.:
	\begin{itemize}
		\item The \href{https://en.wikipedia.org/wiki/Vehicle_routing_problem}{vehicle routing problem}, a form of \href{https://en.wikipedia.org/wiki/Shortest_path_problem}{shortest path problem}
		\item The \href{https://en.wikipedia.org/wiki/Knapsack_problem}{knapsack problem}: Given a set of items, each with a weight \& a value, determine the number of each item to include in a collection so that the total weight is $\le$ a given limit \& the total value is as large as possible.
		\item The \href{https://en.wikipedia.org/wiki/Nurse_scheduling_problem}{nurse scheduling problem}
	\end{itemize}
	\item Problems in \href{https://en.wikipedia.org/wiki/Constraint_satisfaction}{constraint satisfaction}, e.g.:
	\begin{itemize}
		\item The \href{https://en.wikipedia.org/wiki/Map_coloring_problem}{map coloring problem}
		\item Filling in a \href{https://en.wikipedia.org/wiki/Sudoku}{sudoku} or \href{https://en.wikipedia.org/wiki/Crossword_puzzle}{crossword puzzle}
	\end{itemize}
	\item In \href{https://en.wikipedia.org/wiki/Game_theory}{game theory} \& especially \href{https://en.wikipedia.org/wiki/Combinatorial_game_theory}{combinatorial game theory}, choosing the best move to make next (e.g. with the \href{https://en.wikipedia.org/wiki/Minmax}{minmax} algorithm)
	\item Finding a combination or password from the whole set of possibilities
	\item \href{https://en.wikipedia.org/wiki/Factorization}{Factoring} an integer (an important problem in \href{https://en.wikipedia.org/wiki/Cryptography}{cryptography})
	\item Search engine optimization (SEO) \& content optimization for web crawlers
	\item Optimizing an industrial process, e.g. a \href{https://en.wikipedia.org/wiki/Chemical_reaction}{chemical reaction}, by changing the parameters of the process (like temperature, pressure, \& pH)
	\item Retrieving a record from a \href{https://en.wikipedia.org/wiki/Database}{database}
	\item Finding the maximum or minimum value in a \href{https://en.wikipedia.org/wiki/List_(abstract_data_type)}{list} or \href{https://en.wikipedia.org/wiki/Array_data_structure}{array}
	\item Checking to see if a given value is present in a set of values
\end{itemize}

%------------------------------------------------------------------------------%

\subsubsection{Classes of search algorithms}

\begin{enumerate}
	\item {\bf For virtual search spaces.} Algorithms for searching virtual spaces are used in the \href{https://en.wikipedia.org/wiki/Constraint_satisfaction_problem}{constraint satisfaction problem}, where the goal is to find a set of value assignments to certain varieties that will satisfy specific mathematical equations \& inequations{\tt/}equalities. They are also used when the goal is to find a variable assignment that will \href{https://en.wikipedia.org/wiki/Discrete_optimization}{maximize or minimize} a certain function of those variables. Algorithms for these problems include the basic \href{https://en.wikipedia.org/wiki/Brute-force_search}{brute-force search} (also called ``na\"ive'' or ``uninformed'' search), \& a variety of \href{https://en.wikipedia.org/wiki/Heuristic_function}{heuristics} that try to exploit partial knowledge about the structure of this space, e.g. linear relaxation, constraint generation, \& \href{https://en.wikipedia.org/wiki/Local_consistency}{constraint propagation}.
	
	-- Các thuật toán tìm kiếm không gian ảo được sử dụng trong bài toán thỏa mãn ràng buộc, trong đó mục tiêu là tìm 1 tập hợp các phép gán giá trị cho các biến nhất định sẽ thỏa mãn các phương trình và bất phương trình toán học/bằng nhau cụ thể. Chúng cũng được sử dụng khi mục tiêu là tìm 1 phép gán biến sẽ tối đa hóa hoặc tối thiểu hóa 1 hàm nhất định của các biến đó. Các thuật toán cho các bài toán này bao gồm tìm kiếm brute-force cơ bản (còn gọi là tìm kiếm ``ngây thơ'' hoặc ``không có thông tin''), và nhiều phương pháp tìm kiếm khác nhau cố gắng khai thác kiến thức 1 phần về cấu trúc của không gian này, chẳng hạn như thư giãn tuyến tính, tạo ràng buộc và truyền ràng buộc.
	
	An important subclass are the \href{https://en.wikipedia.org/wiki/Local_search_(optimization)}{local search} methods, that view the elements of the search space as the vertices of a graph, with edges defined by a set of heuristics applicable to the case; \& scan the space by moving from item to item along the edges, e.g. according to the \href{https://en.wikipedia.org/wiki/Gradient_descent}{steepest descent} or \href{https://en.wikipedia.org/wiki/Best-first_search}{best 1st} criterion, or in a \href{https://en.wikipedia.org/wiki/Stochastic_optimization}{stochastic search}. This category includes a great variety of general \href{https://en.wikipedia.org/wiki/Metaheuristic}{metaheuristic} methods, e.g. \href{https://en.wikipedia.org/wiki/Simulated_annealing}{simulated annealing}, \href{https://en.wikipedia.org/wiki/Tabu_search}{tabu search}, A-teams, \& \href{https://en.wikipedia.org/wiki/Genetic_programming}{general programming}, that combine arbitrary heuristics in specific ways. The opposite of local search would be global search methods. This method is applicable when the search space is not limited \& all aspects of the given network are available to the entity running the search algorithm.
	
	-- 1 phân lớp quan trọng là các phương pháp tìm kiếm cục bộ, xem các phần tử của không gian tìm kiếm như các đỉnh của 1 đồ thị, với các cạnh được xác định bởi 1 tập hợp các phương pháp tìm kiếm áp dụng cho trường hợp này; và quét không gian bằng cách di chuyển từ mục này sang mục khác dọc theo các cạnh, ví dụ theo tiêu chí dốc nhất hoặc tiêu chí tốt nhất đầu tiên, hoặc trong tìm kiếm ngẫu nhiên. Thể loại này bao gồm nhiều phương pháp siêu tìm kiếm chung, chẳng hạn như ủ mô phỏng, tìm kiếm tabu, nhóm A và lập trình di truyền, kết hợp các phương pháp tìm kiếm tùy ý theo những cách cụ thể. Ngược lại với tìm kiếm cục bộ sẽ là các phương pháp tìm kiếm toàn cục. Phương pháp này có thể áp dụng khi không gian tìm kiếm không bị giới hạn và tất cả các khía cạnh của mạng đã cho đều khả dụng đối với thực thể chạy thuật toán tìm kiếm.
	
	This class also includes various \href{https://en.wikipedia.org/wiki/Tree_traversal}{tree search algorithms}, that view the elements as vertices of a \href{https://en.wikipedia.org/wiki/Tree_(graph_theory)}{tree}, \& traverse that tree in some special order. Examples of the latter include the exhaustive methods e.g. \href{https://en.wikipedia.org/wiki/Depth-first_search}{depth-1st search} \& \href{https://en.wikipedia.org/wiki/Breadth-first_search}{breadth-1st search}, as well as various heuristic-based \href{https://en.wikipedia.org/wiki/Pruning_(decision_trees)}{search tree pruning} methods e.g. \href{https://en.wikipedia.org/wiki/Backtracking}{backtracking} \& \href{https://en.wikipedia.org/wiki/Branch\_and\_bound}{branch \& bound}. Unlike general metaheuristics, which at best work only in a probabilistic scene, many of these tree-search methods are guaranteed to find the exact or optimal solution, if given enough time. This is called ``\href{https://en.wikipedia.org/wiki/Completeness_(logic)}{completeness}''.
	
	-- Lớp này cũng bao gồm nhiều thuật toán tìm kiếm cây khác nhau, xem các phần tử như các đỉnh của 1 cây và duyệt cây đó theo 1 thứ tự đặc biệt nào đó. Ví dụ về thứ tự sau bao gồm các phương pháp đầy đủ như tìm kiếm theo chiều sâu và tìm kiếm theo chiều rộng, cũng như nhiều phương pháp cắt tỉa cây tìm kiếm dựa trên phương pháp heuristic như quay lui và rẽ nhánh và giới hạn. Không giống như các siêu phương pháp heuristic chung, tốt nhất chỉ hoạt động theo nghĩa xác suất, nhiều phương pháp tìm kiếm cây này được đảm bảo tìm ra giải pháp chính xác hoặc tối ưu, nếu có đủ thời gian. Điều này được gọi là ``hoàn chỉnh''.
	
	Another important subclass consists of algorithms for exploring the \href{https://en.wikipedia.org/wiki/Game_tree}{game tree} of multiple-player games, e.g. chess or \href{https://en.wikipedia.org/wiki/Backgammon}{backgammon}, whose nodes consist of all possible game situations that could result from the current situation. The goal in these problems is to find the move that provides the best chance of a win, taking into account all possible moves of the opponent(s). Similar problems occur when humans or machines have to make successive decisions whose outcomes are not entirely under one's control, e.g. in robot guidance or in marketing, financial, or military strategy planning. This kind of problem -- \href{https://en.wikipedia.org/wiki/Combinatorial_search}{combinatorial search} -- has been extensively studied in the context of AI. Examples of algorithms for this class are the \href{https://en.wikipedia.org/wiki/Minimax}{minimax algorithm}, \href{https://en.wikipedia.org/wiki/Alpha%E2%80%93beta_pruning}{alpha--beta pruning}, \& the \href{https://en.wikipedia.org/wiki/A*_search_algorithm}{$\rm A^\star$ algorithm} \& its variants.
	
	-- 1 phân lớp quan trọng khác bao gồm các thuật toán để khám phá cây trò chơi của các trò chơi nhiều người chơi, chẳng hạn như cờ vua hoặc cờ cá ngựa, có các nút bao gồm tất cả các tình huống trò chơi có thể xảy ra do tình huống hiện tại. Mục tiêu của các bài toán này là tìm ra nước đi mang lại cơ hội chiến thắng cao nhất, có tính đến tất cả các nước đi có thể có của đối thủ. Các bài toán tương tự xảy ra khi con người hoặc máy móc phải đưa ra các quyết định liên tiếp mà kết quả không hoàn toàn nằm trong tầm kiểm soát của mình, chẳng hạn như trong hướng dẫn rô-bốt hoặc trong lập kế hoạch chiến lược tiếp thị, tài chính hoặc quân sự. Loại bài toán này -- tìm kiếm kết hợp -- đã được nghiên cứu rộng rãi trong bối cảnh trí tuệ nhân tạo. Các ví dụ về thuật toán cho lớp này là thuật toán minimax, cắt tỉa alpha–beta và thuật toán A* cùng các biến thể của nó.
	\item {\bf For sub-structures of a given structure.} An important \& extensively studied subclass are the \href{https://en.wikipedia.org/wiki/List_of_algorithms#Graph_algorithms}{graph algorithms}, in particular \href{https://en.wikipedia.org/wiki/Graph_traversal}{graph traversal} algorithms, for finding specific sub-structures in a given graph -- e.g. \href{https://en.wikipedia.org/wiki/Glossary_of_graph_theory#Subgraphs}{subgraphs}, paths, circuits, etc. Examples include \href{https://en.wikipedia.org/wiki/Dijkstra%27s_algorithm}{Dijkstra's algorithm}, \href{https://en.wikipedia.org/wiki/Kruskal%27s_algorithm}{Kruskal's algorithm}, the \href{https://en.wikipedia.org/wiki/Nearest_neighbour_algorithm}{nearest neighbor algorithm}, \& \href{https://en.wikipedia.org/wiki/Prim%27s_algorithm}{Prim's algorithm}.
	
	-- {\it Đối với các cấu trúc con của 1 cấu trúc nhất định.} 1 phân lớp quan trọng và được nghiên cứu rộng rãi là các thuật toán đồ thị, đặc biệt là các thuật toán duyệt đồ thị, để tìm các cấu trúc con cụ thể trong 1 đồ thị nhất định — chẳng hạn như các đồ thị con, đường dẫn, mạch, etc. Các ví dụ bao gồm thuật toán Dijkstra, thuật toán Kruskal, thuật toán hàng xóm gần nhất và thuật toán Prim.
	
	Another important subclass of this category are the \href{https://en.wikipedia.org/wiki/String_searching_algorithm}{string searching algorithms}, that search for patterns within strings. 2 famous examples are the \href{https://en.wikipedia.org/wiki/Boyer%E2%80%93Moore_string-search_algorithm}{Boyer--Moore} \& \href{https://en.wikipedia.org/wiki/Knuth%E2%80%93Morris%E2%80%93Pratt_algorithm}{Knuth--Morris--Pratt algorithms}, \& several algorithms based on the \href{https://en.wikipedia.org/wiki/Suffix_tree}{suffix tree} data structure.
	
	-- 1 phân lớp quan trọng khác của thể loại này là các thuật toán tìm kiếm chuỗi, tìm kiếm các mẫu trong chuỗi. Hai ví dụ nổi tiếng là các thuật toán Boyer--Moore \& Knuth--Morris--Pratt, \& 1 số thuật toán dựa trên cấu trúc dữ liệu cây hậu tố.
	\item {\bf Search for the maximum of a function.} In 1953, American statistician \href{https://en.wikipedia.org/wiki/Jack_Kiefer_(statistician)}{\sc Jack Kiefer} devised \href{https://en.wikipedia.org/wiki/Fibonacci_search_technique}{Fibonacci search} which can be used to find the maximum of a unimodal function \& has many other applications in CS.
	
	-- {\it Tìm kiếm giá trị lớn nhất của 1 hàm số.} Vào năm 1953, nhà thống kê người Mỹ Jack Kiefer đã phát minh ra thuật toán tìm kiếm Fibonacci có thể được sử dụng để tìm giá trị lớn nhất của 1 hàm số đơn thức và có nhiều ứng dụng khác trong khoa học máy tính.
	\item {\bf For quantum computers.} There are also search methods designed for \href{https://en.wikipedia.org/wiki/Quantum_computing}{quantum computers}, like \href{https://en.wikipedia.org/wiki/Grover%27s_algorithm}{Grover's algorithm}, that are theoretically faster than linear or brute-force search even without the help of data structures or heuristics. While the ideas \& applications behind quantum computers are still entirely theoretical, studies have been conducted with algorithms like Grover's that accurately replicate the hypothetical physical versions of quantum computing systems.
	
	-- {\it Đối với máy tính lượng tử}: Cũng có những phương pháp tìm kiếm được thiết kế cho máy tính lượng tử, như thuật toán Grover, về mặt lý thuyết nhanh hơn tìm kiếm tuyến tính hoặc tìm kiếm bằng vũ lực ngay cả khi không có sự trợ giúp của cấu trúc dữ liệu hoặc phương pháp tìm kiếm. Trong khi các ý tưởng và ứng dụng đằng sau máy tính lượng tử vẫn hoàn toàn là lý thuyết, các nghiên cứu đã được tiến hành với các thuật toán như thuật toán Grover sao chép chính xác các phiên bản vật lý giả định của hệ thống máy tính lượng tử.
\end{enumerate}

%------------------------------------------------------------------------------%

\subsection{Gradient -- Độ dốc}
\textbf{\textsf{Resources -- Tài nguyên.}}
\begin{enumerate}
	\item \cite{Tiep_ML_co_ban}. {\sc Vũ Hữu Tiệp}. {\it Machine Learning Cơ Bản}. Chap. 12: Gradient Descent.
\end{enumerate}

\begin{vidu}[\cite{Tiep_ML_co_ban}, p. 160]
	Xét hàm số $f(x) = x^2 + 5\sin x$, $f\in C(\mathbb{R}$ có đạo hàm $f'(x) = 2x + 5\cos x$. Giả sử xuất phát từ 1 điểm $x_0$, quy tắc cập nhật tại vòng lặp thứ $t$ là
	\begin{equation*}
		x_{t+1} = x_t - \eta f'(x_t) = x_t - \eta(2x_t + 5\cos x_t).
	\end{equation*}
	Codes:
	\begin{itemize}
		\item Python:
		\begin{verbatim}
import math
import numpy as np

# f(x) = x^2 + 5sin x
def f(x):
    return x**2 + 5*np.sin(x)

def df(x): # derivative f'(x) of f(x)
    return 2*x + 5 * np.cos(x)

x = float(input("x = "))
print("f(x) = ", f(x))
print("df(x) = ", df(x))

tol = 1e-3 # tolerance: just a small number

def gradient_descent(x0, eta): # x0: starting point, eta: learning rate
    x = [x0]
    for i in range(100):
        x_new = x[-1] - eta*df(x[-1]) # x_new: x_{t+1}, x[-1]: x_t
        if abs(df(x_new)) < tol:
            break
        x.append(x_new)
    return(x, i)

x0 = float(input("x0 = "))
eta = float(input("eta = "))
if eta <= 0:
    print("error: eta must be positive!")
else:
    print(gradient_descent(x0, eta))
		\end{verbatim}
	\end{itemize}
\end{vidu}

\begin{baitoan}
	Xét hàm số $f(x) = x^3 + 3x^2 + 5\sin x - 7\cos x + \sqrt{2}e^{-2x}$. Viết chương trình {\sf C{\tt/}C++, Python} để: (a) Tính hàm $f(x),f'(x)$ với $x\in\mathbb{R}$ được nhập từ bàn phím. (b) Viết hàm gradient descent theo công thức
	\begin{equation*}
		x_{t+1} = x_t - \eta f'(x_t),
	\end{equation*}
	với $\eta\in(0,\infty)$ được gọi là {\rm tốc độ học (learning rate)}.
\end{baitoan}

\begin{proof}
	Dễ thấy $f(x)$ là 1 hàm liên tục trên $\mathbb{R}$, i.e., $f\in C(\mathbb{R}$ , \& có đạo hàm $f'(x) = 3x^2 + 6x + 5\cos x + 7\sin x - 2\sqrt{2}e^{-2x}$.
	
	Code Python:
	\begin{verbatim}
# f1(x) = x^3 + 3x^2  + 5sin x - 7cos x + sqrt{2}e^{-2x}
def f1(x):
    return x**3 + 3*x**2 + 5*np.sin(x) - 7*np.cos(x) + np.sqrt(2)*np.exp(-2*x)

def df1(x):
    return 3*x**2 + 6*x + 5*np.cos(x) + 7*np.sin(x) - 2*np.sqrt(2)*np.exp(-2*x)

x = float(input("x = "))
print("f(x) = ", f(x))
print("df(x) = ", df(x))

tol = 1e-3 # tolerance: just a small number

def gradient_descent_f1(x0, eta): # x0: starting point, eta: learning rate
    x = [x0]
    for i in range(100):
        x_new = x[-1] - eta*df1(x[-1]) # x_new: x_{t+1}, x[-1]: x_t
        if abs(df1(x_new)) < tol:
            break
        x.append(x_new)
    return(x, i)

x0 = float(input("x0 = "))
eta = float(input("eta = "))
if eta <= 0:
    print("error: eta must be positive!")
else:
    print(gradient_descent_f1(x0, eta))
	\end{verbatim}
\end{proof}

\begin{remark}
	Có thể tham khảo các công thức tính đạo hàm ở \href{https://en.wikibooks.org/wiki/Calculus/Tables_of_Derivatives}{Wikipedia{\tt/}tables of derivatives}.
\end{remark}

\begin{baitoan}
	Xét hàm số $f(x,y) = 2x^3y^2 + \dfrac{\sqrt{x^3}}{y} + \sin(x^2y) + e^{\cos(xy^2)}$. Viết chương trình {\sf C{\tt/}C++, Python} để: (a) Tính hàm $f(x,y),\nabla f(x,y)$ với $x,y\in\mathbb{R}$ được nhập từ bàn phím. (b) Viết hàm gradient descent cho 2 trường hợp:
	\begin{equation*}
		(x_{t+1},y_{t+1}) = (x_t,y_t) - \eta\nabla f(x_t,y_t),
	\end{equation*}
	or
	\begin{equation*}
		\left\{\begin{split}
			x_{t+1} = x_t - \boldsymbol{\alpha}\cdot\nabla f(x_t,y_t) = x_t - \alpha_1\partial_xf(x_t,y_t) - \alpha_2\partial_xf(x_t,y_t),\\
			y_{t+1} = y_t - \boldsymbol{\beta}\cdot\nabla f(x_t,y_t) = x_t - \beta_1\partial_xf(x_t,y_t) - \beta_2\partial_xf(x_t,y_t),
		\end{split}\right.
	\end{equation*}
	Python:
	\begin{verbatim}
# f(x,y) = 2x^3y^2 + sqrt(x^3)/y + sin(x^2y) + e^{cos(xy^2)}

def f(x, y):
    return 2*x**3*y**2 + np.sqrt(x**3)/y + np.sin(x**2 * y) + np.exp(np.cos(x * y**2))

def grad_f(x, y):
    df_dx = 6*x**2 * y**2 + (3/2) * x**0.5 / y + 2*x*y * np.cos(x**2 * y) - y**2 * np.sin(x * y**2) * np.exp(np.cos(x * y**2))
    df_dy = 4*x**3 * y - np.sqrt(x**3) / y**2 + x**2 * np.cos(x**2 * y) - 2*x*y * np.sin(x * y**2) * np.exp(np.cos(x * y**2))
    return np.array([df_dx, df_dy])

x = float(input("x = "))
y = float(input("y = "))
print("f(x,y) = ", f(x,y))
print("grad f(x,y) = ", grad_f(x,y))
	\end{verbatim}
\end{baitoan}

%------------------------------------------------------------------------------%

\subsection{Minimax}
\textbf{\textsf{Resources -- Tài nguyên.}}
\begin{enumerate}
	\item \href{https://en.wikipedia.org/wiki/Minimax}{Wikipedia{\tt/}minimax}.
\end{enumerate}
{\it Minimax} (sometimes {\it Minmax, MM, or {\it saddle point}}) is a decision rule used in AI, \href{https://en.wikipedia.org/wiki/Decision_theory}{decision theory}, \href{https://en.wikipedia.org/wiki/Game_theory}{game theory}, statistics, \& philosophy for {\it minimizing} the possible \href{https://en.wikipedia.org/wiki/Loss_function}{loss} for a \href{https://en.wikipedia.org/wiki/Worst-case_scenario}{worse case (maximum loss) scenario}. When dealing with gains, it is referred to as ``maximin'' -- to maximize the minimum gain. Originally formulated for several-player \href{https://en.wikipedia.org/wiki/Zero-sum}{zero-sum} \href{https://en.wikipedia.org/wiki/Game_theory}{game theory}, covering both the cases where players take alternate moves \& those where they make simultaneous moves, it has also been extended to more complex games \& to general decision-making in the presence of uncertainty.

-- {\it Minimax} (đôi khi là {\it Minmax, MM}, hoặc {\it điểm yên ngựa}) là 1 quy tắc quyết định được sử dụng trong trí tuệ nhân tạo, lý thuyết quyết định, lý thuyết trò chơi, thống kê và triết học để giảm thiểu tổn thất có thể xảy ra cho 1 kịch bản xấu nhất (tổn thất tối đa). Khi giải quyết các khoản lợi nhuận, nó được gọi là "maximin" – để tối đa hóa lợi nhuận tối thiểu. Ban đầu được xây dựng cho lý thuyết trò chơi tổng bằng không của nhiều người chơi, bao gồm cả các trường hợp mà người chơi thực hiện các nước đi thay thế và các trường hợp mà họ thực hiện các nước đi đồng thời, nó cũng đã được mở rộng sang các trò chơi phức tạp hơn và ra quyết định chung khi có sự không chắc chắn.

%------------------------------------------------------------------------------%

\section{Heuristic Algorithms -- Các Thuật Giải Heuristic}

\begin{itemize}\sf\small
	\item \textbf{heuristic} [a] (formal) heuristic teaching or education encourages you to learn by discovering things for yourself.
	\item \textbf{heuristics} [n] [uncountable] (formal) a method of solving problems by finding practical ways of dealing with them, learning from past experience.
\end{itemize}
\textbf{\textbf{Resources -- Tài nguyên.}}
\begin{enumerate}
	\item \cite{Norvig_Russell2021}. {\sc Peter Norvig, Stuart Russell}. {\it Artificial Intelligence: A Modern Approach}. 4e.
	
	\item \href{https://en.wikipedia.org/wiki/Heuristic_(computer_science)}{Wikipedia{\tt/}heuristic (CS)}.
\end{enumerate}



%------------------------------------------------------------------------------%

\subsection{Heuristic (Computer Science) -- Tự tìm tòi (Khoa Học Máy Tính)}
In mathematical optimization \& CS, {\it heuristic} (from Greek ``I find, discover'') is a technique designed for \href{https://en.wikipedia.org/wiki/Problem_solving}{problem solving} more quickly when classic methods are too slow for finding an exact or approximate solution, or when classic methods fail to find any exact solution in a \href{https://en.wikipedia.org/wiki/Space_complexity}{search space}. This is achieved by trading optimality, completeness, \href{https://en.wikipedia.org/wiki/Accuracy_and_precision}{accuracy or precision} for speed. In a way, it can be considered a shortcut.

-- Trong tối ưu hóa toán học và khoa học máy tính, heuristic (từ tiếng Hy Lạp ``Tôi tìm thấy, khám phá'') là 1 kỹ thuật được thiết kế để giải quyết vấn đề nhanh hơn khi các phương pháp cổ điển quá chậm để tìm ra giải pháp chính xác hoặc gần đúng, hoặc khi các phương pháp cổ điển không tìm thấy bất kỳ giải pháp chính xác nào trong không gian tìm kiếm. Điều này đạt được bằng cách đánh đổi tính tối ưu, tính hoàn chỉnh, tính chính xác hoặc độ chính xác để lấy tốc độ. Theo 1 cách nào đó, nó có thể được coi là 1 lối tắt.

A {\it heuristic function}, also simply called a {\it heuristic}, is a function that ranks alternatives in \href{https://en.wikipedia.org/wiki/Search_algorithm}{serch algorithms} at each branching step based on available information to decide which brand to follow. E.g., it may approximate the exact solution.

-- 1 hàm heuristic, hay còn gọi đơn giản là heuristic, là 1 hàm xếp hạng các phương án thay thế trong thuật toán tìm kiếm tại mỗi bước phân nhánh dựa trên thông tin có sẵn để quyết định nhánh nào sẽ theo. Ví dụ, nó có thể xấp xỉ giải pháp chính xác.

{\bf Motivation of heuristic.} The objective of a heuristic is to produce a solution in a reasonable time frame that is good enough for solving the problem at hand. This solution may not be the best of all the solutions to this problem, or it may simply approximate the exact solution. But it is still valuable because finding it does not require a prohibitively long time.

-- {\bf Động lực của phương pháp tìm kiếm.} Mục tiêu của phương pháp tìm kiếm là đưa ra 1 giải pháp trong 1 khung thời gian hợp lý đủ tốt để giải quyết vấn đề đang xét. Giải pháp này có thể không phải là giải pháp tốt nhất trong tất cả các giải pháp cho vấn đề này hoặc có thể chỉ đơn giản là xấp xỉ giải pháp chính xác. Nhưng nó vẫn có giá trị vì việc tìm ra nó không đòi hỏi quá nhiều thời gian.

Heuristics may produce results by themselves, or they may be used in conjunction with optimization algorithms to improve their efficiency (e.g., they may be used to generate good seed values).

-- Phương pháp tìm kiếm có thể tự tạo ra kết quả hoặc có thể được sử dụng kết hợp với các thuật toán tối ưu hóa để cải thiện hiệu quả của chúng (ví dụ: chúng có thể được sử dụng để tạo ra các giá trị hạt giống tốt).

Results about \href{https://en.wikipedia.org/wiki/NP-hard}{NP-hardness} in theoretical computer science make heuristics the only viable option for a variety of complex optimization problems that need to be routinely solved in real-world applications.

-- Kết quả về độ khó NP trong khoa học máy tính lý thuyết khiến phương pháp tìm kiếm trở thành lựa chọn khả thi duy nhất cho nhiều vấn đề tối ưu hóa phức tạp cần được giải quyết thường xuyên trong các ứng dụng thực tế.

Heuristics underlie the whole field of AI \& the computer simulation of thinking, as they may be used in situations where there are no known algorithms.

-- Phương pháp tìm kiếm là nền tảng cho toàn bộ lĩnh vực AI \& mô phỏng suy nghĩ bằng máy tính, vì chúng có thể được sử dụng trong những tình huống không có thuật toán nào được biết đến.

{\it Simpler problem.} 1 way of achieving the computational performance gain expected of a heuristic consists of solving a simpler problem whose solution is also a solution to the initial problem.

-- {\it Bài toán đơn giản hơn.} 1 cách để đạt được hiệu suất tính toán mong đợi của 1 phương pháp tìm kiếm là giải 1 bài toán đơn giản hơn mà giải pháp của nó cũng là giải pháp cho bài toán ban đầu.

\begin{example}[Search]
	An example of heuristic making an algorithm faster occurs in certain search problems. Initially, the heuristic tries every possibility at each step, like the full-space search algorithm. But it can stop the search at any time if the current possibility is already worse than the best solution already found. In such search problems, a heuristic can be used to try good choices 1st so that bad paths can be eliminated early, see \href{https://en.wikipedia.org/wiki/Alpha%E2%80%93beta_pruning}{Wikipedia{\tt/}alpha-beta pruning}. In the case of \href{https://en.wikipedia.org/wiki/Best-first_search}{best-1st search} algorithms, e.g. \href{https://en.wikipedia.org/wiki/A*_search}{$\rm A^\star$ search}, the heuristic improves the algorithm's convergence while maintaining its correctness as long as the heuristic is \href{https://en.wikipedia.org/wiki/Admissible_heuristic}{admissible}.
	
	-- 1 ví dụ khác về phương pháp tìm kiếm giúp thuật toán nhanh hơn xảy ra trong 1 số bài toán tìm kiếm nhất định. Ban đầu, phương pháp tìm kiếm thử mọi khả năng ở mỗi bước, giống như thuật toán tìm kiếm toàn không gian. Nhưng nó có thể dừng tìm kiếm bất kỳ lúc nào nếu khả năng hiện tại đã tệ hơn giải pháp tốt nhất đã tìm thấy. Trong các bài toán tìm kiếm như vậy, phương pháp tìm kiếm có thể được sử dụng để thử các lựa chọn tốt trước để các đường dẫn xấu có thể bị loại bỏ sớm (xem cắt tỉa alpha–beta). Trong trường hợp các thuật toán tìm kiếm tốt nhất trước, chẳng hạn như tìm kiếm $\rm A^\star$, phương pháp tìm kiếm cải thiện sự hội tụ của thuật toán trong khi vẫn duy trì tính chính xác của nó miễn là phương pháp tìm kiếm được chấp nhận.
\end{example}

\begin{example}[{\sc Newell \& Simon}: heuristic search hypothesis]
	In their \href{https://en.wikipedia.org/wiki/Turing_Award}{Turing Award} acceptance speech, \href{https://en.wikipedia.org/wiki/Allen_Newell}{\sc Allen Newell} \& \href{https://en.wikipedia.org/wiki/Herbert_A._Simon}{\sc Herbert A. Simon} discuss the heuristic search hypothesis: a physical symbol system will repeatedly generate \& modify known symbol structures until the created structure matches the solution structure. Each following step depends upon the step before it, thus the heuristic search learns what avenues to pursue \& which ones to disregard by measuring how close the current step is to the solution. Therefore, some possibilities will never be generated as they are measured to be less likely to complete the solution.
	
	-- Trong bài phát biểu nhận giải thưởng Turing, Allen Newell và Herbert A. Simon thảo luận về giả thuyết tìm kiếm theo phương pháp heuristic: 1 hệ thống ký hiệu vật lý sẽ liên tục tạo ra và sửa đổi các cấu trúc ký hiệu đã biết cho đến khi cấu trúc được tạo ra khớp với cấu trúc giải pháp. Mỗi bước tiếp theo phụ thuộc vào bước trước đó, do đó tìm kiếm theo phương pháp heuristic tìm hiểu những con đường nào cần theo đuổi và những con đường nào cần bỏ qua bằng cách đo lường mức độ gần của bước hiện tại với giải pháp. Do đó, 1 số khả năng sẽ không bao giờ được tạo ra vì chúng được đo lường là ít có khả năng hoàn thành giải pháp hơn.
	
	A heuristic method can accomplish its task by using search trees. However, instead of generating all possible solution branches, a heuristic selects branches more likely to produce outcomes than other branches. It is selective at each decision point, picking branches that are more likely to produce solutions.
	
	-- 1 phương pháp heuristic có thể hoàn thành nhiệm vụ của mình bằng cách sử dụng cây tìm kiếm. Tuy nhiên, thay vì tạo ra tất cả các nhánh giải pháp khả thi, 1 phương pháp heuristic sẽ chọn các nhánh có nhiều khả năng tạo ra kết quả hơn các nhánh khác. Nó có tính chọn lọc tại mỗi điểm quyết định, chọn các nhánh có nhiều khả năng tạo ra giải pháp hơn.
\end{example}

\begin{example}[Antivirus software -- Phần mềm diệt virus]
	\href{https://en.wikipedia.org/wiki/Antivirus_software}{Antivirus software} often uses heuristic rules for detecting viruses \& other forms of \href{https://en.wikipedia.org/wiki/Malware}{malware}. Heuristic scanning looks for code \&{\tt/}or behavioral patterns common to a class or family of viruses, with different sets of rules for different viruses. If a file or executing process is found to contain matching code patterns \&{\tt/}or to be performing that set of activities, then the scanner infers that the file is infected. The most advanced part of behavior--based heuristic scanning is that it can work against highly randomized self-modifying{\tt/}mutating (\href{https://en.wikipedia.org/wiki/Polymorphic_code}{polymorphic}) viruses that cannot be easily detected by simpler string scanning methods. Heuristic scanning has the potential to detect future viruses without requiring the virus to be 1st detected somewhere else, submitted to the virus scanner developer, analyzed, \& a detection update for the scanner provided to the scanner's users.
	
	-- Phần mềm diệt vi-rút thường sử dụng các quy tắc heuristic để phát hiện vi-rút và các dạng phần mềm độc hại khác. Quét heuristic tìm kiếm mã và/hoặc các mẫu hành vi phổ biến đối với 1 lớp hoặc họ vi-rút, với các bộ quy tắc khác nhau cho các loại vi-rút khác nhau. Nếu phát hiện thấy 1 tệp hoặc quy trình thực thi có chứa các mẫu mã trùng khớp và/hoặc đang thực hiện bộ hoạt động đó, thì trình quét sẽ suy ra rằng tệp đó đã bị nhiễm. Phần tiên tiến nhất của quét heuristic dựa trên hành vi là nó có thể hoạt động chống lại các vi-rút tự sửa đổi/đột biến (đa hình) ngẫu nhiên cao mà không thể dễ dàng phát hiện bằng các phương pháp quét chuỗi đơn giản hơn. Quét heuristic có khả năng phát hiện vi-rút trong tương lai mà không cần phải phát hiện vi-rút trước ở nơi khác, gửi cho nhà phát triển trình quét vi-rút, phân tích và cung cấp bản cập nhật phát hiện cho trình quét cho người dùng trình quét.
\end{example}

%------------------------------------------------------------------------------%

\subsubsection{Pitfalls of heuristic -- Những cạm bẫy của phương pháp tìm kiếm}
Some heuristics have a strong underlying theory; they are either derived in a top-down manner from the theory or are arrived at based on either experimental or real world data. Others are just \href{https://en.wikipedia.org/wiki/Rule_of_thumb}{rules of thumb} based on real-world observation or experience without even a glimpse of theory. The latter are exposed to a larger number of pitfalls.

-- 1 số phương pháp tìm kiếm có lý thuyết cơ bản mạnh mẽ; chúng được suy ra theo cách từ trên xuống từ lý thuyết hoặc được đưa ra dựa trên dữ liệu thực nghiệm hoặc dữ liệu thực tế. Những phương pháp khác chỉ là các quy tắc kinh nghiệm dựa trên quan sát hoặc kinh nghiệm thực tế mà không hề có 1 chút lý thuyết nào. Những phương pháp sau có nhiều cạm bẫy hơn.

When a heuristic is reused in various contexts because it has been to ``work'' in 1 context, without having been mathematically proven to meet a given set of requirements, it is possible that the current data set does not necessarily represent future data sets (see \href{https://en.wikipedia.org/wiki/Overfitting}{overfitting}) \& that purported ``solutions'' turn out to be akin to noise.

-- Khi 1 phương pháp tìm kiếm được tái sử dụng trong nhiều bối cảnh khác nhau vì nó được coi là "có hiệu quả" trong 1 bối cảnh, nhưng chưa được chứng minh về mặt toán học là đáp ứng được 1 tập hợp các yêu cầu nhất định, thì có khả năng là tập dữ liệu hiện tại không nhất thiết đại diện cho các tập dữ liệu trong tương lai (xem quá khớp) và các ``giải pháp'' được cho là giống như nhiễu.

\href{https://en.wikipedia.org/wiki/Statistical_analysis}{Statistical analysis} can be conducted when employing heuristics to estimate the probability of incorrect outcomes. To use a heuristic for solving a \href{https://en.wikipedia.org/wiki/Search_problem}{search problem} or a \href{https://en.wikipedia.org/wiki/Knapsack_problem}{knapsack problem}, it is necessary to check that the heuristic is \href{https://en.wikipedia.org/wiki/Admissible_heuristic}{admissible}. Given a heuristic function $h(v_i,v_g)$ meant to approximate the true optimal distance $d^\star(v_i,v_g)$ to the goal node $v_g$ in a \href{https://en.wikipedia.org/wiki/Directed_graph}{directed graph} $G$ containing $n$ total nodes or vertices labeled $v_0,v_1,\ldots,v_n$, ``admissible'' means roughly that the heuristic underestimates the cost to the goal or formally that $h(v_i,v_g)\le d^\star(v_i,v_g)$, $\forall(v_i,v_g)$ where $i,g\in\{0,1,\ldots,n\}$.

-- Phân tích thống kê có thể được tiến hành khi sử dụng phương pháp tìm kiếm để ước tính xác suất của các kết quả không chính xác. Để sử dụng phương pháp tìm kiếm để giải quyết bài toán tìm kiếm hoặc bài toán ba lô, cần phải kiểm tra xem phương pháp tìm kiếm đó có thể chấp nhận được hay không. Với 1 hàm phương pháp tìm kiếm $h(v_i,v_g)$ có nghĩa là xấp xỉ khoảng cách tối ưu thực sự $d^\star(v_i,v_g)$ đến nút đích $v_g$ trong đồ thị có hướng $G$ chứa tổng cộng $n$ nút hoặc đỉnh được gắn nhãn $v_0,v_1,\ldots,v_n$, ``có thể chấp nhận được'' có nghĩa là phương pháp tìm kiếm đó ước tính thấp chi phí đến đích hoặc chính thức là $h(v_i,v_g)\le d^\star(v_i,v_g)$, $\forall(v_i,v_g)$ trong đó $i,g\in\{0,1,\ldots,n\}$.

If a heuristic is not admissible, it may never find the goal, either by ending up in a dead end of graph $G$ or by skipping back \& forth between 2 nodes $v_i,v_j$ where $i,j\ne g$.

-- Nếu 1 phương pháp tìm kiếm không được chấp nhận, nó có thể không bao giờ tìm thấy mục tiêu, hoặc là kết thúc ở ngõ cụt của đồ thị $G$ hoặc bằng cách bỏ qua \& tiến giữa 2 nút $v_i,v_j$ trong đó $i,j\ne g$.

\noindent{\it Some types of heuristics}:
\begin{enumerate}
	\item \href{https://en.wikipedia.org/wiki/Constructive_heuristic}{Constructive heuristic}.
	\item \href{https://en.wikipedia.org/wiki/Metaheuristic}{Metaheuristic}: Methods for controlling \& tuning basic heuristic algorithms, usually with usage of memory \& learning.
	
	-- Siêu thuật toán tìm kiếm: Phương pháp kiểm soát \& điều chỉnh các thuật toán tìm kiếm cơ bản, thường sử dụng bộ nhớ \& học tập.
	\item \href{https://en.wikipedia.org/wiki/Matheuristics}{Matheuristics}: Optimization algorithms made by the interoperation of metaheuristics \& mathematical programming (MP) techniques.
	
	-- Thuật toán tìm kiếm Toán học: Các thuật toán tối ưu hóa được tạo ra bằng cách kết hợp các kỹ thuật siêu thuật toán và kỹ thuật Toán Tối Ưu (MP).
	\item Reactive search optimization: Methods using online ML principles for self-tuning of heuristics.
	
	-- Tối ưu hóa tìm kiếm phản ứng: Phương pháp sử dụng nguyên lý học máy trực tuyến để tự điều chỉnh phương pháp tìm kiếm.
\end{enumerate}

%------------------------------------------------------------------------------%

\subsection{Admissible heuristics -- Các phương pháp tìm kiếm có thể chấp nhận được}
\textbf{\textsf{Resources -- Tài nguyên.}}
\begin{enumerate}
	\item \href{https://en.wikipedia.org/wiki/Admissible_heuristic}{Wikipedia{\tt/}admissible heuristic}.
\end{enumerate}
In CS, specifically in algorithms related to \href{https://en.wikipedia.org/wiki/Pathfinding}{pathfinding}, a \href{https://en.wikipedia.org/wiki/Heuristic_function}{heuristic function} is said to be {\it admissible} if it never overestimates the cost of reaching the goal, i.e., the cost it estimates to reach the goal is not higher than the lowest possible cost from the current point in the path. I.e., it should act as a lower bound.

-- Trong khoa học máy tính, đặc biệt là trong các thuật toán liên quan đến tìm đường, 1 hàm heuristic được cho là có thể chấp nhận được nếu nó không bao giờ ước tính quá cao chi phí để đạt được mục tiêu, tức là chi phí mà nó ước tính để đạt được mục tiêu không cao hơn chi phí thấp nhất có thể từ điểm hiện tại trên đường đi. Nói cách khác, nó sẽ hoạt động như 1 giới hạn dưới.

It is related to the concept of \href{https://en.wikipedia.org/wiki/Consistent_heuristic}{consistent heuristics}. While all consistent heuristics are admissible, not all admissible heuristics are consistent.

-- Nó liên quan đến khái niệm về phương pháp tìm kiếm nhất quán. Trong khi tất cả các phương pháp tìm kiếm nhất quán đều có thể chấp nhận được, không phải tất cả các phương pháp tìm kiếm được chấp nhận đều nhất quán.
\begin{equation*}
	\mbox{consistent heuristic}\not\Leftarrow\Rightarrow\mbox{admissible heuristic}
\end{equation*}
{\bf Search algorithms.} An admissible heuristic is used to estimate the cost of reaching the goal state in an \href{https://en.wikipedia.org/wiki/Informed_search_algorithm}{informed search algorithm}. In order for a heuristic to be admissible to the search problem, the estimated cost must always be $\le$ the actual cost of reaching the goal state. The search algorithm uses the admissible heuristic to find an estimated optimal path to the goal state from the current node. E.g., in \href{https://en.wikipedia.org/wiki/A*_search}{$\rm A^\star$ search} the evaluation function, where $n$ is the current node, is $f(n) = g(n) + h(n)$, where $f(n)$: the evaluation function, $g(n)$: the cost from the start node to the current node, \& $h(n)$: estimated cost from current node to goal. $h(n)$ is calculated using the heuristic function. With a non-admissible heuristic, the $\rm A^\star$ algorithm could overlook the optimal solution to a search problem due to an overestimation in $f(n)$.

-- {\it Thuật toán tìm kiếm.} 1 phương pháp tìm kiếm có thể chấp nhận được được sử dụng để ước tính chi phí đạt được trạng thái mục tiêu trong 1 thuật toán tìm kiếm có thông tin. Để 1 phương pháp tìm kiếm có thể chấp nhận được đối với bài toán tìm kiếm, chi phí ước tính phải luôn bằng $\le$ chi phí thực tế để đạt được trạng thái mục tiêu. Thuật toán tìm kiếm sử dụng phương pháp tìm kiếm có thể chấp nhận được để tìm đường dẫn tối ưu ước tính đến trạng thái mục tiêu từ nút hiện tại. Ví dụ, trong tìm kiếm $\rm A^\star$, hàm đánh giá, trong đó $n$ là nút hiện tại, là $f(n) = g(n) + h(n)$, trong đó $f(n)$: hàm đánh giá, $g(n)$: chi phí từ nút bắt đầu đến nút hiện tại, \& $h(n)$: chi phí ước tính từ nút hiện tại đến mục tiêu. $h(n)$ được tính toán bằng cách sử dụng hàm phương pháp tìm kiếm. Với 1 phương pháp tìm kiếm không được chấp nhận, thuật toán $\rm A^\star$ có thể bỏ qua giải pháp tối ưu cho 1 bài toán tìm kiếm do ước tính quá cao trong $f(n)$.

{\bf Formulation.} $n$ is a node, $h$ is a heuristic, $h(n)$ is cost indicated by $h$ to reach a goal from $n$, $h^\star(n)$ is the optimal cost to reach a goal from $n$. Then $h(n)$ is {\it admissible} if $h(n)\le h^\star(n)$, $\forall$ node $n$.

{\bf Construction.} An admissible heuristic can be derived from a \href{https://en.wikipedia.org/wiki/Relaxation_(approximation)}{relaxed} version of the problem, or by information from pattern databases that store exact solutions to subproblems of the problem, or by using \href{https://en.wikipedia.org/wiki/Inductive_transfer}{inductive learning} methods.

-- 1 phương pháp tìm kiếm có thể chấp nhận được có thể được rút ra từ phiên bản đơn giản của bài toán, hoặc từ thông tin từ cơ sở dữ liệu mẫu lưu trữ các giải pháp chính xác cho các bài toán con của bài toán, hoặc bằng cách sử dụng các phương pháp học quy nạp.

%------------------------------------------------------------------------------%

\subsubsection{Optimality proof of admissible heuristics}
If an admissible heuristic is used in an algorithm that, per iteration, progresses only the path of lowest evaluation (current cost $+$ heuristic) of several candidate paths, terminates the moment its exploration reaches the goal \&, crucially, never closes all optimal paths before terminating (something that's possible with \href{https://en.wikipedia.org/wiki/A*_search_algorithm}{$\rm A^\star$ search algorithm} if special case isn't taken), then this algorithm can only terminate on an optimal path. To see why, consider the following proof by contradiction:

-- Nếu 1 phương pháp tìm kiếm có thể chấp nhận được được sử dụng trong 1 thuật toán, theo mỗi lần lặp, chỉ tiến triển theo đường đánh giá thấp nhất (phương pháp tìm kiếm chi phí hiện tại $+$) của 1 số đường ứng viên, kết thúc ngay khi quá trình khám phá của nó đạt đến mục tiêu \&, quan trọng là không bao giờ đóng tất cả các đường tối ưu trước khi kết thúc (điều này có thể thực hiện được với thuật toán tìm kiếm $\rm A^\star$ nếu không áp dụng trường hợp đặc biệt), thì thuật toán này chỉ có thể kết thúc trên 1 đường tối ưu. Để biết lý do, hãy xem xét bằng chứng phản chứng sau:

Assume such an algorithm managed to terminate on a path $T$ with a true cost $T_{\rm true}$ greater than the optimal path $S$ with true cost $S_{\rm true}$. I.e., before terminating, the evaluated cost of $T$ was $\le$ the evaluated cost of $S$ (or else $S$ would have been picked). Denote these evaluated costs $T_{\rm eval},S_{\rm eval}$, resp. The above can be summarized as follows,
\begin{equation*}
	S_{\rm true} < T_{\rm true},\ T_{\rm eval}\le S_{\rm eval}.
\end{equation*}
If our heuristic is admissible it follows that at this penultimate step $T_{\rm eval} = T_{\rm true}$ because any increase on the true cost by the heuristic on $T$ would be inadmissible \& the heuristic cannot be negative. On the other hand, an admissible heuristic would require that $S_{\rm eval}\le S_{\rm true}$ which combined with the above inequalities gives us $T_{\rm eval} < T_{\rm true}$ \& more specifically $T_{\rm eval}\ne T_{\rm true}$. As $T_{\rm eval},T_{\rm true}$ cannot be both equal \& unequal our assumption must have been false \& so it must be impossible to terminate on a more costly than optimal path.

-- Giả sử 1 thuật toán như vậy đã kết thúc trên 1 đường dẫn $T$ với chi phí thực $T_{\rm true}$ lớn hơn đường dẫn tối ưu $S$ với chi phí thực $S_{\rm true}$. Tức là, trước khi kết thúc, chi phí được đánh giá của $T$ bằng $\le$ chi phí được đánh giá của $S$ (nếu không thì $S$ đã được chọn). Ký hiệu các chi phí được đánh giá này là $T_{\rm eval},S_{\rm eval}$, tương ứng. Có thể tóm tắt những điều trên như sau,
\begin{equation*}
	S_{\rm true} < T_{\rm true},\ T_{\rm eval}\le S_{\rm eval}.
\end{equation*}
Nếu phương pháp heuristic của chúng ta có thể chấp nhận được thì theo đó tại bước áp chót này $T_{\rm eval} = T_{\rm true}$ vì bất kỳ sự gia tăng nào về chi phí thực tế của phương pháp heuristic trên $T$ đều không thể chấp nhận được \& phương pháp heuristic không thể là số âm. Mặt khác, 1 phương pháp heuristic có thể chấp nhận được sẽ yêu cầu $S_{\rm eval}\le S_{\rm true}$ kết hợp với các bất đẳng thức trên cho chúng ta $T_{\rm eval} < T_{\rm true}$ \& cụ thể hơn là $T_{\rm eval}\ne T_{\rm true}$. Vì $T_{\rm eval},T_{\rm true}$ không thể vừa bằng nhau \& không bằng nhau nên giả định của chúng ta phải sai \& do đó không thể kết thúc trên 1 đường dẫn tốn kém hơn đường dẫn tối ưu.

Although an admissible heuristic can guarantee final optimality, it is not necessarily efficient.

-- Mặc dù 1 phương pháp tìm kiếm có thể chấp nhận được có thể đảm bảo tính tối ưu cuối cùng, nhưng nó không nhất thiết phải hiệu quả.

%------------------------------------------------------------------------------%

\subsection{Consistent heuristic}
\textbf{\textsf{Resources -- Tài nguyên.}}
\begin{enumerate}
	\item \href{https://en.wikipedia.org/wiki/Consistent_heuristic}{Wikipedia{\tt/}consistent heuristic}.
\end{enumerate}
In the study of \href{https://en.wikipedia.org/wiki/Shortest_path_problem}{path-finding problems} in AI, a \href{https://en.wikipedia.org/wiki/Heuristic_function}{heuristic function} is said to be {\it consistent}, or {\it monotone}, if its estimate is always $\le$ the estimated distance from any neighboring vertex to the goal, plus the cost of reaching that neighbor.

Formally, for every node $N$ \& each \href{https://en.wikipedia.org/wiki/Successor_(graph_theory)#Direction}{successor} $P$ of $N$, the estimated cost of reaching the goal from $N$ is $\le$ the step cost of getting to $P$ plus the estimated cost of reaching the goal from $P$. I.e.:
\begin{equation*}
	h(N)\le c(N,P) + h(P),\ h(G) = 0,
\end{equation*}
where
\begin{itemize}
	\item $h$ is the consistent heuristic function
	\item $N$ is any node in the graph
	\item $P$is any descendant of $N$
\end{itemize}

%------------------------------------------------------------------------------%

\section{Scheduling problem -- Bài toán phân công}

\begin{dangtoan}
	Cài đặt \& đánh giá thực nghiệm 1 thuật giải heuristic cho bài toán phân công công việc (đơn giản), \& thuật giải cải tiến.
\end{dangtoan}

\begin{baitoan}[Roster -- Bài toán phân công đơn giản]
	1 đề án gồm $n\in\mathbb{N}^\star$ công việc \& các việc sẽ được thực hiện bởi $m\in\mathbb{N}^\star$ máy như nhau. Giả sử biết thời gian để 1 máy thực hiện việc thứ $i$  là $t_i$. Yêu cầu: Tìm phương án phân công sao cho thời gian hoàn thành toàn bộ công việc là thấp nhất.
	\item {\sf Input.} $m$: số máy, $n$: số việc, dãy $t[0],\ldots,t[n-1]$ với $t[i]$: thời gian để 1 máy thực hiện việc $i$.
	\item {\sf Output.} Bảng phân công tối ưu.
	\item {\sf Sample.}
	\begin{table}[H]
		\centering
		\begin{tabular}{|l|l|}
			\hline
			{\tt roster.inp} & {\tt roster.out} \\
			\hline
			3 10 &  \\
			4 9 5 2 7 6 10 8 7 5 &  \\
			\hline
		\end{tabular}
	\end{table}
\end{baitoan}
\noindent\textbf{\textsf{Thuật giải cho bài toán phân công đơn giản -- Pseudocode.}}
\begin{proof}[Mathematical analyse -- Phân tích Toán học]
	Gọi $n$ công việc là $w_1,\ldots,w_n$ ($w$: work), gọi $m$ máy là $M_1,\ldots,M_m$ (các máy này có công suất làm việc như nhau). Yêu cầu của bài toán: Phân hoạch tập $\{t_i\}_{i=1}^n$ thành $m$ tập con $T_1,\ldots,T_m$ lần lượt có số phần tử là $n_1,\ldots,n_m$, i.e., $|T_i| = n_i$, $\forall i = 1,\ldots,m$.
\end{proof}

\begin{proof}[Computer Science analyse -- Phân tích Tin học]
	
\end{proof}

\begin{verbatim}
for (i = 0; i < n; i++) {
    chọn việc i chưa phân công có thời gian thực hiện cao nhất;
    chọn máy m có thời gian làm việc thấp nhất;
    bố trí việc i cho máy m;
}
\end{verbatim}

\begin{itemize}
	\item Input: \url{https://github.com/NQBH/advanced_STEM_beyond/blob/main/AI/Python/roster.inp}.
	\item Output: \url{https://github.com/NQBH/advanced_STEM_beyond/blob/main/AI/Python/roster.out}.
	\item Python: \url{https://github.com/NQBH/advanced_STEM_beyond/blob/main/AI/Python/roster.py}.
\begin{verbatim}
m, n = map(int, input().split())
t = [int(x) for x in input().split()]
d = [0] * m # devices/machines's current accomplished time
t.sort(reverse = True) # descending order
for i in range(n):
    current_max_work = t[0] # current longest work
    t.pop(0) # remove current longest work
    # print(t)
    d.sort() # ascending order
    # print(d)
    d[0] += int(current_max_work) # laziest device takes longest work
    # print(d)
print(max(d))
\end{verbatim}
\end{itemize}
Các bước {\tt print} để mô phỏng quá trình giao công việc cho các máy để tiện hình dung, không bắt buộc.

\begin{baitoan}[Extended roster -- Bài toán phân công mở rộng]
	Có $n\in\mathbb{N}^\star$ công việc \& $m\in\mathbb{N}^\star$ máy không đồng nhất. Biết thời gian máy $i$ làm việc $j$ là $t_{ij} = t[i][j]$. Yêu cầu: Lập bảng phân công tối ưu.
	\item {\sf Input.} $m$: số máy, $n$: số việc, array 2 chiều $t[i][j]$: thời gian để máy $i$ thực hiện việc $j$.
	\item {\sf Output.} Bảng phân công tối ưu.
	\item {\sf Sample.}
	\begin{table}[H]
		\centering
		\begin{tabular}{|l|l|}
			\hline
			\verb|extended_roster.inp| & \verb|extended_roster.out| \\
			\hline
			3 8 &  \\
			4 5 4 10 8 6 12 8 &  \\
			7 5 7 3 9 7 9 5 &  \\
			10 6 7 12 10 6 5 7 &  \\
			\hline
		\end{tabular}
	\end{table}
\end{baitoan}
{\sf Cách phát biểu khác của bài toán phân công mở rộng.} Có $n\in\mathbb{N}^\star$ công việc sẽ được phân công cho $m\in\mathbb{N}^\star$ người thực hiện, mỗi việc được phân công cho 1 người. Giả sử ta biết thời gian $t_{ij} = t[i][j]$ cần để người thứ $i$ thực hiện công việc thứ $j$, $\forall i = 1,\ldots,m$, $\forall j = 1,\ldots,n$. Tìm 1 phương pháp phân công sao cho thời gian hoàn thành tất cả các công việc là thấp nhất.

%------------------------------------------------------------------------------%

\subsection{Optimal job scheduling -- Lên lịch công việc tối ưu}
\textbf{\textbf{Resources -- Tài nguyên.}}
\begin{enumerate}
	\item \href{https://en.wikipedia.org/wiki/Optimal_job_scheduling}{Wikipedia{\tt/}optimal job scheduling}.
\end{enumerate}
{\it Optimal job scheduling} is a class of \href{https://en.wikipedia.org/wiki/Optimization_problem}{optimization problem} related to \href{https://en.wikipedia.org/wiki/Scheduling_(computing)}{scheduling}. The inputs to such problems are a list of \href{https://en.wikipedia.org/wiki/Job_(computing)}{jobs} (also called {\it processes} or {\it tasks}) \& a list of \href{https://en.wikipedia.org/wiki/Processor_(computing)}{machines} (also called {\it processors} or {\it workers}). The required output is a {\it schedule} -- an assignment of jobs to machines. The schedule should optimize a certain \href{https://en.wikipedia.org/wiki/Objective_function}{objective function}. In the literature, problems of optimal job scheduling are often called {\it machine scheduling, processor scheduling, multiprocessor scheduling}, or just {\it scheduling}.

-- Lên lịch công việc tối ưu là 1 lớp các vấn đề tối ưu hóa liên quan đến việc lên lịch. Đầu vào cho các vấn đề như vậy là 1 danh sách các công việc (còn gọi là quy trình hoặc tác vụ) và 1 danh sách các máy (còn gọi là bộ xử lý hoặc công nhân). Đầu ra bắt buộc là 1 lịch trình – 1 sự phân công các công việc cho các máy. Lịch trình này phải tối ưu hóa 1 hàm mục tiêu nhất định. Trong tài liệu, các vấn đề về lập lịch công việc tối ưu thường được gọi là lập lịch máy, lập lịch bộ xử lý, lập lịch đa bộ xử lý hoặc chỉ là lập lịch.

There are many different problems of optimal job scheduling, different in the nature of jobs, the nature of machines, the restrictions on the schedule, \& the objective function. A convenient {\it notation} for optimal scheduling problems was introduced by \href{https://en.wikipedia.org/wiki/Ronald_Graham}{\sc Ronald Graham}, \href{https://en.wikipedia.org/wiki/Eugene_Lawler}{\sc Eugene Lawler}, \href{https://en.wikipedia.org/wiki/Jan_Karel_Lenstra}{\sc Jan Karel Lenstra}, \& \href{https://en.wikipedia.org/wiki/Alexander_Rinnooy_Kan}{\sc Alexander Rinnooy Kan}. It consists of 3 fields: $\alpha,\beta,\gamma$. Each field may be a comma separated list of words. The $\alpha$ field describes the machine environment, $\beta$ the job characteristics \& constraints, \& $\gamma$ the objective function. Since its introduction in the late 1970s the notation has been constantly extended, sometimes inconsistently. As a result, today there are some problems that appear with distinct notations in several papers.

-- Có rất nhiều bài toán khác nhau về lập kế hoạch công việc tối ưu, khác nhau về tính chất công việc, tính chất của máy móc, những hạn chế về tiến độ, \& hàm mục tiêu. Một {\it notation} thuận tiện cho các vấn đề lập kế hoạch tối ưu đã được giới thiệu bởi \href{https://en.wikipedia.org/wiki/Ronald_Graham}{\sc Ronald Graham}, \href{https://en.wikipedia.org/wiki/Eugene_Lawler}{\sc Eugene Lawler}, \href{https://en.wikipedia.org/wiki/Jan_Karel_Lenstra}{\sc Jan Karel Lenstra}, \& \href{https://en.wikipedia.org/wiki/Alexander_Rinnooy_Kan}{\sc Alexander Rinnooy Kan}. Nó bao gồm 3 trường: $\alpha,\beta,\gamma$. Mỗi trường có thể là một danh sách các từ được phân tách bằng dấu phẩy. Trường $\alpha$ mô tả môi trường máy, $\beta$ mô tả đặc điểm công việc \& ràng buộc, \& $\gamma$ mô tả hàm mục tiêu. Kể từ khi được giới thiệu vào cuối những năm 1970, ký hiệu này đã liên tục được mở rộng, đôi khi không nhất quán. Do đó, hiện nay có một số vấn đề xuất hiện với các ký hiệu riêng biệt trong một số bài báo.

%------------------------------------------------------------------------------%

\subsubsection{Single-stage jobs vs. multi-stage jobs -- Công việc một giai đoạn so với công việc nhiều giai đoạn}
In the simpler optimal job scheduling problems, each job $j$ consists of a single execution phase, with a given processing time $p_j$. In more complex variants, each job consists of several execution phases, which may be executed in sequence or in parallel.

-- Trong các bài toán lập lịch công việc tối ưu đơn giản hơn, mỗi công việc $j$ bao gồm một giai đoạn thực hiện duy nhất, với thời gian xử lý nhất định $p_j$. Trong các biến thể phức tạp hơn, mỗi công việc bao gồm một số giai đoạn thực hiện, có thể được thực hiện theo trình tự hoặc song song.

%------------------------------------------------------------------------------%

\subsubsection{Machine environments -- Môi trường máy móc}
In {\it single-stage job scheduling problems}, there are 4 main categories of machine environments:
\begin{enumerate}
	\item {\bf1}: \href{https://en.wikipedia.org/wiki/Single-machine_scheduling}{single-machine scheduling}. There is a single machine.
	\item {\bf P}: \href{https://en.wikipedia.org/wiki/Identical-machines_scheduling}{identical-machines scheduling}. There are $m\in\mathbb{N}$, $m\ge2$, parallel machines, \& they are identical. Job $j$ takes time $p_j\in(0,\infty)$ on any machine it is scheduled to.
	\item {\bf Q}: \href{https://en.wikipedia.org/wiki/Uniform-machines_scheduling}{uniform-machines scheduling}. There are $m\in\mathbb{N}$, $m\ge2$, parallel machines, \& they have different given speeds. Job $j$ on machine $i$ takes time $\frac{p_j}{s_i}$.
	\item {\bf R}: \href{https://en.wikipedia.org/wiki/Unrelated-machines_scheduling}{unrelated-machines scheduling}. There are $m$ parallel machines, \& they are unrelated -- job $j$ on machine $i$ takes time $p_{ij}$.
\end{enumerate}
These letters might be followed by the number of machines, which is then fixed. E.g., {\bf P2} indicates that there are 2 parallel identical machines. {\bf Pm} indicates that there are $m\in\mathbb{N}$, $m\ge2$, parallel identical machines, where $m$ is a fixed parameter. In contrast, {\bf P} indicates that there are $m$ parallel identical machines, but $m$ is not fixed (it is part of the input).

In {\it multi-stage job scheduling problems}, there are other options of the machine environments:
\begin{enumerate}
	\item {\bf O}: \href{https://en.wikipedia.org/wiki/Open-shop_scheduling}{open-shop problem}. Every job $j$ consists of $m$ operations $O_{ij}$ for $i\in[m]$. The operations can be scheduled in {\it any} order. Operation $O_{ij}$ must be processed for $p_{ij}$ units on machine $i$.
	\item {\bf F}: \href{https://en.wikipedia.org/wiki/Flow-shop_scheduling}{Flow-shop problem}. Every job $j$ consists of $m$ operations $O_{ij}$ for $i\in[m]$, to be scheduled in the given order. Operation $O_{ij}$ must be processed for $p_{ij}$ units on machine $i$.
	\item {\bf J}: \href{https://en.wikipedia.org/wiki/Job-shop_scheduling}{job-shop problem}. Every job $j$ consists of $n_j$ operations $O_{kj}$ for $k\in[n_j]$, to be scheduled in that order. Operation $O_{kj}$ must be processed for $p_{kj}$ units on a {\it dedicated} machine $\mu_{kj}$ with $\mu_{kj}\ne\mu_{k'j}$ for $k\ne k'$.
\end{enumerate}

%------------------------------------------------------------------------------%

\subsubsection{Job characteristics -- Đặc điểm công việc}
All processing times are assumed to be integers. In some odler research papers however they are assumed to be rationals.
\begin{enumerate}
	\item $p_i = p$, or $p_{ij} = p$: the processing time is equal for all jobs.
	\item $p_i = 1$, or $p_{ij} = 1$: the processing time is equal to $1$ time-unit for all jobs.
	\item $r_j$: for each job a release time is given before which it cannot be scheduled, default is 0.
	\item online-$r_j$: an online problem. Jobs are revealed at their release times. In this context the performance of an algorithm is measured by its \href{https://en.wikipedia.org/wiki/Competitive_analysis_(online_algorithm)}{competitive ratio}.
	\item $d_j$: for each job a due date is given. The idea is that every job should complete before its due date \& there is some penalty for jobs that complete late. This penalty is denoted in the objective value. The presence of the job characteristic $d_j$ is implicitly assumed \& not denoted in the problem name, unless there are some restrictions as e.g. $d_j = d$, assuming that all due dates are equal to some given date.
	\item $\bar{d}_j$: for each job a strict deadline is given. Every job must complete before its deadline.
	\item {\tt pmtn}: Jobs can be preempted \& resumed possibly on another machine. Sometimes also denoted by {\tt prmp}/
	\item ${\rm size}_j$: each job comes with a number of machines on which it must be scheduled at the same time. The default is 1. This is an important parameter in the variant called \href{https://en.wikipedia.org/wiki/Parallel_task_scheduling}{parallel task scheduling}.
\end{enumerate}

\paragraph{Precedence relations.}

\paragraph{Transportation delays.}

\paragraph{Various constraints.}

%------------------------------------------------------------------------------%

\subsubsection{Objective functions -- Các hàm mục tiêu}
Usually the goal is to minimize some objective value. 1 difference is the notation $\sum_j U_j$ where the goal is to maximize the number of jobs that complete before their deadline. This is also called the {\it throughput}. The objective value can be sum, possibly weighted by some given priority weights $w_j$ per job.

%------------------------------------------------------------------------------%

\subsection{Fractional job scheduling -- Lập lịch công việc theo từng phần}
\textbf{\textbf{Resources -- Tài nguyên.}}
\begin{enumerate}
	\item \href{https://en.wikipedia.org/wiki/Fractional_job_scheduling}{Wikipedia{\tt/}fractional job scheduling}.
\end{enumerate}
{\it Fractional job scheduling} is a variant of \href{https://en.wikipedia.org/wiki/Optimal_job_scheduling}{optimal job scheduling} in which it is allowed to break jobs into parts \& process each part separately on the same or a different machine. Breaking jobs into parts may allow for improving the overall performance, e.g., decreasing the makespan. Moreover, the computational problem of finding an optimal schedule may become easier, as some of the optimization variables become continuous. On the other hand, breaking jobs apart might be costly.

-- Lập lịch công việc theo phần là 1 biến thể của lập lịch công việc tối ưu trong đó cho phép chia nhỏ công việc thành nhiều phần và xử lý từng phần riêng biệt trên cùng 1 máy hoặc 1 máy khác. Chia nhỏ công việc thành nhiều phần có thể cho phép cải thiện hiệu suất chung, ví dụ, giảm thời gian hoàn thành. Hơn nữa, vấn đề tính toán để tìm lịch trình tối ưu có thể trở nên dễ dàng hơn, vì 1 số biến tối ưu hóa trở nên liên tục. Mặt khác, việc chia nhỏ công việc có thể tốn kém.

There are several variants of job scheduling problems in which it is allowed to break jobs apart. They can be broadly classified into {\it quyền ưu tiên \& tách, chia nhỏ ra}.
\begin{enumerate}
	\item In the preemption variants, different parts of a job must be processed at different times. In the \href{https://en.wikipedia.org/wiki/Optimal_job_scheduling}{3-field notation}, they are denoted by {\it pmtn}. They were 1st studied by {\sc McNaughton}.
	\item In the splitting variants, different parts of a job may be processed simultaneously on different machines. They are denoted by {\it split} \& were introduced by {\sc Xing \& Zhang}.
\end{enumerate}
-- Có 1 số biến thể của các vấn đề lập lịch công việc trong đó cho phép chia nhỏ các công việc. Chúng có thể được phân loại thành {\it preemption \& splitting}.
\begin{enumerate}
	\item Trong các biến thể preemption, các phần khác nhau của 1 công việc phải được xử lý tại các thời điểm khác nhau. Trong \href{https://en.wikipedia.org/wiki/Optimal_job_scheduling}{ký hiệu 3 trường}, chúng được ký hiệu là {\it pmtn}. Chúng được nghiên cứu lần đầu tiên bởi {\sc McNaughton}.
	\item Trong các biến thể chia nhỏ, các phần khác nhau của 1 công việc có thể được xử lý đồng thời trên các máy khác nhau. Chúng được ký hiệu là {\it split} \& được giới thiệu bởi {\sc Xing \& Zhang}.
\end{enumerate}
For more details on fractional job scheduling, see, e.g., \href{https://en.wikipedia.org/wiki/Fractional_job_scheduling}{Wikipedia{\tt/}fractional job scheduling}.

%------------------------------------------------------------------------------%

\subsection{Bài toán tô màu đồ thị -- Graph coloring problem}

\begin{baitoan}[Bài toán tô màu các đỉnh đồ thị -- Graph coloring problem]
	Có 1 đồ thị vô hướng đơn giản. Ta muốn tìm cách tô màu cho các đỉnh của đồ thị sao cho 2 đỉnh cạnh nhau phải có màu khác nhau. Yêu cầu: Tìm phương án tô sao cho số màu sử dụng là ít nhất.
	\item {\sf Input.} Đồ thị vô hướng đơn giản.
	\item {\sf Output.} Mỗi đỉnh tô màu gì.
\end{baitoan}
{\sf 1 thuật giải heuristic.} Sử dụng nguyên lý thứ tự:
\begin{verbatim}
for (i = 0; i < n; i++) {
    chọn đỉnh s chưa tô có d[s] lớn nhất;
    chọn màu: ưu tiên tô đỉnh s bằng 1 trong các màu đã sử dụng, nếu không được thì sử dụng màu mới;
    sau khi tô màu cho đỉnh s: với mỗi đỉnh x cạnh, giảm d[x]; ???
}
\end{verbatim}
$d[x]$: số đỉnh cạnh $x$ mà chưa tô màu. ???

%------------------------------------------------------------------------------%

\subsection{Shortest path problem -- Bài toán đường đi ngắn nhất}

\begin{baitoan}
	Cài đặt \& thử nghiệm $\rm A^*$. So sánh với Dijkstra nếu được.
	\item {\sf Input.} $G = (V,E)$ có trọng số dương, đỉnh xuất phát $a$, đỉnh mục tiêu $z$. Thông tin bổ sung: $h(x)$: ước lượng khoảng cách từ $a$ đến mục tiêu $z$.
	\item {\sf Output.} Đường đi ngắn nhất shortest path SP từ $a$ đến $z$.
\end{baitoan}

%------------------------------------------------------------------------------%

\subsection{Traveling salesman problem (TSP) -- Bài toán người bán hàng du lịch}
\textbf{\textbf{Resources -- Tài nguyên.}}
\begin{enumerate}
	\item \href{https://en.wikipedia.org/wiki/Travelling_salesman_problem}{Wikipedia{\tt/}traveling salesman problem}.
\end{enumerate}
An example of approximation is described by \href{https://en.wikipedia.org/wiki/Jon_Bentley_(computer_scientist)}{\sc Jon Bentley} for solving the \href{https://en.wikipedia.org/wiki/Travelling_salesman_problem}{traveling salesman problem} (TSP):

\begin{problem}[Original Traveling Salesman Problem (TSP)]
	Given a list of cities \& the distances between each pair of cities, what is the shortest possible route that visits each city exactly once \& returns to the origin city?
	
	-- Cho 1 danh sách các thành phố \& khoảng cách giữa mỗi cặp thành phố, đâu là tuyến đường ngắn nhất có thể đi qua mỗi thành phố đúng 1 lần \& quay trở lại thành phố ban đầu?
\end{problem}
so as to select the order to draw using a \href{https://en.wikipedia.org/wiki/Pen_plotter}{pen plotter}. TSP is known to be NP-hard so an optimal solution for even a moderate size problem is difficult to solve. Instead, the \href{https://en.wikipedia.org/wiki/Greedy_algorithm}{greedy algorithm} can be used to give a good but not optimal solution (it is an approximation to the optimal answer) in a reasonably short amount of time. The greedy algorithm heuristic says to pick whatever is currently the best next step regardless of whether that prevents (or even makes impossible) good steps later. It is a heuristic in the sense that practice indicates it is a good enough solution, while theory indicates that there are better solutions (\& even indicates how much better, in some cases).

-- {\sc Jon Bentley} đã đưa ra 1 ví dụ về phép xấp xỉ để giải bài toán người bán hàng du lịch (TSP): để chọn thứ tự vẽ bằng bút vẽ. TSP được biết là NP-khó nên giải pháp tối ưu cho ngay cả bài toán có kích thước vừa phải cũng khó giải. Thay vào đó, thuật toán tham lam có thể được sử dụng để đưa ra giải pháp tốt nhưng không tối ưu (là phép xấp xỉ với câu trả lời tối ưu) trong 1 khoảng thời gian khá ngắn. Thuật toán tham lam nói rằng hãy chọn bất kỳ bước tiếp theo nào hiện là tốt nhất bất kể điều đó có ngăn cản (hoặc thậm chí khiến không thể) thực hiện các bước tốt sau này hay không. Đây là thuật toán theo nghĩa là thực hành chỉ ra rằng đó là giải pháp đủ tốt, trong khi lý thuyết chỉ ra rằng có những giải pháp tốt hơn (\& thậm chí chỉ ra tốt hơn bao nhiêu, trong 1 số trường hợp).

\begin{problem}[Traveling Salesman Problem (TSP)]
	The traveling salesman must visit every city in this territory exactly once \& then return to the starting point; given the cost of travel between all cities, how should he plan his itinerary for minimum total cost of the entire tour?
\end{problem}
TSP $\in$ NP-Complete.

\begin{remark}[Approximate TSP by GAs]
	We shall discuss a single possible approach to approximate the TSP by genetic algorithms (GAs).
\end{remark}

%------------------------------------------------------------------------------%

\subsection{15 Puzzle Problem}
\textbf{\textbf{Resources -- Tài nguyên.}}
\begin{enumerate}
	\item \href{https://en.wikipedia.org/wiki/Admissible_heuristic}{Wikipedia{\tt/}admissible heuristic}.
	\item \href{https://en.wikipedia.org/wiki/Fifteen_puzzle}{Wikipedia{\tt/}15 puzzle}.
\end{enumerate}
2 different examples of admissible heuristics apply to the \href{https://en.wikipedia.org/wiki/Fifteen_puzzle}{Wikipedia{\tt/}15 puzzle} problem:
\begin{itemize}
	\item \href{https://en.wikipedia.org/wiki/Hamming_distance}{Hamming distance}
	\item \href{https://en.wikipedia.org/wiki/Manhattan_distance}{Manhattan distance}
\end{itemize}
The \href{https://en.wikipedia.org/wiki/Hamming_distance}{Hamming distance} is the total number of misplaced tiles. It is clear that this heuristic is admissible since the total number of moves to order the tiles correctly is at least the number of misplaced tiles (each tile not in place must be moved at least once). The cost (number of moves) to the goal (an ordered puzzle) is at least the \href{https://en.wikipedia.org/wiki/Hamming_distance}{Hamming distance} of the puzzle.

-- Khoảng cách Hamming là tổng số ô bị đặt sai vị trí. Rõ ràng là phương pháp tìm kiếm này có thể chấp nhận được vì tổng số lần di chuyển để sắp xếp các ô đúng ít nhất bằng số ô bị đặt sai vị trí (mỗi ô không đúng vị trí phải được di chuyển ít nhất 1 lần). Chi phí (số lần di chuyển) đến đích (một câu đố có thứ tự) ít nhất bằng khoảng cách Hamming của câu đố.

The Manhattan distance of a puzzle is defined as:
\begin{equation*}
	h(n) = \sum_{\rm all\ tiles} {\rm distance}(\mbox{tile},\mbox{correct position}).
\end{equation*}
Consider the puzzle below in which the player wishes to move each tile s.t. the numbers are ordered. The Manhattan distance is an admissible heuristic in this case because every tile will have to be moved at least the number of spots in between itself \& its correct position.
z
-- Xem xét câu đố bên dưới trong đó người chơi muốn di chuyển từng ô theo thứ tự các số. Khoảng cách Manhattan là 1 phép thử có thể chấp nhận được trong trường hợp này vì mỗi ô sẽ phải được di chuyển ít nhất số điểm giữa nó \& vị trí chính xác của nó.

\begin{baitoan}[Tính khoảng cách Hamming \& khoảng cách Manhattan]
	 (a) Cho 1 dãy hoán vị của $[15]$ theo thứ tự sắp xếp trái sang phải, trên xuống dưới. Tính khoảng cách Hamming \& khoảng cách Manhattan của hoán vị này.
	 \item {\sf Input.} Dòng 1 chứa số bộ test $t\in\mathbb{N}^\star$. Với $t$ dòng tiếp theo, mỗi dòng chứa đúng 1 hoán vị $\{a_n\}_{n=1}^{15} = a_1,a_2,\ldots,a_{15}$ của $[15]$.
	 \item {\sf Output.} Khoảng cách Hamming \& khoảng cách Manhattan của hoán vị $\{a_n\}_{n=1}^{15}$.
	 \item {\sf Sample.}
	 \begin{table}[H]
	 	\centering
	 	\begin{tabular}{|l|l|}
	 		\hline
	 		\verb|15_puzzle.inp| & \verb|15_puzzle.out| \\
	 		\hline
	 		1 & $h(n) = 36$ \\
	 		4 6 3 8 7 12 9 14 15 13 1 5 2 10 11 &  \\
	 		\hline
	 	\end{tabular}
	 \end{table}
	 \noindent(b) Mở rộng bài toán từ $15$ thành $n\in\mathbb{N}^\star$.
\end{baitoan}

%------------------------------------------------------------------------------%

\section{Miscellaneous}

\subsection{Contributors}

\begin{enumerate}
	\item PGS. TS. {\sc Đỗ Văn Nhơn}. Slide Bài Giảng \& Bài Tập môn học Introduction to Artificial Intelligence -- Nhập Môn Trí Tuệ Nhân Tạo.
	\item {\sc Vòng Lỷ Nàm Phúc.} C++ codes for scheduling problems.
\end{enumerate}

%------------------------------------------------------------------------------%

\printbibliography[heading=bibintoc]
	
\end{document}