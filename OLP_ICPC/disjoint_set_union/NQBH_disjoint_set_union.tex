\documentclass{article}
\usepackage[backend=biber,natbib=true,style=alphabetic,maxbibnames=50]{biblatex}
\addbibresource{/home/nqbh/reference/bib.bib}
\usepackage[utf8]{vietnam}
\usepackage{tocloft}
\renewcommand{\cftsecleader}{\cftdotfill{\cftdotsep}}
\usepackage[colorlinks=true,linkcolor=blue,urlcolor=red,citecolor=magenta]{hyperref}
\usepackage{amsmath,amssymb,amsthm,enumitem,fancyvrb,float,graphicx,mathtools,tikz}
\usetikzlibrary{angles,calc,intersections,matrix,patterns,quotes,shadings}
\allowdisplaybreaks
\newtheorem{assumption}{Assumption}
\newtheorem{baitoan}{Bài toán}
\newtheorem{cauhoi}{Câu hỏi}
\newtheorem{conjecture}{Conjecture}
\newtheorem{corollary}{Corollary}
\newtheorem{dangtoan}{Dạng toán}
\newtheorem{definition}{Definition}
\newtheorem{dinhly}{Định lý}
\newtheorem{dinhnghia}{Định nghĩa}
\newtheorem{example}{Example}
\newtheorem{ghichu}{Ghi chú}
\newtheorem{hequa}{Hệ quả}
\newtheorem{hypothesis}{Hypothesis}
\newtheorem{lemma}{Lemma}
\newtheorem{luuy}{Lưu ý}
\newtheorem{nhanxet}{Nhận xét}
\newtheorem{notation}{Notation}
\newtheorem{note}{Note}
\newtheorem{principle}{Principle}
\newtheorem{problem}{Problem}
\newtheorem{proposition}{Proposition}
\newtheorem{question}{Question}
\newtheorem{remark}{Remark}
\newtheorem{theorem}{Theorem}
\newtheorem{vidu}{Ví dụ}
\usepackage[left=1cm,right=1cm,top=5mm,bottom=5mm,footskip=4mm]{geometry}
\def\labelitemii{$\circ$}
\DeclareRobustCommand{\divby}{%
    \mathrel{\vbox{\baselineskip.65ex\lineskiplimit0pt\hbox{.}\hbox{.}\hbox{.}}}%
}
\setlist[itemize]{leftmargin=*}
\setlist[enumerate]{leftmargin=*}

\title{Disjoint Set Union (DSU) -- Hợp Tập Hợp Rời Rạc}
\author{Nguyễn Quản Bá Hồng\footnote{A scientist- {\it\&} creative artist wannabe, a mathematics {\it\&} computer science lecturer of Department of Artificial Intelligence {\it\&} Data Science (AIDS), School of Technology (SOT), UMT Trường Đại học Quản lý {\it\&} Công nghệ TP.HCM, Hồ Chí Minh City, Việt Nam.\\E-mail: {\sf nguyenquanbahong@gmail.com} {\it\&} {\sf hong.nguyenquanba@umt.edu.vn}. Website: \url{https://nqbh.github.io/}. GitHub: \url{https://github.com/NQBH}.}}
\date{\today}

\begin{document}
\maketitle
\begin{abstract}
    This text is a part of the series {\it Some Topics in Advanced STEM \& Beyond}:

    {\sc url}: \url{https://nqbh.github.io/advanced_STEM/}.

    Latest version:
    \begin{itemize}
        \item {\it Disjoint Set Union (DSU) -- Hợp Tập Hợp Rời Rạc}.

        PDF: {\sc url}: \url{.pdf}.

        \TeX: {\sc url}: \url{.tex}.
        \item {\it }.

        PDF: {\sc url}: \url{.pdf}.

        \TeX: {\sc url}: \url{.tex}.
    \end{itemize}
\end{abstract}
\tableofcontents

%------------------------------------------------------------------------------%

\section{Introduction to Disjoint Set Union -- Nhập Môn Hợp Tập Hợp Rời Rạc}
\textbf{\textsf{Resources -- Tài nguyên.}}
\begin{enumerate}
    \item \href{https://cp-algorithms.com/data_structures/disjoint_set_union.html}{Algorithms for Competitive Programming{\tt/}disjoint set union}.

    \item {\sc Benjamin Qi, Andrew Wang, Nathan Gong, Michael Cao}. \href{https://usaco.guide/gold/dsu?lang=cpp}{USACO Guide{\tt/}Disjoint Set Union}.

    {\sf Abstract.} The Disjoint Set Union (DSU) data structure, which allows you to add edges to a graph \& test whether 2 vertices of a graph are connected.

    -- Cấu trúc dữ liệu Disjoint Set Union (DSU), cho phép bạn thêm các cạnh vào đồ thị \& kiểm tra xem 2 đỉnh của đồ thị có được kết nối hay không.

    \item {\sc Ngô Quang Nhật}. \href{https://wiki.vnoi.info/algo/data-structures/disjoint-set-union}{VNOI Wiki{\tt/}Disjoint Set Union}.

    \item \href{https://en.wikipedia.org/wiki/Disjoint-set_data_structure}{Wikipedia{\tt/}disjoint-set data structure}.
\end{enumerate}
Disjoint Set Union (abbr., DSU) là 1 cấu trúc dữ liệu hữu dụng, thường xuất hiện trong các kỳ thi Lập trình Thi Đấu, \& có thể được dùng để quản lý 1 cách hiệu 1 tập hợp của các tập hợp.

\begin{baitoan}
    \label{prob: query connectedness}
    Cho 1 đồ thị $G = (V,E)$ có $|V| = n\in\mathbb{N}^\star$ đỉnh, ban đầu không có cạnh nào, $E = \emptyset$. Ta cần xử lý 2 loại truy vấn:
    \begin{enumerate}
        \item Thêm 1 cạnh giữa 2 đỉnh $x,y\in V$ trong đồ thị, i.e., $E = E\cup\{\{x,y\}\}$ nếu $G$ là đồ thị vô hướng \& $E = E\cup\{(x,y)\}$ nếu $G$ là đồ thị có hướng (trước tiên ta chỉ xét trường hợp đồ thị vô hướng cho đơn giản).
        \item In ra {\tt yes} nếu như 2 đỉnh $x,y$ nằm trong cùng 1 thành phần liên thông. In ra {\tt no} nếu ngược lại.
    \end{enumerate}
\end{baitoan}

%------------------------------------------------------------------------------%

\subsection{Data Structure Disjoint Set Union -- Cấu trúc dữ liệu Disjoint Set Union}
Cho tiện, ta đánh số $n$ đỉnh của đồ thị $G$ bởi $1,2,\ldots,n$ (trường hợp $n$ đỉnh được dán nhãn bởi $v_1,v_2,\ldots,v_n$ hoàn toàn tương tự vì ta có thể làm việc trên chỉ số $i$ của $v_i$), khi đó $V = [n]$. Giả sử $G$ có $c\coloneqq$ \verb|num_connected_component| $\in\mathbb{N}^\star$ (số thành phần liên thông) $C_1,C_2,\ldots,C_c$ với $\{C_i\}_{i=1}^c$ là 1 phân hoạch của $V = [n]$, i.e.:
\begin{equation*}
    \bigcup_{i=1}^c C_i = [n],\ C_i\cap C_j = \emptyset,\ \forall i,j\in[c],\ i\ne j.
\end{equation*}
Nếu ta coi mỗi đỉnh của đồ thị $G = (V,E)$ là 1 phần tử \& mỗi thành phần liên thông (connected component) trong đồ thị là 1 tập hợp, truy vấn 1 sẽ trở thành gộp 2 tập hợp lần lượt chứa phần tử $x,y$ thành 1 tập hợp mới \& truy vấn 2 trở thành việc hỏi 2 phần tử $x,y$ có nằm trong cùng 1 tập hợp không.

Để tiện tính toán \& lý luận về mặt toán học cho riêng cấu trúc dữ liệu DSU, sau đây là 1 định nghĩa lai Toán--Tin mang tính cá nhân của tác giả [NQBH], hoàn toàn không chính thống trong Lý thuyết Đồ thị:

\begin{dinhnghia}[Chỉ số thành phần liên thông]
    \label{def: index component}
    Cho đồ thị vô hướng $G = (V,E)$ với $V = [n]$. Gọi $C(i)\subset[n]$ là thành phần liên thông của $G = (V,E)$ chứa đỉnh $i\in[n]$ \& gọi chỉ số của thành phần liên thông chứa đỉnh $i$ là ${\rm cid}(i)$, i.e., $i\in C_{{\rm cid}(i)}\equiv C(i)$, với hàm ${\rm cid}:[n]\to[c]$ được gọi là {\rm hàm chỉ số liên thông}.
\end{dinhnghia}
Với định nghĩa \ref{def: index component}, ta có ngay
\begin{equation*}
    \left\{\begin{split}
        &i\in C(i) = C_{{\rm cid}(i)}\subset[n],\\
        &i,j\mbox{ are connected},\ \forall j\in C(i).
    \end{split}\right.\ \forall i\in[n].
\end{equation*}
Ở đây, ta coi mỗi đỉnh của đồ thị tự liên thông với chính nó theo nghĩa đỉnh đó đến được (reachability) chính đỉnh đó thông qua 1 đường đi có độ dài 0, được gọi là 1 {\it đường đi tầm thường}, chứ không phải theo nghĩa khuyên (loop).

\begin{lemma}[A characterization of connectedness -- 1 đặc trưng hóa của tính liên thông]
    \label{lem: characterization connectedness}
    Cho đồ thị vô hướng $G = (V,E)$.
    (i) 2 đỉnh trên 1 đồ thị $G$ không liên thông với nhau, i.e., không có đường đi nào trên $G$ nối chúng khi \& chỉ khi chúng thuộc 2 thành phần liên thông khác nhau, i.e.,
    \begin{equation*}
        i,j\mbox{ are not connected}\Leftrightarrow C(i)\ne C(j)\Leftrightarrow C(i)\cap C(j) = \emptyset\Leftrightarrow{\rm cid}(i)\ne{\rm cid}(j),\ \forall i,j\in[n].
    \end{equation*}
    \item(ii) 2 đỉnh trên đồ thị $G$ liên thông với nhau, i.e., có đường đi trên trên $G$ nối chúng khi \& chỉ khi chúng cùng thuộc 1 thành phần liên thông, i.e.:
    \begin{equation*}
        i,j\mbox{ are connected}\Leftrightarrow C(i) = C(j)\Leftrightarrow C(i)\cap C(j)\ne\emptyset\Leftrightarrow{\rm cid}(i) = {\rm cid}(j),\ \forall i,j\in[n].
    \end{equation*}
\end{lemma}
Với truy vấn 1, giả sử 2 đỉnh $i,j\in[n]$ chưa có cạnh nối chúng trực tiếp, i.e., $\{i,j\}\notin E$. Có 2 trường hợp xảy ra:
\begin{itemize}
    \item Trường hợp 1: Giả sử $i,j$ cùng thuộc 1 thành phần liên thông, theo Lem. \ref{lem: characterization connectedness}, có $C(i) = C(j)$, ${\rm cid}(i) = {\rm cid}(j)$ nên ta chỉ cần thêm cạnh $\{i,j\}$ vào tập cạnh $E$: $E\leftarrow E\cup\{\{i,j\}\}$ hay \verb|edge_list.append({i, j})| mà không cần cập nhật $c$ tập liên thông $\{C_i\}_{i=1}^c$ hay hàm chỉ số liên thông ${\rm cid}(\cdot)$.
    \item Trường hợp 2: Giả sử $i,j$ thuộc 2 thành phần liên thông khác nhau, theo \ref{lem: characterization connectedness}, có $C(i)\ne C(j)$, ${\rm cid}(i)\ne {\rm cid}(j)$. Khi đó, việc nối cạnh $i,j$ với nhau, i.e., cập nhập tập cạnh bằng cách thêm cạnh $\{i,j\}$ vào tập cạnh $E$: $E\leftarrow E\cup\{\{i,j\}\}$ hay \verb|edge_list.append({i, j})|, nhưng điều khác biệt ở đây nằm ở chỗ: ta cũng cần phải cập nhật tập các thành phần liên thông \& hàm chỉ số liên thông như sau:
    \begin{enumerate}
        \item Cập nhật thành phần liên thông chứa cả $i$ \& $j$ bằng cách lấy hợp của 2 tập hợp $C(i),C(j)$, i.e., $C_{\rm new}(i) = C_{\rm new}(j)\coloneqq C(i)\cup C(j)$.
        \item Cập nhật hàm chỉ số liên thông: ${\rm cid}_{\rm new}(i) = {\rm cid}_{\rm new}(j) = \min\{{\rm cid}(i),{\rm cid}(j)\}$ (cũng có thể lấy $\max$ thay vì $\min$ nhưng theo quy ước của DSU data structure, ta nên lấy min để đảm bảo tính nhất quán\footnote{Consistency is 1 of the kings in natural sciences.}) \& sau đó ta có thể đánh chỉ số các thành phần liên thông lại nếu cần vì sau khi nối $i,j$ với nhau, số thành phần liên thông $c$ đã giảm đi 1, i.e., $c\leftarrow c - 1$ hay {\tt--c}.
    \end{enumerate}
\end{itemize}
Với truy vấn 2, với 2 đỉnh $i,j\in[n]$, $i\ne j$, ta có thể kiểm tra 2 đỉnh này có cùng nằm trong 1 thành phần liên thông hay không bằng cách so sánh $C(i)$ \& $C(j)$ hoặc ${\rm cid}(i)$ \& ${\rm cid}(j)$, nhờ Lem. \ref{lem: characterization connectedness}. Việc thực hiện truy vấn này khá hiển nhiên do bản chất của cấu trúc dữ liệu DSU chính là rã sự liên thông thành các thành phần liên khác nhau để tiện quản lý.

Về mặt cài đặt, để giải Bài toán \ref{prob: query connectedness}, ta sẽ xây dựng 1 cấu trúc dữ liệu có 3 thao tác sau:
\begin{enumerate}
    \item \verb|make_set(v)| tạo ra 1 tập hợp mới chỉ chứa phần tử $v$: \verb|make_set(v)| $= \{v\}$.
    \item \verb|union_sets(a,b)| gộp tập hợp chứa phần tử $a$ \& tập hợp chứa phần tử $b$ thành 1, i.e., bước cập nhật thành phần liên thông chung bằng cách lấy hợp của 2 thành phần liên thông tương ứng: $C_{\rm new}(i) = C_{\rm new}(j)\coloneqq C(i)\cup C(j)$ đã để cập.
    \item \verb|find_set(v)| cho biết {\it đại diện} (representative) của tập hợp có chứa phần tử $v$ (phần tử đại diện cho $v$ không nhất thiết phải là $v$, e.g., người đỡ đầu cho 1 tập hợp các đứa trẻ trong 1 trại trẻ mồ côi). Đại diện này là sẽ 1 phần tử của tập hợp đó \& có thể thay đổi sau mỗi lần gọi thao tác \verb|union_sets| (e.g., nếu chọn phần tử đại diện là đỉnh có giá trị nhỏ nhất thì nếu tìm được đỉnh mới nhỏ hơn phần tử đại diện hiện tại, thì phải cập nhật phần tử đại diện mới này). Ta có thể sử dụng đại diện đó để kiểm tra 2 phần tử có nằm trong cùng 1 tập hợp hay không. $a,b$ nằm trong cùng 1 tập hợp nếu như đại diện của 2 tập chứa chúng là giống nhau \& không nằm trong cùng 1 tập hợp nếu ngược lại.
\end{enumerate}
Ta có thể xử lý 3 thao tác này 1 cách hiệu quả với các tập hợp được biểu diễn dưới dạng các cây (tree-based representation), mỗi phần tử là 1 đỉnh \& mỗi cây tương ứng với 1 tập hợp. Gốc của mỗi cây sẽ là đại diện của tập hợp đó.





%------------------------------------------------------------------------------%

\section{Miscellaneous}

%------------------------------------------------------------------------------%

\printbibliography[heading=bibintoc]

\end{document}