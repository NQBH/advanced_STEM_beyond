\documentclass{article}
\usepackage[backend=biber,natbib=true,style=alphabetic,maxbibnames=50]{biblatex}
\addbibresource{/home/nqbh/reference/bib.bib}
\usepackage[utf8]{vietnam}
\usepackage{tocloft}
\renewcommand{\cftsecleader}{\cftdotfill{\cftdotsep}}
\usepackage[colorlinks=true,linkcolor=blue,urlcolor=red,citecolor=magenta]{hyperref}
\usepackage{amsmath,amssymb,amsthm,enumitem,fancyvrb,float,graphicx,mathtools,tikz}
\usetikzlibrary{angles,calc,intersections,matrix,patterns,quotes,shadings}
\allowdisplaybreaks
\newtheorem{assumption}{Assumption}
\newtheorem{baitoan}{Bài toán}
\newtheorem{cauhoi}{Câu hỏi}
\newtheorem{conjecture}{Conjecture}
\newtheorem{corollary}{Corollary}
\newtheorem{dangtoan}{Dạng toán}
\newtheorem{definition}{Definition}
\newtheorem{dinhly}{Định lý}
\newtheorem{dinhnghia}{Định nghĩa}
\newtheorem{example}{Example}
\newtheorem{ghichu}{Ghi chú}
\newtheorem{hequa}{Hệ quả}
\newtheorem{hypothesis}{Hypothesis}
\newtheorem{lemma}{Lemma}
\newtheorem{luuy}{Lưu ý}
\newtheorem{nhanxet}{Nhận xét}
\newtheorem{notation}{Notation}
\newtheorem{note}{Note}
\newtheorem{principle}{Principle}
\newtheorem{problem}{Problem}
\newtheorem{proposition}{Proposition}
\newtheorem{question}{Question}
\newtheorem{remark}{Remark}
\newtheorem{theorem}{Theorem}
\newtheorem{vidu}{Ví dụ}
\usepackage[left=1cm,right=1cm,top=5mm,bottom=5mm,footskip=4mm]{geometry}
\def\labelitemii{$\circ$}
\DeclareRobustCommand{\divby}{%
	\mathrel{\vbox{\baselineskip.65ex\lineskiplimit0pt\hbox{.}\hbox{.}\hbox{.}}}%
}
\setlist[itemize]{leftmargin=*}
\setlist[enumerate]{leftmargin=*}

\title{Lecture Note: Information Technology Fundamentals\\Bài Giảng: Nền Tảng Công Nghệ Thông Tin}
\author{Nguyễn Quản Bá Hồng\footnote{A scientist- {\it\&} creative artist wannabe, a mathematics {\it\&} computer science lecturer of Department of Artificial Intelligence {\it\&} Data Science (AIDS), School of Technology (SOT), UMT Trường Đại học Quản lý {\it\&} Công nghệ TP.HCM, Hồ Chí Minh City, Việt Nam.\\E-mail: {\sf nguyenquanbahong@gmail.com} {\it\&} {\sf hong.nguyenquanba@umt.edu.vn}. Website: \url{https://nqbh.github.io/}. GitHub: \url{https://github.com/NQBH}.}}
\date{\today}

\begin{document}
\maketitle
\begin{abstract}
	This text is a part of the series {\it Some Topics in Advanced STEM \& Beyond}:
	
	{\sc url}: \url{https://nqbh.github.io/advanced_STEM/}.
	
	Latest version:
	\begin{itemize}
		\item {\it Lecture Note: Information Technology Fundamentals -- Bài Giảng: Nền Tảng Công Nghệ Thông Tin}.
		
		PDF: {\sc url}: \url{https://github.com/NQBH/advanced_STEM_beyond/blob/main/IT_fundamentals/lecture/NQBH_IT_fundamentals_lecture.pdf}.
		
		\TeX: {\sc url}: \url{https://github.com/NQBH/advanced_STEM_beyond/blob/main/IT_fundamentals/lecture/NQBH_IT_fundamentals_lecture.tex}.
		\item {\it Codes}.
		
		PDF: {\sc url}: \url{.pdf}.
		
		\TeX: {\sc url}: \url{.tex}.
	\end{itemize}
\end{abstract}
\tableofcontents

%------------------------------------------------------------------------------%

\section{Basic Python Guides -- Hướng Dẫn Lập Trình Python Cơ Bản}
\textbf{\textsf{Resources -- Tài nguyên.}}
\begin{enumerate}
	\item \cite{Duc_200_BT_Python}. {\sc Nguyễn Tiến Đức}. {\it Tuyển Tập 200 Bài Tập Lập Trình Bằng Ngôn Ngữ Python}.
	\item \cite{Ha_Python_co_ban}. {\sc Bùi Việt Hà}. {\it Python Cơ Bản}.
	\item \cite{Ha_loi_giai_BT_Python_co_ban}. {\sc Bùi Việt Hà}. {\it Lời Giải Bài Tập Python Cơ Bản}.
	\item \cite{Ha_Python_nang_cao}. {\sc Bùi Việt Hà}. {\it Python Nâng Cao}.
	\item \cite{Matthes2019,Matthes2023}. {\sc Eric Matthes}. {\it Python Crash Course: A Hands-on, Project-Based Introduction to Programming}.
	\item \cite{Que_BT_Python}. {\sc Trần Thông Quế}. {\it Bài Tập Lập Trình Cơ Bản Với Ngôn Ngữ Python}.
\end{enumerate}

%------------------------------------------------------------------------------%

\subsection{Input \& output -- Nhập xuất dữ liệu}

\begin{itemize}
	\item Nhập kiểu dữ liệu dạng chuỗi (string), e.g., tên, từ, câu, etc.: {\tt a = input()}.
	\item Nhập kiểu dữ liệu số nguyên:  {\tt a = int(input())}.
	\item Nhập kiểu dữ liệu số nguyên:  {\tt a = float(input())}.
\end{itemize}

\begin{itemize}
	\item Truy cập trang web Google Colab: \url{https://colab.research.google.com}.
	\item {\it Cách tạo 1 file Jupyter notebook mới}: File $\to$ New notebook in Drive.
	\item Thêm ghi chú: Nhấp vào {\tt+ Text} $\to$ Gõ ghi chú, comment $\to$ Shift Enter.
	\item Thêm code: Nhấp vào {\tt+ Code} $\to$ Gõ code vào $\to$ Run.
\end{itemize}

\begin{itemize}
	\item {\tt int}: integer: kiểu dữ liệu số nguyên $\mathbb{Z} = \{0,\pm1,\pm2,\ldots\}$.
	\item {\tt float}: real number: integer: kiểu dữ liệu số thực $\mathbb{R}$.
\end{itemize}

\begin{baitoan}
	Viết chương trình Python để tính tổng, hiệu, tích, thương của 2 số $a,b\in\mathbb{R}$ được nhập từ bàn phím.
\end{baitoan}

\begin{proof}
	Python:
	\begin{verbatim}
a = float(input("a = "))
b = float(input("b = "))
print("Sum a + b = ", a + b)
print("Difference a - b = ", a - b)
print("Product ab = ", a * b)
if b == 0:
    print("Division by zero error")
else:
    print("Quotient a/b = ", a / b)
	\end{verbatim}
\end{proof}

\begin{remark}
	Nếu không xét trường hợp $b = 0$ thì sẽ bị lỗi chia cho $0$:
	\begin{verbatim}
Traceback (most recent call last):
  File "/home/nqbh/advanced_STEM_beyond/IT_fundamentals/Python/basic.py", line 6, in <module>
    print("Quotient a/b = ", a / b)
                             ~~^~~
ZeroDivisionError: float division by zero
	\end{verbatim}
\end{remark}

\begin{baitoan}[Even \& odd -- Chẵn \& lẻ. +0.5]
	Viết chương trình Python để xét tính chẵn lẻ của 1 số $a\in\mathbb{Z}$ được nhập từ bàn phím.
\end{baitoan}

\begin{baitoan}[Divisible by -- Tính chia hết, +0.5]
	Viết chương trình Python để xét xem $a\in\mathbb{Z}$ có chia hết cho $b\in\mathbb{Z}$ không, với $a,b$ được nhập từ bàn phím. Nếu có thông báo {\tt a is divisible by b}, nếu không thì in số dư $r$ của phép chia $a$ cho $b$, với $0\le r < |b|$.
\end{baitoan}


\subsection{Loop commands -- Các lệnh lặp}

\begin{baitoan}
	Cho $n\in\mathbb{N}^\star$ được nhập từ bàn phím. Viết chương trình Python để tính: (a) Tổng của $n$ số nguyên dương đầu tiên: $\sum_{i=1}^n i = 1 + 2 + \cdots + n$ \& so sánh với $\dfrac{n(n + 1)}{2}$. (b) Tổng của $n$ số nguyên dương lẻ đầu tiên: $\sum_{i=1}^n (2i - 1) = 1 + 3 + 5 + \cdots + (2n - 1)$  \& so sánh với $n^2$. (c) Tổng của $n$ số lẻ nguyên dương chẵn đầu tiên: $\sum_{i=1}^n 2i = 2 + 4 + 6 + \cdots + 2n$ \& so sánh với $n(n + 1)$. (d) Tổng bình phương của $n$ số nguyên dương đầu tiên: $\sum_{i=1}^n i^2 = 1^2 + 2^2 + \cdots + n^2$ \& so sánh với $\dfrac{n(n + 1)(2n + 1)}{6}$. (e) Tổng bình phương của $n$ số nguyên dương lẻ đầu tiên: $\sum_{i=1}^n (2i - 1)^2 = 1^2 + 3^2 + 5^2 + \cdots + (2n - 1)^2$. (f) Tổng bình phương của $n$ số lẻ nguyên dương chẵn đầu tiên: $\sum_{i=1}^n (2i)^2 = 2^2 + 4^2 + 6^2 + \cdots + (2n)^2$ \& so sánh với $\dfrac{2n(n + 1)(2n + 1)}{3}$. (g) Tổng lập phương của $n$ số nguyên dương đầu tiên: $\sum_{i=1}^n i^3 = 1^3 + 2^3 + \cdots + n^3$ \& so sánh với $\dfrac{n^2(n + 1)^2}{4}$. (e) Tổng lập phương của $n$ số nguyên dương lẻ đầu tiên: $\sum_{i=1}^n (2i - 1)^3 = 1^3 + 3^3 + 5^3 + \cdots + (2n - 1)^3$. (f) Tổng lập phương của $n$ số nguyên dương chẵn đầu tiên: $\sum_{i=1}^n (2i)^3 = 2^3 + 4^3 + 6^3 + \cdots + (2n)^3$ \& so sánh với $2n^2(n + 1)^2$.
\end{baitoan}

\begin{baitoan}[Triangle -- Tam giác]
	 Viết chương trình Python để xét 3 số $a,b,c\in(0,\infty)$ được nhập từ bàn phím có phải là: (a) 3 cạnh của 1 tam giác hay không nhờ bất đẳng thức 3 cạnh tam giác $a < b + c,b < c + a,c < a + b$. (b) Nếu $a,b,c$ là 3 cạnh tam giác, phân loại tam giác đó: tam giác nhọn, tam giác vuông, tam giác tù, tam giác cân, tam giác đều, tam giác vuông cân.
\end{baitoan}

\begin{baitoan}
	Viết chương trình tính chu vi, diện tích, 3 đường cao của 1 tam giác với độ dài 3 cạnh $a,b,c\in(0,\infty)$ được nhập từ bàn phím.
\end{baitoan}

\begin{baitoan}
	Cho 1 mảng số thực $a_1,\ldots,a_n$ được nhập từ bàn phím ứng với số tiền thu được mỗi tháng, trong đó $a_i < 0$: lỗ, $a_i = 0$: huề vốn, $a_i > 0$: lời{\tt/}lãi. Viết chương trình Python xuất ra màn hình: (a) Số tháng lời, lỗ, huề vốn. (b) Tổng số tiền lời, tổng số tiền lỗ, tổng số thu nhập cuối cùng (sau khi lấy tổng số tiền lời $-$ tổng số tiền lỗ).
	\item {\sf Input.} Dãy số thực $a_1,\ldots,a_n$.
	\item {\sf Output.} Số tháng lời, số tháng lỗ, số tháng huề vốn. Dòng tiếp theo: Tổng số tiền lời, tổng số tiền lỗ.
	\item {\sf Sample.}
	\begin{table}[H]
		\centering
		\begin{tabular}{|l|l|}
			\hline
			{\tt money.inp} & {\tt money.out} \\
			\hline
			10.5 -2.3 3.6 4.5 -7.41 0 1.23 & 4 2 1 \\
			& 19.83 $-9.71$ \\
			& 10.12 \\
			\hline
		\end{tabular}
	\end{table}
\end{baitoan}

\begin{baitoan}[\cite{CDHT_Toan_10_CD}, VD3, p. 25, tính tiền vốn lẫn lãi nếu không rút tiền ra]
	1 người gửi số tiền $m_0\in(0,\infty)$ đồng vào ngân hàng với lãi suất $r\%${\tt/}năm. Biết nếu không rút tiền ra khỏi ngân hàng thì cứ sau mỗi năm, số tiền lãi sẽ được nhạp vào vốn ban đầu. Biết số tiền nhận được (bao gồm cả vốn lẫn lãi) sau $n$ năm là
	\begin{equation*}
		M(m_0,r,n) = m_0\left(1 + \frac{r}{100}\right)^n\mbox{ đồng},
	\end{equation*}
	nếu trong khoảng thời gian này người gửi không rút tiền ra \& lãi suất không thay đổi. Viết chương trình Python để: (a) Tính $M(m_0,r,n)$ với $m_0,r,n$ lần lượt được nhập vào. (b) Xuất ra số tiền nhận được (bao gồm cả vốn lẫn lãi) sau năm 1, năm 2, $\ldots$, năm $n$, i.e., xuất ra dãy số thực $\{M(m_0,r,i)\}_{i=1}^n = M(m_0,r,1),M(m_0,r,2),\ldots,M(m_0,r,n)$. (c) Với số tiền $m$ được nhập từ bàn phím, cho biết sau bao nhiêu năm thì số tiền cả vốn lẫn lãi vượt qua số tiền $m$ kỳ vọng này.
	\item {\sf Input.} Dòng 1 chứa lần lượt $m_0,r\in(0,\infty)$, $n\in\mathbb{N}^\star$.
	\item {\sf Output.} Dòng 1 chứa $T(m_0,r,n)$. Dòng 2 chứa dãy số $\{M(m_0,r,i)\}_{i=1}^n = M(m_0,r,1),M(m_0,r,2),\ldots,M(m_0,r,n)$.
	\item {\sf Sample.}
	\begin{table}[H]
		\centering
		\begin{tabular}{|l|l|}
			\hline
			{\tt rate.inp} & {\tt rate.out} \\
			\hline
			125000000 4.9 3 & 144290081.125 \\
			\hline
		\end{tabular}
	\end{table}
\end{baitoan}

\begin{baitoan}[\cite{CDHT_Toan_10_CD}, 10., p. 30, tính tiền vốn lẫn lãi nếu không rút tiền ra]
	Giả sử năm đầu tiên, A gửi vào ngân hàng $m_0\in(0,\infty)$ đồng với lãi suất $r\%$ năm. Hết năm đầu tiên, A không rút tiền ra \& gửi thêm $m_0$ đồng nữa. Hết năm thứ 2, A cũng không rút tiền ra \& lại gửi thêm $m_0$ đồng nữa. Cứ tiếp tục như vậy cho các năm sau. Biết số tiền cả vốn lẫn lãi mà A có được sau $n\in\mathbb{N}^\star$ năm là
	\begin{equation*}
		M(m_0,r,n) = \frac{m_0(100 + r)}{r}\left[\left(1 + \frac{r}{100}\right)^n - 1\right]\mbox{ đồng},
	\end{equation*}
	nếu trong khoảng thời gian này lãi suất không thay đổi. Viết chương trình Python để: (a) Tính $M(m_0,r,n)$với $m_0,r,n$ lần lượt được nhập vào. (b) Xuất ra số tiền nhận được (bao gồm cả vốn lẫn lãi) sau năm 1, năm 2, $\ldots$, năm $n$, i.e., xuất ra dãy số thực $\{M(m_0,r,i)\}_{i=1}^n = M(m_0,r,1),M(m_0,r,2),\ldots,M(m_0,r,n)$. (c) Với số tiền $m$ được nhập từ bàn phím, cho biết sau bao nhiêu năm thì số tiền cả vốn lẫn lãi vượt qua số tiền $m$ kỳ vọng này.
	\item {\sf Input.} Dòng 1 chứa lần lượt $m_0,r\in(0,\infty)$, $n\in\mathbb{N}^\star$.
	\item {\sf Output.} Dòng 1 chứa $T(m_0,r,n)$. Dòng 2 chứa dãy số $\{M(m_0,r,i)\}_{i=1}^n = M(m_0,r,1),M(m_0,r,2),\ldots,M(m_0,r,n)$.
	\item {\sf Sample.}
	\begin{table}[H]
		\centering
		\begin{tabular}{|l|l|}
			\hline
			{\tt rate.inp} & {\tt rate.out} \\
			\hline
			125000000 4.9 5 & 723102450.785  \\
			\hline
		\end{tabular}
	\end{table}
\end{baitoan}

\begin{baitoan}[\cite{CDHT_Toan_10_CD}, 11., p. 30, tính tiền vốn lẫn lãi nếu không rút tiền ra]
	1 người gửi số tiền $m_0\in(0,\infty)$ đồng vào ngân hàng. Biểu lãi suất của ngân hàng như sau: Chia mỗi năm thanh $m\in\mathbb{N}^\star$ kỳ hạn \& lãi suất $r\%${\tt/}năm. Biết nếu không rút tiền ra khỏi ngân hàng thì cứ sau mỗi kỳ hạn, số tiền lãi sẽ được nhập vào vốn ban đầu. Biết số tiền nhận được (bao gồm cả vốn lẫn lãi) sau $n$ năm gửi là
	\begin{equation*}
		M(m_0,r,m,n) = m_0\left(1 + \frac{r}{100m}\right)^{mn},
	\end{equation*}
	nếu trong khoảng thời gian này người gửi không rút tiền ra \& lãi suất không thay đổi. Viết chương trình Python để: (a) Tính $M(m_0,r,m,n)$với $m_0,r,m,n$ lần lượt được nhập vào. (b) Xuất ra số tiền nhận được (bao gồm cả vốn lẫn lãi) sau năm 1, năm 2, $\ldots$, năm $n$, i.e., xuất ra dãy số thực $\{M(m_0,r,m,i)\}_{i=1}^n = M(m_0,r,m,1),M(m_0,r,m,2),\ldots,M(m_0,r,m,n)$. (c) Với số tiền $M$ được nhập từ bàn phím, cho biết sau bao nhiêu năm thì số tiền cả vốn lẫn lãi vượt qua số tiền $M$ kỳ vọng này.
	\item {\sf Input.} Dòng 1 chứa lần lượt $m_0,r\in(0,\infty)$, $m,n\in\mathbb{N}^\star$.
	\item {\sf Output.} Dòng 1 chứa $T(m_0,r,m,n)$. Dòng 2 chứa dãy số $\{M(m_0,r,m,i)\}_{i=1}^n = M(m_0,r,m,1),M(m_0,r,m,2),\ldots,M(m_0,r,m,n)$.
\end{baitoan}

\begin{baitoan}[Even vs. odd -- chẵn lẻ]
	Tính số số chẵn \& số số lẻ của 1 dãy gồm $n$ số nguyên cho trước.
	\item {\sf Input.} Dòng 1 chứa $n\in\mathbb{N}^\star$. Dòng 2 chứa $n$ số nguyên $a_1,a_2,\ldots,a_n$.
	\item {\sf Output.} In ra số số chẵn $a_i\divby2$ \& số số lẻ $a_i\not{\divby}\ 2$.
	\item {\sf Sample.}
	\begin{table}[H]
		\centering
		\begin{tabular}{|l|l|}
			\hline
			\verb|even_odd.inp| & \verb|even_odd.out| \\
			\hline
			10 &  number of evens: 4 \\
			1 -2 3 5 0 7 -100 -42 7 6345 & number of odds: 6 \\
			\hline
		\end{tabular}
	\end{table}	
\end{baitoan}
Python code:
\begin{verbatim}

\end{verbatim}

\begin{baitoan}[Population prediction -- Dự báo dân số]
	Giả sử tỷ lệ tăng dân số bình quân hàng năm của Việt Nam là $r\in(0,\infty)$ \& dân số hiện nay là $P_0$. Tính dân số sau $n\in\mathbb{N}^\star$ năm. Tính số năm ít nhất để dẫn số đạt $P\in(0,\infty)$ cho trước.
	\item {\sf Input.} Dòng 1 chứa dân số ban đầu $P_0\in(0,\infty)$, tỷ lệ tăng dân số bình quân $r\in(0,\infty)$, số năm $n\in\mathbb{N}^\star$. Dòng 2 chứa số dân $P$ cần đạt.
	\item {\sf Output.} Dòng 1 chứa số dân $P_n$ sau $n$ năm. Dòng 2 chứa số dân tăng từng năm tới năm $n$, i.e., in ra dãy số thực $P_0,P_1,\ldots,P_n$. Dòng 3 chứa số năm ít nhất để dân số đạt ngưỡng $P$.
	\item {\sf Sample.}
	\begin{table}[H]
		\centering
		\begin{tabular}{|l|l|}
			\hline
			{\tt population.inp} & {\tt population.out} \\
			\hline
			96525000 0.003 5 & 97981588.35 \\
			100000000 & 96525000.00 96814575.00 97105018.72 97396333.78 97688522.78 97981588.35 \\
			& 12 \\
			\hline
		\end{tabular}
	\end{table}	
\end{baitoan}

\begin{baitoan}[\cite{Doanh_Tuan_Pascal}, VD2, p. 15]
	(a) Tìm {\rm GTLN} $\max\{a,b,c\}$ \& {\rm GTNN} $\min\{a,b,c\}$ với $a,b,c\in\mathbb{R}$. (b) Mở rộng bài toán cho $n\in\mathbb{N}^\star$ số $a_1,a_2,\ldots,a_n$.
\end{baitoan}

\begin{baitoan}[\cite{Doanh_Tuan_Pascal}, VD3, p. 16]
	(a) Tính giá trị của hàm số $f:\mathbb{R}^2\to\mathbb{R}$ xác định bởi công thức:
	\begin{equation*}
		f(x,y) = \left\{\begin{split}
			&x^3 + y^3&&\mbox{if }0\le x - y\le10,\\
			&x^2 + y^2&&\mbox{if } x - y < 0,\ y\ge0,\\
			&(x - y)^2&&\mbox{else}.
		\end{split}\right.
	\end{equation*}
	(b) Mở rộng bài toán cho các hàm số tương tự.
\end{baitoan}

\begin{baitoan}[\cite{VietSTEM2021}, 6., p. 27, Tây Ninh 2019, Số hoàn hảo -- Perfect number]
	\emph{Số hoàn hảo} là 1 số tự nhiên mà tổng tất cả các ước tự nhiên thực sự của nó bằng chính nó. Trong đó ước thực sự của 1 số là các ước dương không bằng số đó. Lập trình nhập vào 1 số tự nhiên có $2$ chữ số bất kỳ. In ra màn hình thông báo số vừa nhập có phải là số hoàn hảo hay không? Nếu là số hoàn hảo thì in tất cả các ước nguyên dương của số đó (i.e., bao gồm tất cả các ước tự nhiên thực sự \& chính số đó).
\end{baitoan}

\begin{baitoan}[\cite{Trung_HSG_THPT_Tin}, 1., p. 20, HSG Lớp 12 Nam Định 2020--2021, Nearly perfect number -- Số gần hoàn hảo]
	1 số nguyên dương $a\in\mathbb{N}^\star$ được gọi là {\rm số ``gần hoàn hảo''} nếu thỏa mãn điều kiện: $2a\le k$ với $k$ là tổng các ước số của $a$, e.g., $12$ là 1 số ``gần hoàn hảo'' vì $2\cdot12 < 1 + 2 + 3 + 4 + 6 + 12$ ($24 < 28$).
	\begin{itemize}
		\item {\sf Input.} Dòng đầu tiên chứa số nguyên dương $n\in\mathbb{N}^\star$, $1\le n\le10^4$. $n$ dòng tiếp theo, mỗi dòng là 1 số nguyên dương có giá trị $\le10^6$.
		\item {\sf Output.} Dòng đầu tiên ghi số lượng số ``gần hoàn hảo''. Các dòng tiếp theo, mỗi dòng ghi 1 số ``gần hoàn hảo'', số gặp trước thì viết trước.
		\item {\sf Sample.}
		\begin{table}[H]
			\centering
			\begin{tabular}{|l|l|}
				\hline
				\verb|near_perfect_number.inp| & \verb|near_perfect_number.out| \\
				\hline
				5 & 2 \\
				8 & 12 \\
				16 & 6 \\
				12 & \\
				6 & \\
				7 & \\
				\hline
			\end{tabular}
		\end{table}
	\end{itemize}
\end{baitoan}

%------------------------------------------------------------------------------%

\section{Recursion -- Đệ Quy}

\begin{baitoan}
    Viết hàm đệ quy tính $n!$ với $n\in\mathbb{N}$ được nhập vào từ bàn phím.
\end{baitoan}

\begin{baitoan}
    Với $n\in\mathbb{N}$ được nhập vào, viết hàm đệ quy để: (a) In ra dãy số Fibonacci $\{F_i\}_{i=0}^n$. (b) In ra số Fibonacci $F_n$.
\end{baitoan}

\begin{baitoan}[Ha Noi tower problem -- Bài toán tháp Hà Nội]
    Thực hiện chuyển $n$ đĩa từ cọc 1 sang cọc 2, được dùng cọc trung gian. Luật chơi: (i) Mỗi lần chỉ chuyển 1 đĩa. (ii) Đĩa nhỏ nằm trên đĩa lớn. (iii) Trong lúc chuyển hông được để đĩa lên bất kỳ chỗ nào.
\end{baitoan}

\begin{baitoan}[\cite{Que_BT_Python}, 2., p. 89]
    Nhập $n\in\mathbb{N},n\ge2$ số vào từ bàn phím. Viết chương trình Python sử dụng đệ quy để tìm {\rm ƯCLN, BCNN} của $n$ số đó.
\end{baitoan}

\begin{baitoan}[\cite{Que_BT_Python}, 3., p. 89]
    Cho dãy $\{a_n\}_{n=0}^\infty$ được định nghĩa bởi công thức truy hồi:
    \begin{equation*}
        a_0 = 1,\ a_n = n^2a_0 + (n - 1)^2a_1 + (n - 2)^2a_2 + \cdots + 1^2a_{n-1},\ \forall n\in\mathbb{N}^\star.
    \end{equation*}
    Viết chương trình Python sử dụng đệ quy để tính $a_n$ với $n\in\mathbb{N}$ được nhập vào từ bàn phím. 
\end{baitoan}

\begin{baitoan}[Mở rộng \cite{Que_BT_Python}, 3., p. 89]
    Cho dãy $\{a_n\}_{n=0}^\infty$ được định nghĩa bởi công thức truy hồi:
    \begin{equation*}
        a_0 = 1,\ a_n = f(n)a_0 + f(n - 1)a_1 + f(n - 2)a_2 + \cdots + f(1)a_{n-1},\ \forall n\in\mathbb{N}^\star,
    \end{equation*}
    với $f:\mathbb{N}^\star\to\mathbb{R}$ là 1 hàm số được định nghĩa trước, e.g., lấy $f(n) = \dfrac{n^2\sin n}{\sqrt{n(n + 1)|\cos n|}}$, $\forall n\in\mathbb{N}^\star$. Viết chương trình Python sử dụng đệ quy để tính $a_n$ với $n\in\mathbb{N}$ được nhập vào từ bàn phím. 
\end{baitoan}

\begin{baitoan}[\cite{Que_BT_Python}, 4., p. 89]
    Tính giai thừa kép $n!!$ rồi tính tổng $S = 1!! - 2!! + 3!! - 4!! + \cdots + (-1)^{n+1}n!!$ với $n\in\mathbb{N}^\star$ được nhập vào từ bàn phím.
\end{baitoan}

\begin{baitoan}[\cite{Que_BT_Python}, 5., p. 90, Pascal triangle -- tam giác Pascal]
    In lên màn hình tam giác Pascal chứa các hệ số của khai triển nhị thức $(x + 1)^n$. Yêu cầu: Xuất lên màn hình tam giác Pascal ``vuông cân'' \& tam giác Pascal ``đều''.
\end{baitoan}

\begin{baitoan}[\cite{Que_BT_Python}, 6., p. 90]
    Viết chương trình Python sử dụng đệ quy để tính tổng: (a) $S = \dfrac{1}{2} + \dfrac{1}{4} + \cdots + \dfrac{1}{2n}$.\\(b) $S = 1 + 2^2 + 3^3 + 4^4 + \cdots + n^n$. (c) $S = \sqrt{3n + \sqrt{3(n - 1) + \cdots + \sqrt{9 + \sqrt{6 + \sqrt{3}}}}}$. (d) $S = \sqrt[n]{n} + \sqrt[n - 1]{n - 1} + \cdots + \sqrt{2}$.\\(e) $S = \sqrt[n + 1]{n + \sqrt[n]{n - 1 + \cdots + \sqrt[3]{2 + \sqrt{1}}}}$. (f) $S = \sqrt{n + \sqrt{n - 1 + \sqrt{n - 2 + \cdots + \sqrt{2 + \sqrt{1}}}}}$.\\(g) $S = \sqrt[n+1]{n! + \sqrt[n]{(n - 1)! + \cdots + \sqrt[3]{2! + \sqrt{1!}}}}$. (h) $S(n) = x + \dfrac{x^2}{2!} + \dfrac{x^3}{3!} + \cdots + \dfrac{x^n}{n!}$ với $x\in\mathbb{R}$, rồi tính $e^x - S(n)$.
\end{baitoan}

\begin{baitoan}[\cite{Que_BT_Python}, 7., p. 91]
    Cho trước 1 tập gồm $n\in\mathbb{N}^\star$ số nguyên. Liệt kê mọi cách phân hoạch tập này thành các tập con, e.g., tập $\{1,2,4\}$ có thể phân hoạch thành $\{1,2,4\} = \{1\}\cup\{2,4\} = \{2\}\cup\{1,4\}= \{4\}\cup\{1,2\}$.
\end{baitoan}

\begin{baitoan}[\cite{Que_BT_Python}, 8., p. 91]
    Tính giá trị Ackerman $A(m,n)$ được định nghĩa bởi:
    \begin{equation*}
        A(m,n) = \left\{\begin{split}
            &n + 1&&\mbox{if } m = 0,\\
            &A(m - 1,1)&&\mbox{if } n = 0,\ m > 0,\\
            &A(m - 1,A(m,n - 1))&&\mbox{if } m > 0,\ n > 0.
        \end{split}\right.
    \end{equation*}
    Với $m,n$ nhập vào từ bàn phím, in ra ma trận $\{A(i,j)\}_{i,j=0}^{m,n}$.
\end{baitoan}

\begin{baitoan}[\cite{Que_BT_Python}, 9., p. 91]
    Viết chương trình Python sử dụng đệ quy để in ra tất cả dãy nhị phân dài $n$ với $n\in\mathbb{N}^\star$ được nhập vào từ bàn phím.
\end{baitoan}

\begin{baitoan}[\cite{Que_BT_Python}, 10., p. 91]
    Không được dùng {\tt list, tuple, string}, chỉ dùng biến đơn, viết Python sử dụng đệ quy để đảo ngược 1 số, e.g., $123\mapsto321$.
\end{baitoan}

%------------------------------------------------------------------------------%

\section{Visualization with {\tt matplotlib}}
\textbf{\textsf{Resources -- Tài nguyên.}}
\begin{enumerate}
    \item \href{https://matplotlib.org/stable/users/explain/quick_start.html#quick-start}{matplotlib{\tt/}quick start guide}.
\end{enumerate}
Import thư viện {\tt matplotlib}:
\begin{verbatim}
import matplotlib.pyplot as plt
import numpy as np
\end{verbatim}
{\tt matplotlib} graphs your data on {\tt Figure}s (e.g., windows, Jupyter widgets, etc.), each of which can contain 1 or more {\tt Axes}, an area where points can be specified in terms of $x$-$y$ coordinates (or $\theta$-$r$ in a polar plot, $x$-$y$-$z$ in a 3D plot, etc.). The simplest way of creating a Figure with an Axes is using {\tt pyplot.subplots}. We can then sue {\tt Axes.plot} to draw some data on the Axes, \& {\tt show} to display the figure:

-- {\tt matplotlib} biểu đồ hóa dữ liệu của bạn trên {\tt Figure} (ví dụ: cửa sổ, tiện ích Jupyter, v.v.), mỗi cửa sổ có thể chứa 1 hoặc nhiều {\tt Axes}, một khu vực nơi các điểm có thể được chỉ định theo tọa độ $x$-$y$ (hoặc $\theta$-$r$ trong biểu đồ cực, $x$-$y$-$z$ trong biểu đồ 3D, v.v.). Cách đơn giản nhất để tạo Figure với Axes là sử dụng {\tt pyplot.subplots}. Sau đó, chúng ta có thể sử dụng {\tt Axes.plot} để vẽ một số dữ liệu trên Axes, \& {\tt show} để hiển thị hình:
\begin{Verbatim}[numbers=left,xleftmargin=5mm]
fig, ax = plt.subplots()             # Create a figure containing a single Axes.
ax.plot([1, 2, 3, 4], [1, 4, 2, 3])  # Plot some data on the Axes.
plt.show()                           # Show the figure.
\end{Verbatim}
Depending on the environment you are working in, {\tt plt.show()} can be left out, which is e.g. the case with Jupyter notebooks, which automatically show all figures created in a code cell.

-- Tùy thuộc vào môi trường bạn đang làm việc, {\tt plt.show()} có thể bị bỏ qua, ví dụ như trường hợp của sổ ghi chép Jupyter, tự động hiển thị tất cả các hình được tạo trong ô mã.

%------------------------------------------------------------------------------%

\subsection{Parts of a figure -- Các phần của 1 hình}

\begin{figure}[H]
    \centering
    \includegraphics[width=4cm]{matplotlib_component}
    \caption{Compenents of a {\tt matplotlib} figure.}
\end{figure}

\begin{enumerate}
    \item {\tt Figure}: The whole figure. The Figure keeps track of all the child {\tt Axes}, a group of `special' Artists (titles, figure legends, colorbars, etc.), \& even nested subfigures.
    
    -- Toàn bộ hình. Hình theo dõi tất cả các {\tt Axes} con, một nhóm Nghệ sĩ `đặc biệt' (tiêu đề, chú thích hình, thanh màu, v.v.), \& thậm chí cả các hình phụ lồng nhau.
    
    Typically, create a new Figure through 1 of the following functions:
    \begin{Verbatim}[numbers=left,xleftmargin=5mm]
fig = plt.figure()             # an empty figure with no Axes
fig, ax = plt.subplots()       # a figure with a single Axes
fig, axs = plt.subplots(2, 2)  # a figure with a 2x2 grid of Axes
# a figure with one Axes on the left, and two on the right:
fig, axs = plt.subplot_mosaic([['left', 'right_top'],
['left', 'right_bottom']])   
    \end{Verbatim}
    \verb|subplots(), subplot_mosaic| are convenience functions that additionally create Axes objects inside the Figure, but you can also manually add Axes later on.
    
    -- \verb|subplots(), subplot_mosaic| là các hàm tiện ích có chức năng tạo thêm các đối tượng Axes bên trong Hình, nhưng bạn cũng có thể thêm Axes theo cách thủ công sau đó.
    \item {\sf Axes}: An Axes is an Artist attached to a Figure that contains a region for plotting data, \& usually includes 2 (or 3 in the case of 3D) {\tt Axis} objects (be aware of the difference between {\tt Axes, Axis}) that provide ticks \& tick labels to provide scales for the data in the Axes. Each {\tt Axes} also has a title (set via \verb|set_title()|), an $x$-label (set via \verb|set_xlabel()|), \& a $y$-label (set via \verb|set_ylabel()|).
    
    -- Axes là 1 Artist gắn liền với một Figure chứa một vùng để vẽ dữ liệu, \& thường bao gồm 2 (hoặc 3 trong trường hợp 3D) {\tt Axis} đối tượng (lưu ý sự khác biệt giữa {\tt Axes, Axis}) cung cấp các dấu \& nhãn dấu để cung cấp thang đo cho dữ liệu trong Axes. Mỗi {\tt Axes} cũng có một tiêu đề (được thiết lập thông qua \verb|set_title()|), một nhãn $x$ (được thiết lập thông qua \verb|set_xlabel()|), \& một nhãn $y$ (được thiết lập thông qua \verb|set_ylabel()|).
    
    The {\tt Axes} methods are the primary interface or configuring most parts of your plot (adding data, controlling axis scales \& limits, adding labels, etc.).
    
    -- Các phương thức {\tt Axes} là giao diện chính hoặc cấu hình hầu hết các phần của biểu đồ (thêm dữ liệu, kiểm soát tỷ lệ trục \& giới hạn, thêm nhãn, v.v.).
    \item {\tt Axis}: These objects set the scale \& limits \& generate ticks (the marks on the Axis) \& ticklabels (strings labeling the ticks). The location of the ticks is determined by a {\tt Locator} object \& the ticklabel strings are formatted by a {\tt Formatter}. The combination of the correct {\tt Locator} \& {\tt Formatter} gives very fine control over the tick locations \& labels.
    
    -- Các đối tượng này thiết lập tỷ lệ \& giới hạn \& tạo ra các vạch chia (các vạch trên Trục) \& nhãn chia (các chuỗi nhãn chia). Vị trí của các vạch chia được xác định bởi một đối tượng {\tt Locator} \& các chuỗi nhãn chia được định dạng bởi một {\tt Formatter}. Sự kết hợp của {\tt Locator} \& {\tt Formatter} chính xác mang lại khả năng kiểm soát rất tốt đối với các vị trí của vạch chia \& nhãn.
    \item {\tt Artist}: Basically, everything visible on the Figure is an Artist (even {\tt Figure, Axes}, \& {\tt Axis} objects). This includes {\tt Text} objects, {\tt Line2D} objects, {\tt collections} objects, {\tt Patch} objects, etc. When the Figure is rendered, all of the {\tt Artists} are drawn to the {\tt canvas}. Most Artists are tied to an Axes; such an Artist cannot be shared by multiple Axes, or moved from 1 to another.
    
    -- Về cơ bản, mọi thứ hiển thị trên Figure đều là một Artist (kể cả các đối tượng {\tt Figure, Axes}, \& {\tt Axis}). Điều này bao gồm các đối tượng {\tt Text}, {\tt Line2D}, {\tt collections}, {\tt Patch}, v.v. Khi Figure được hiển thị, tất cả {\tt Artists} đều được vẽ vào {\tt canvas}. Hầu hết các Artists đều được gắn với một Axes; một Artist như vậy không thể được chia sẻ bởi nhiều Axes hoặc di chuyển từ 1 đến 1 Axes khác.
\end{enumerate}

%------------------------------------------------------------------------------%

\subsection{Types of inputs to plotting functions -- Các loại đầu vào để vẽ hàm}
Plotting functions except {\tt numpy.array} or \verb|numpy.ma.masked_array| as input, or objects that can be passed to {\tt numpy.asarray}. Classes that are similar to arrays (`array-like') e.g. {\tt pandas} data objects \& {\tt numpy.matrix} may not work as intended. Common convention is to convert these to {\tt numpy.array} objects prior to plotting, e.g., to convert a {\tt numpy.matrix}:

-- Các hàm vẽ đồ thị ngoại trừ {\tt numpy.array} hoặc \verb|numpy.ma.masked_array| làm đầu vào hoặc các đối tượng có thể được truyền vào {\tt numpy.asarray}. Các lớp tương tự như mảng (`giống mảng') ví dụ: {\tt pandas} đối tượng dữ liệu \& {\tt numpy.matrix} có thể không hoạt động như mong đợi. Quy ước chung là chuyển đổi các đối tượng này thành {\tt numpy.array} trước khi vẽ đồ thị, ví dụ: chuyển đổi {\tt numpy.matrix}:
\begin{verbatim}
b = np.matrix([[1, 2], [3, 4]])
b_asarray = np.asarray(b)
\end{verbatim}
Most methods will also parse a string-indexable object like a {\it dict}, a structure numpy array, or a {\tt pandas.DataFrame}. {\tt matplotlib} allows you to provide the {\tt data} keyword argument \& generate plots passing the strings corresponding to the $x,y$ variables.

-- Hầu hết các phương pháp cũng sẽ phân tích cú pháp một đối tượng có thể lập chỉ mục theo chuỗi như {\it dict}, một mảng cấu trúc numpy hoặc {\tt pandas.DataFrame}. {\tt matplotlib} cho phép bạn cung cấp đối số từ khóa {\tt data} \& tạo biểu đồ truyền các chuỗi tương ứng với các biến $x,y$.
\begin{Verbatim}[numbers=left,xleftmargin=5mm]
np.random.seed(19680801)  # seed the random number generator.
data = {'a': np.arange(50),
    'c': np.random.randint(0, 50, 50),
    'd': np.random.randn(50)}
data['b'] = data['a'] + 10 * np.random.randn(50)
data['d'] = np.abs(data['d']) * 100

fig, ax = plt.subplots(figsize=(5, 2.7), layout='constrained')
ax.scatter('a', 'b', c='c', s='d', data=data)
ax.set_xlabel('entry a')
ax.set_ylabel('entry b')
\end{Verbatim}

%------------------------------------------------------------------------------%

\subsection{Coding styles -- Các phong cách lập trình}


\subsubsection{Explicit \& implicit interfaces -- Giao diện rõ ràng \& ngầm định}
There are essentially 2 ways to use {\tt matplotlib}:
\begin{enumerate}
    \item Explicitly create Figures \& Axes, \& call methods on them (the ``object-oriented (OO) style'').
    \item Rely on {\tt pyplot} to implicitly create \& manage the Figures \& Axes, \& use {\tt pyplot} functions for plotting.
\end{enumerate}
See \href{https://matplotlib.org/stable/users/explain/figure/api_interfaces.html#api-interfaces}{Matplotlib Application Interfaces (APIs)} for an explanation of the tradeoffs between the implicit \& explicit interfaces. So one can use the OO-style:

-- Về cơ bản có 2 cách để sử dụng {\tt matplotlib}:
\begin{enumerate}
    \item Tạo Figures \& Axes một cách rõ ràng, \& gọi các phương thức trên chúng (``phong cách hướng đối tượng (OO)'').
    \item Dựa vào {\tt pyplot} để tạo \& quản lý Figures \& Axes một cách ngầm định, \& sử dụng các hàm {\tt pyplot} để vẽ đồ thị.
\end{enumerate}
Xem \href{https://matplotlib.org/stable/users/explain/figure/api_interfaces.html#api-interfaces}{Giao diện ứng dụng Matplotlib (API)} để biết giải thích về sự đánh đổi giữa giao diện ngầm định \& rõ ràng. Vì vậy, người ta có thể sử dụng phong cách OO:
\begin{Verbatim}[numbers=left,xleftmargin=5mm]
x = np.linspace(0, 2, 100)  # Sample data.

# Note that even in the OO-style, we use `.pyplot.figure` to create the Figure.
fig, ax = plt.subplots(figsize=(5, 2.7), layout='constrained')
ax.plot(x, x, label='linear')  # Plot some data on the Axes.
ax.plot(x, x**2, label='quadratic')  # Plot more data on the Axes...
ax.plot(x, x**3, label='cubic')  # ... and some more.
ax.set_xlabel('x label')  # Add an x-label to the Axes.
ax.set_ylabel('y label')  # Add a y-label to the Axes.
ax.set_title("Simple Plot")  # Add a title to the Axes.
ax.legend()  # Add a legend.
\end{Verbatim}
or the pyplot-style:
\begin{Verbatim}[numbers=left,xleftmargin=5mm]
x = np.linspace(0, 2, 100)  # Sample data.

plt.figure(figsize=(5, 2.7), layout='constrained')
plt.plot(x, x, label='linear')  # Plot some data on the (implicit) Axes.
plt.plot(x, x**2, label='quadratic')  # etc.
plt.plot(x, x**3, label='cubic')
plt.xlabel('x label')
plt.ylabel('y label')
plt.title("Simple Plot")
plt.legend()
\end{Verbatim}
In addition, there is a 3rd approach, for the case when embedding {\tt matplotlib} in a GUI application, which completely drops {\tt pyplot}, even for figure creation, see \href{https://matplotlib.org/stable/gallery/user_interfaces/index.html#user-interfaces}{embedding matplotlib in graphical user interfaces}.

-- Ngoài ra, còn có cách tiếp cận thứ 3, dành cho trường hợp nhúng {\tt matplotlib} vào ứng dụng GUI, cách này loại bỏ hoàn toàn {\tt pyplot}, ngay cả khi tạo hình, hãy xem nhúng matplotlib vào giao diện người dùng đồ họa.

\begin{remark}
    The approach using the {\tt pylab} interface, via {\tt from pylab import *} is strongly deprecated.
\end{remark}

%------------------------------------------------------------------------------%

\subsection{Making a helper functions -- Tạo các hàm giúp đỡ}
If you need to make the same plots over \& over again with different data sets, or want to easily wrap {\tt matplotlib} methods, use the recommended signature function.
\begin{Verbatim}[numbers=left,xleftmargin=5mm]
def my_plotter(ax, data1, data2, param_dict):
    """
    A helper function to make a graph.
    """
    out = ax.plot(data1, data2, **param_dict)
    return out
\end{Verbatim}
which you would then use twice to populate 2 subplots:
\begin{Verbatim}[numbers=left,xleftmargin=5mm]
data1, data2, data3, data4 = np.random.randn(4, 100)  # make 4 random data sets
fig, (ax1, ax2) = plt.subplots(1, 2, figsize=(5, 2.7))
my_plotter(ax1, data1, data2, {'marker': 'x'})
my_plotter(ax2, data3, data4, {'marker': 'o'})
\end{Verbatim}

%------------------------------------------------------------------------------%

\section{Miscellaneous}

\begin{enumerate}
	\item Install Anaconda for Python: \url{https://www.anaconda.com/}.
\end{enumerate}

%------------------------------------------------------------------------------%

\printbibliography[heading=bibintoc]
	
\end{document}