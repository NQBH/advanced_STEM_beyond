\documentclass{article}
\usepackage[backend=biber,natbib=true,style=alphabetic,maxbibnames=50]{biblatex}
\addbibresource{/home/nqbh/reference/bib.bib}
\usepackage[utf8]{vietnam}
\usepackage{tocloft}
\renewcommand{\cftsecleader}{\cftdotfill{\cftdotsep}}
\usepackage[colorlinks=true,linkcolor=blue,urlcolor=red,citecolor=magenta]{hyperref}
\usepackage{amsmath,amssymb,amsthm,enumitem,float,graphicx,mathtools,tikz}
\usetikzlibrary{angles,calc,intersections,matrix,patterns,quotes,shadings}
\allowdisplaybreaks
\newtheorem{assumption}{Assumption}
\newtheorem{baitoan}{}
\newtheorem{cauhoi}{Câu hỏi}
\newtheorem{conjecture}{Conjecture}
\newtheorem{corollary}{Corollary}
\newtheorem{dangtoan}{Dạng toán}
\newtheorem{definition}{Definition}
\newtheorem{dinhly}{Định lý}
\newtheorem{dinhnghia}{Định nghĩa}
\newtheorem{example}{Example}
\newtheorem{ghichu}{Ghi chú}
\newtheorem{hequa}{Hệ quả}
\newtheorem{hypothesis}{Hypothesis}
\newtheorem{lemma}{Lemma}
\newtheorem{luuy}{Lưu ý}
\newtheorem{nhanxet}{Nhận xét}
\newtheorem{notation}{Notation}
\newtheorem{note}{Note}
\newtheorem{principle}{Principle}
\newtheorem{problem}{Problem}
\newtheorem{proposition}{Proposition}
\newtheorem{question}{Question}
\newtheorem{remark}{Remark}
\newtheorem{theorem}{Theorem}
\newtheorem{vidu}{Ví dụ}
\usepackage[left=1cm,right=1cm,top=5mm,bottom=5mm,footskip=4mm]{geometry}
\def\labelitemii{$\circ$}
\DeclareRobustCommand{\divby}{%
	\mathrel{\vbox{\baselineskip.65ex\lineskiplimit0pt\hbox{.}\hbox{.}\hbox{.}}}%
}
\setlist[itemize]{leftmargin=*}
\setlist[enumerate]{leftmargin=*}

\title{Olympic Tin Học Sinh Viên OLP \& ACM-ICPC}
\author{Nguyễn Quản Bá Hồng\footnote{A Scientist {\it\&} Creative Artist Wannabe. Website: \url{https://nqbh.github.io}. GitHub: \url{https://github.com/NQBH}.\\E-mail: {\sf nguyenquanbahong@gmail.com, hong.nguyenquanba@umt.edu.vn}. Bến Tre \& Hồ Chí Minh Cities, Việt Nam.}}
\date{\today}

\begin{document}
\maketitle
\begin{abstract}
	This text is a part of the series {\it Some Topics in Advanced STEM \& Beyond}:
	
	{\sc url}: \url{https://nqbh.github.io/advanced_STEM/}.
	
	Latest version:
	\begin{itemize}
		\item {\it Olympic Tin Học Sinh Viên OLP \& ICPC}.
		
		PDF: {\sc url}: \url{https://github.com/NQBH/advanced_STEM_beyond/blob/main/OLP_ICPC/NQBH_OLP_ICPC.pdf}.
		
		\TeX: {\sc url}: \url{https://github.com/NQBH/advanced_STEM_beyond/blob/main/OLP_ICPC/NQBH_OLP_ICPC.tex}.
		\item Codes:
		\begin{itemize}
			\item C: \url{https://github.com/NQBH/advanced_STEM_beyond/tree/main/OLP_ICPC/C}.
			\item C++: \url{https://github.com/NQBH/advanced_STEM_beyond/tree/main/OLP_ICPC/C++}.
			\item Python: \url{https://github.com/NQBH/advanced_STEM_beyond/tree/main/OLP_ICPC/Python}.
		\end{itemize}
	\end{itemize}
\end{abstract}
\tableofcontents

%------------------------------------------------------------------------------%

\section{Basic Competitive Programming -- Lập Trình Thi Đấu Cơ Bản}
\textbf{\textsf{Resources -- Tài nguyên.}}
\begin{enumerate}
	\item \cite{Laaksonen2020}. {\sc Antti Laaksonen}. {\it Guide to Competitive Programming: Learning \& Improving Algorithms Through Contests}.
	\item \cite{Thu_Phuong_Tien_Triet_NMLT}. {\sc Trần Đan Thư, Nguyễn Thanh Phương, Đinh Bá Tiến, Trần Minh Triết}. {\it Nhập Môn Lập Trình}.
	\item \cite{Thu_Phuong_Tien_Triet_Phuong_KTLT}. {\sc Trần Đan Thư, Nguyễn Thanh Phương, Đinh Bá Tiến, Trần Minh Triết, Đặng Bình Phương}. {\it Kỹ Thuật Lập Trình}.
	\item \cite{Thu_Tien_Khang_PPLTHDT}. {\sc Trần Đan Thư, Đinh Bá Tiến, Nguyễn Tấn Trần Minh Khang}. {\it Phương Pháp Lập Trình Hướng Đối Tượng}.
\end{enumerate}

\subsection{The art of handling inputs \& formatting outputs -- Nghệ thuật xử lý các dạng đầu vào \& định dạng các dạng đầu ra}
To handle various types of inputs \& format various types of outputs, see, e.g.:
\begin{itemize}
	\item \href{http://poj.org/faq.htm}{Peking University Judge Online for ACM{\tt/}ICPC (POJ){\tt/}FAQ}.
	See, e.g., \cite[Chap. 2, Subsect. 2.1.1, pp. 10--11]{Laaksonen2020, Laaksonen2024}.
\end{itemize}
To compile a C++ program in Linux, run in Terminal:
\begin{verbatim}
$ g++ -O2 -Wall program_name.cpp -o program_name
$ ./program_name
\end{verbatim}
or if you want to transfer input file into it \& print output into Terminal screen:
\begin{verbatim}
$ ./program_name < program_name.inp
\end{verbatim}
or if you want to transfer input file into it \& print output into a file:
\begin{verbatim}
$ ./program_name < program_name.inp > program_name.out
\end{verbatim}

\begin{itemize}
	\item Geeks4Geeks{\tt/std::endl} vs. \verb|\n| in C++: \url{https://www.geeksforgeeks.org/endl-vs-n-in-cpp/}. 
	\item {\tt i++} vs. {\tt++i}: \href{https://stackoverflow.com/questions/24886/is-there-a-performance-difference-between-i-and-i-in-c}{StackOverflow{\tt/}Is there a performance difference between i++ \& ++i in C?}
\end{itemize}

\subsection{Repeat{\tt/}Loop -- Lặp}

\subsection{String data -- Kiểu dữ liệu chuỗi}

%------------------------------------------------------------------------------%

\subsection{Array data -- Kiểu dữ liệu mảng}
Về mặt toán học, kiểu dữ liệu mảng là dãy số hữu hạn $(a_i)_{i=1}^n = (a_1,a_2,\ldots,a_n)$. Về mặt Tin học, kiểu dữ liệu mảng được ký hiệu bởi {\tt a[1..n]}.

\begin{baitoan}[\cite{Duc_200_BT_Python}, 141., pp. 140--141: Count digit -- Đếm chữ số]
	Cho dãy số $n$ số nguyên dương $A[1..n]$ \& 1 chữ số $k$. Đếm số lần xuất hiện chữ số $k$ trong dãy $A$ đã cho. E.g., với dãy $A[] = (11,12,13,14,15)$, thì chữ số $k = 1$ xuất hiện $6$ lần trong dãy $A$.
	\item {\sf Input.} Dòng đầu tiên của đầu vào chứa số nguyên $T\in\mathbb{N}^\star$ cho biết số bộ dữ liệu cần kiểm tra. Mỗi bộ dữ liệu gồm: (i) Dòng đầu chứa lần lượt $n,k\in\mathbb{N}$ là số phần tử trong dãy $A[]$ \& chữ số $k$. (ii) Dòng thứ 2 chứa $n$ số nguyên cách nhau 1 dấu cách, mô tả các phần tử của dãy $A$.
	\item {\sf Output.} Ứng với mỗi bộ dữ liệu, in ra 1 dòng chứa kết quả của bài toán tương ứng với bộ dữ liệu đầu vào đó.
	\item {\sf Constraint.} $1\le T\le100,1\le n\le100,0\le k\le9,1\le A[i]\le1000$, $\forall i = 1,\ldots,n$.
\end{baitoan}

\begin{itemize}
	\item Input: \url{https://github.com/NQBH/advanced_STEM_beyond/blob/main/OLP_ICPC/input/count_digit.inp}.
	\item Output: \url{https://github.com/NQBH/advanced_STEM_beyond/blob/main/OLP_ICPC/output/count_digit.out}.
	\item Python: \url{https://github.com/NQBH/advanced_STEM_beyond/blob/main/OLP_ICPC/Python/count_digit.py}.
	\item C++: ?
\end{itemize}

\begin{baitoan}[\cite{Duc_200_BT_Python}, 141., pp. 140--141: Count digit -- Đếm chữ số]
	Cho dãy số nguyên $a[1],a[2],\ldots,a[n]$. Thực hiện nhiệm vụ: Chia dãy thành 2 phần trái \& phải, trong đó phần trái gồm $\frac{n}{2}$ phần tử đầu tiên \& phần phải gồm các phần tử còn lại. Tính tổng các phần tử của mỗi phần, cuối cùng tính \& in ra tích 2 tổng tìm được.
	\item {\sf Input.} Dòng đầu tiên của đầu vào chứa $t\in\mathbb{N}^\star$ cho biết số bộ dữ liệu cần kiểm tra. Mỗi bộ dữ liệu gồm: (i) Dòng đầu chứa $n\in\mathbb{N}^\star$ cho biết số phần tử của dãy. (ii) Dòng 2 chứa $n$ số nguyên cách nhau bởi dấu cách, là các phần tử của dãy.
	\item {\sf Output.} Ứng với mỗi bộ dữ liệu, in ra 1 dong chứa kết quả của bài toán tương ứng với bộ dữ liệu đầu vào đó.
	\item {\sf Constraint.} $1\le t\le100,1\le n\le100,1\le A[i]\le100$, $\forall i = 1,\ldots,n$.
\end{baitoan}

\begin{itemize}
	\item Input: \url{https://github.com/NQBH/advanced_STEM_beyond/blob/main/OLP_ICPC/input/prod_left_right_sums.inp}.
	\item Output: \url{https://github.com/NQBH/advanced_STEM_beyond/blob/main/OLP_ICPC/output/prod_left_right_sums.out}.
	\item Python: \url{https://github.com/NQBH/advanced_STEM_beyond/blob/main/OLP_ICPC/Python/prod_left_right_sums.py}.
	\item C++: ?
\end{itemize}

%------------------------------------------------------------------------------%

\section{Olympic Tin THCS \& THPT}

\begin{baitoan}[\cite{Trung_HSG_THPT_Tin}, HSG12 Tp. Hà Nội 2020--2021, Prob. 1, p. 80: Find mid -- Tìm giữa]
	(a) Cho $l,r\in\mathbb{N}^\star$. Tìm $m\in[l,r)\cap\mathbb{N}^\star$ để chênh lệch giữa tổng các số nguyên liên tiếp từ $l$ đến $m$ \& tổng các số nguyên liên tiếp từ $m + 1$ đến $r$ là nhỏ nhất. (b) Mở rộng cho $l,r\in\mathbb{Z}$. (c$\star$) Thay tổng bởi tổng bình phương, tổng lập phương, tổng lũy thừa bậc $a\in\mathbb{R}$.
	\item {\sf Input.} 2 số $l,r\in\mathbb{N}^\star$, $l < r\le10^9$.
	\item {\sf Output.} Gồm 1 số nguyên duy nhất là $m$ thỏa mãn.
	\item {\sf Limits.} Subtask 1: $60\%$ các test có $l < r\le10^3$. Subtask 2: $40\%$ các test còn lại có $l < r\le10^9$.
\end{baitoan}

\begin{itemize}
	\item Input: \url{https://github.com/NQBH/advanced_STEM_beyond/blob/main/OLP_ICPC/input/find_mid.inp}.
	\item Output: 
	\item C++: \url{https://github.com/NQBH/advanced_STEM_beyond/blob/main/OLP_ICPC/C++/find_mid.cpp}.
	\item Python: \url{https://github.com/NQBH/advanced_STEM_beyond/blob/main/OLP_ICPC/Python/find_mid.py}.
\end{itemize}

%------------------------------------------------------------------------------%

\section{VNOI}

\begin{baitoan}[gcd in Pascal triangle -- ƯCLN trong tam giác Pascal, \url{https://oj.vnoi.info/problem/gpt}]
	Tam giác Pascal là 1 cách sắp xếp hình học của các hệ số nhị thức vào 1 tam giác. Hàng thứ $n\in\mathbb{N}$ của tam giác bao gồm các hệ số trong khai triển của đa thức $f(x,y) = (x + y)^n$. I.e., phần tử tại cột thứ $k$, hàng thứ $n$ của tam giác Pascal là $C_n^k = \binom{n}{k}$, i.e., tổ hợp chập $k$ của $n$ phần tử $0\le k\le n$. Cho $n\in\mathbb{N}$. Tính ${\rm GPT}(n)$ là ƯCLN của các số nằm giữa 2 số 1 trên hàng thứ $n$ của tam giác Pascal.
	\item {\sf Input.} Dòng đầu ghi $T$ là số lượng test. $T$ dòng tiếp theo, mỗi dòng ghi 1 số nguyên $n$.
	\item {\sf Output.} Gồm $T$ dòng, mỗi dòng ghi ${\rm GPT}(n)$ tương ứng.
	\item {\sf Constraint.} $1\le T\le20$, $2\le n\le10^9$.
\end{baitoan}
{\it Phân tích.} Công thức khai triển nhị thức Newton: $(a + b)^n = \sum_{i=0}^n C_n^ia^{n-i}b^i$, $\forall n\in\mathbb{N}$, see, e.g., \href{https://en.wikipedia.org/wiki/Binomial_theorem}{Wikipedia{\tt/}binomial theorem}. Cần tính $\gcd(\{C_n^i;1\le i\le n - 1\}) = \gcd(C_n^1,C_n^2,\ldots,C_n^{n-1})$. Chú ý mỗi hàng của tam giác Pascal có tính chất đối xứng nên chỉ cần xét ``1 nửa'' là đủ. Cụ thể hơn: $C_n^k = C_n^{n-k}$, $\forall k\in\mathbb{N}$, $k\le n$, nên
\begin{equation*}
	\{C_n^1,\ldots,C_n^{n-1}\} = \{C_n^1,\ldots,C_n^{\lfloor\frac{n}{2}\rfloor}\} = \left\{\begin{split}
		&\{C_n^1,\ldots,C_n^{\frac{n-1}{2}}\}&&\mbox{if } n\not{\divby}\ 2,\\
		&\{C_n^1,\ldots,C_n^{\frac{n}{2}}\}&&\mbox{if } n\divby2,
	\end{split}\right.
\end{equation*}
nên thay vì xét $i = 1,\ldots,n-1$, chỉ cần xét $i = 1,\ldots,\lfloor\frac{n}{2}\rfloor$ là đủ.

\begin{theorem}
	\begin{equation*}
		\gcd\{C_n^i\}_{i=1}^{n-1} = \left\{\begin{split}
			&p&&\mbox{if } n = p^k\mbox{ for some prime } p\mbox{ \& some } n\in\mathbb{N}^\star,\\
			&1&&\mbox{if } n\ne p^k\mbox{ for all prime } p\mbox{ \& any } n\in\mathbb{N}^\star.
		\end{split}\right.
	\end{equation*}
\end{theorem}
See also, e.g.:
\begin{itemize}
	\item \href{https://math.stackexchange.com/questions/2067235/gcd-of-binomial-coefficients}{Mathematics StackExchange{\tt/}gcd of binomial coefficients}.
\end{itemize}

%------------------------------------------------------------------------------%

\section{Recurrence Relation -- Quan Hệ Hồi Quy}
\textbf{\textsf{Resources -- Tài nguyên.}}
\begin{enumerate}
	\item \cite{Andrica_Bagdasar2020}. {\sc Dorin Andrica, Ovidiu Bagdasar}. {\it Recurrent Sequences: Key Results, Applications, \& Problems}.
\end{enumerate}
Let $X$ be an arbitrary set. A function $f:\mathbb{N}\to X$ defines a {\it sequence} $(x_n)_{n=0}^\infty$ of elements of $X$, where $x_n = f(n)$, $\forall n\in\mathbb{N}$. The set of all sequences with elements in $X$ is denoted by $X^\mathbb{N}$, while $X^n$ denotes Cartesian product of $n$ copies of $X$, where $X$ will be chosen as $\mathbb{C}$, the Euclidean space $\mathbb{R}^m$, the algebra $M_r(A)$ of the $r\times r$ matrices with entries in a ring $A$, etc. The set $X^\mathbb{N}$ has numerous important subsets. E.g., when $X = \mathbb{R}$, the set of real numbers $\mathbb{R}^\mathbb{N}$ includes sequences which are bounded, monotonous, convergent, positive, nonzero, periodic, etc.

-- Cho $X$ là 1 tập hợp tùy ý. Một hàm $f:\mathbb{N}\to X$ định nghĩa một {\it dãy} $(x_n)_{n=0}^\infty$ các phần tử của $X$, trong đó $x_n = f(n)$, $\forall n\in\mathbb{N}$. Tập hợp tất cả các dãy có các phần tử trong $X$ được ký hiệu là $X^\mathbb{N}$, trong khi $X^n$ biểu thị tích Descartes của $n$ bản sao của $X$, trong đó $X$ sẽ được chọn là $\mathbb{C}$, không gian Euclidean $\mathbb{R}^m$, đại số $M_r(A)$ của các ma trận $r\times r$ có các phần tử trong vành $A$, v.v. Tập hợp $X^\mathbb{N}$ có nhiều tập con quan trọng. Ví dụ, khi $X = \mathbb{R}$, tập hợp các số thực $\mathbb{R}^\mathbb{N}$ bao gồm các dãy số bị chặn, đơn điệu, hội tụ, dương, khác không, tuần hoàn, v.v.

When $a\in X$ is fixed, in {\it implicit form}, a recurrence relation is defined by
\begin{equation}
	\label{recurrence relation: implicit form}
	F_n(x_n,x_{n-1},\ldots,x_0) = a,\ \forall n\in\mathbb{N}^\star,
\end{equation}
where $F_n:X^{n+1}\to X$ is a function of $n + 1$ variables, $n\in\mathbb{N}^\star$. In general, the implicit form of a recurrence relation does not define uniquely the sequence $(x_n)_{n=0}^\infty$.

The {\it explicit form} of a recurrence relation is
\begin{equation}
	\label{recurrence relation: explicit form}
	x_n = f_n(x_{n-1},\ldots,x_0),\ \forall n\in\mathbb{N}^\star,
\end{equation}
where $f_n:X^n\to X$ is a function, $\forall n\in\mathbb{N}^\star$. The relations \eqref{recurrence relation: explicit form} give the rule to construct the term $x_n$ of the sequence $(x_n)_{n\ge0}$ from the 1st term $x_0$: $x_1 = f_1(x_0),x_2 = f_2(x_1,x_0),\ldots$, i.e., \eqref{recurrence relation: explicit form} is a functional type relation.

In mathematics, a {\it recurrence relation} is an equation according to which the $n$th term of a sequence of numbers is equal to some combination of the previous terms, i.e.:
\begin{equation}
	\label{explicit recurrent sequence 0}
	\left\{\begin{split}
		u_0&\in\mathbb{F},\\
		u_n &= f_n(n,u_0,u_1,\ldots,u_{n-1}),\ \forall n\in\mathbb{N}^\star,
	\end{split}\right.
\end{equation}
if $u_0$ is the initial element, which is an element of the given field $\mathbb{F}$, of the sequence $\{u_n\}_{n=0}^\infty$, where $f_n:\mathbb{N}^\star\times\mathbb{F}^n\to\mathbb{F}$ is a scalar-valued function of $(n + 1)$-dimensional-vector-valued argument, $\forall n\in\mathbb{N}^\star$; \&
\begin{equation}
	\label{explicit recurrent sequence 1}
	\left\{\begin{split}
		u_1&\in\mathbb{F},\\
		u_n &= f_n(n,u_1,\ldots,u_{n-1}),\ \forall n\in\mathbb{N},\ n\ge2,
	\end{split}\right.
\end{equation}
if $u_1$ is the initial element, which is an element of the given field $\mathbb{F}$, of the sequence $\{u_n\}_{n=1}^\infty$, where $f_n:\mathbb{N}_{\ge2}\times\mathbb{F}^{n-1}\to\mathbb{F}$ is a scalar-valued function of $n$-dimensional-vector-valued argument, $\forall n\in\mathbb{N}$, $n\ge2$.

\begin{question}
	What define uniquely \eqref{explicit recurrent sequence 0}?
\end{question}

\begin{proof}[Answer]
	The solutions $\{u_n\}_{n=0}^\infty$ defined by \eqref{explicit recurrent sequence 0}, are uniquely determined in terms of $u_0\in\mathbb{F},\{f_n\}_{n=1}^\infty$. Analogously, the solutions $\{u_n\}_{n=0}^\infty$ defined by \eqref{explicit recurrent sequence 1}, are uniquely determined in terms of $u_1\in\mathbb{F},\{f_n\}_{n=2}^\infty$.
\end{proof}

\begin{remark}[Starting index of a sequence]
	The starting index of a sequence $\{u_n\}_{n\in\{0,1\}}^\infty$ can be $0$, which is commonly used in Computer Science \& various programming languages, or $1$, which is commonly used in Mathematics.
\end{remark}
Often, only $k$ previous terms of the sequence appear in the equation, for a parameter $k$ that is independent of $n$; this number $k$ is called the {\it order} of the relation. If the values of the 1st $k$ numbers in the sequence have been given, the rest of the sequence can be calculated by repeatedly applying the equation.

In {\it linear recurrences}, the $n$th term is equated to a \href{https://en.wikipedia.org/wiki/Linear_function}{linear function} of the $k$ previous terms. A famous example is the recurrence for the \href{https://en.wikipedia.org/wiki/Fibonacci_number}{Fibonacci numbers}
\begin{equation}
	\label{Fibonacci sequence}
	\tag{Fib}
	\left\{\begin{split}
		F_0 & = F_1 = 1,\\
		F_n &= F_{n-1} + F_{n-2},\ \forall n\in\mathbb{N},\,n\ge2,
	\end{split}\right.
\end{equation}
where the order $k = 2$ \& the linear function merely adds the 2 previous terms. This example is a \href{https://en.wikipedia.org/wiki/Linear_recurrence_with_constant_coefficients}{linear recurrence with constant coefficients}, because the coefficients of the linear function (1 \& 1) are constants that do not depend on $n$. For these recurrences, one can express the general term of the sequence as a \href{https://en.wikipedia.org/wiki/Closed-form_expression}{closed-form expression} of $n$. \href{https://en.wikipedia.org/wiki/P-recursive_equation}{Linear recurrences with polynomial coefficients} depending on $n$ are also important, because many common \href{https://en.wikipedia.org/wiki/Elementary_functions}[elementary functions] \& \href{https://en.wikipedia.org/wiki/Special_functions}{special functions} have a \href{https://en.wikipedia.org/wiki/Taylor_series}{Taylor series} whose coefficients satisfy such a recurrence relation (see \href{https://en.wikipedia.org/wiki/Holonomic_function}{Wikipedia{\tt/}holonomic function}).

Def: Solving a recurrence relation means obtaining a \href{https://en.wikipedia.org/wiki/Closed-form_solution}{closed-form solution}: a non-recursive function of $n$.

The concept of a recurrence relation can be extended to \href{https://en.wikipedia.org/wiki/Multidimensional_array}{multidimensional arrays}, i.e., \href{https://en.wikipedia.org/wiki/Indexed_families}{indexed families} that are indexed by \href{https://en.wikipedia.org/wiki/Tuple}{tuples} of naturals.

\begin{definition}[Recurrence relation]
	A \emph{recurrence relation} is an equation that expresses each element of a sequence as a function of preceding ones. More precisely, in the case where only the immediately preceding element is involved, a {\rm1st order recurrence relation} has the form
	\begin{equation}
		\label{1st order recurrence relation}
		\boxed{\left\{\begin{split}
			u_0&\in X,\\
			u_n &= \varphi(n,u_{n-1}),\ \forall n\in\mathbb{N}^\star,
		\end{split}\right.}		
	\end{equation}
	where $\varphi:\mathbb{N}\times X\to X$ is a function, where $X$ is a set to which the elements of a sequence must belong. For any $u_0\in X$, this defines a unique sequence with $u_0$ as its 1st element, called the {\rm initial value}, which is easy to modify the definition for getting sequences starting from the term of index $1$ or higher.
	
	A {\rm recurrence relation of order $k\in\mathbb{N}^\star$} has the form
	\begin{equation}
		\label{kth order recurrence relation}
		\boxed{\left\{\begin{split}
			u_0,u_1,\ldots,u_{k-1}&\in X,\\
			u_n &= \varphi(n,k,u_{n-1},u_{n-2},\ldots,u_{n-k}),\ \forall n\in\mathbb{N},\,n\ge k,
		\end{split}\right.}
	\end{equation}
	where $\varphi:\mathbb{N}^2\times X^k\to X$ is a function that involves $k$ consecutive elements of the sequence. In this case, $k$ initial values are needed for defining a sequence.
\end{definition}

\begin{remark}[Explicit- vs. implicit recurrence relations]
	The explicit recurrence relations are the recurrence relations that can be given as \eqref{explicit recurrent sequence 0} or \eqref{explicit recurrent sequence 1}; meanwhile the implicit recurrence relations are the recurrence relations that can be given as
	\begin{equation}
		\label{implicit recurrent sequence 0}
		\left\{\begin{split}
			u_0&\in\mathbb{F},\\
			f_n(n,u_0,u_1,\ldots,u_{n-1},u_n) &= 0,\ \forall n\in\mathbb{N}^\star,
		\end{split}\right.
	\end{equation}
	if $u_0$ is the initial element, which is an element of the given field $\mathbb{F}$, of the sequence $\{u_n\}_{n=0}^\infty$, where $f_n:\mathbb{N}^\star\times\mathbb{F}^{n+1}\to\mathbb{F}$ is a scalar-valued function of $(n + 1)$-dimensional-vector-valued argument, $\forall n\in\mathbb{N}^\star$; \&
	\begin{equation}
		\label{implicit recurrent sequence 1}
		\left\{\begin{split}
			u_1&\in\mathbb{F},\\
			f_n(n,u_1,\ldots,u_{n-1},u_n) &= 0,\ \forall n\in\mathbb{N},\ n\ge2,
		\end{split}\right.
	\end{equation}
	if $u_1$ is the initial element, which is an element of the given field $\mathbb{F}$, of the sequence $\{u_n\}_{n=1}^\infty$, where $f_n:\mathbb{N}_{\ge2}\times\mathbb{F}^n\to\mathbb{F}$ is a scalar-valued function of $n$-dimensional-vector-valued argument, $\forall n\in\mathbb{N}$, $n\ge2$. The wellposednesses of \eqref{implicit recurrent sequence 0} \& \eqref{implicit recurrent sequence 1} require that the corresponding recurrent equation has a unique solution to be able to define $u_n$ uniquely.
\end{remark}

\begin{example}[Factorial]
	The \href{https://en.wikipedia.org/wiki/Factorial}{factorial} is defined by the recurrence relation $n! = n\cdot(n - 1)!$, which is \eqref{1st order recurrence relation} with $X = \mathbb{N}^\star$, $u_0 = 0! = 1$, $\varphi(x,y) = xy$, $\forall x,y\in X = \mathbb{N}^\star$ so that $u_n = \varphi(n,u_{n-1}) = nu_{n-1} = n(n - 1)! = n!$, $\forall n\in\mathbb{N}^\star$. This is an example of a {\rm linear recurrence with polynomial coefficients} of order $1$, with the simple polynomial (in $n$) $n$ as its only coefficient.
\end{example}

\begin{example}[Logistic map]
	An example of a recurrence relation is the \href{https://en.wikipedia.org/wiki/Logistic_map}{logistic map} defined by
	\begin{equation}
		\label{logistic map}
		\tag{lgt}
		\left\{\begin{split}
			x_0&\in\mathbb{R},\\
			x_{n+1} &= rx_n(1 - x_n),
		\end{split}\right.
	\end{equation}
	for a given constant $r$. The behavior of the sequence depends dramatically on $r$, but is stable when the initial condition $x_0$ varies (proofs?)
\end{example}

%------------------------------------------------------------------------------%

\subsection{Linear recurrence with constant coefficients -- Hồi quy tuyến tính với hệ số hằng}
See, e.g., \href{https://en.wikipedia.org/wiki/Linear_recurrence_with_constant_coefficients}{Wikipedia{\tt/}linear recurrence with constant coefficients}. In mathematics (including combinatorics, linear algebra, \& \href{https://en.wikipedia.org/wiki/Dynamical_systems}{dynamical system}), a {\it linear recurrence with constant coefficients} (also known as a {\it linear recurrence relation} or {\it linear difference equation}) sets equal to 0 a \href{https://en.wikipedia.org/wiki/Polynomial}{polynomial} that is linear in the various iterates of a variable -- i.e., in the values of the elements of a sequence. The polynomial's linearity means that each of its terms has degree 0 or 1. A linear recurrence denotes the evolution of some variable over time, with the current \href{https://en.wikipedia.org/wiki/Discrete_time}{time period} or discrete moment in time denoted as $t$, 1 period earlier denoted as $t - 1$, 1 period later as $t + 1$, etc.

The \href{https://en.wikipedia.org/wiki/Equation_solving}{solution} of such an equation is a function of $t$, \& not of any iterate values, giving the value of the iterate at any time. To find the solution, it is necessary to know the specific values (known as \href{https://en.wikipedia.org/wiki/Initial_condition}{\it initial conditions}) of $n$ of the iterates, \& normally these are the $n$ iterates that are oldest. The equation or its variable is said to be \href{https://en.wikipedia.org/wiki/Lyapunov_stability#Definition_for_discrete-time_systems}{\it stable} if from any set of initial conditions the variable's limit as time goes to $\infty$ exists; this limit is called the \href{https://en.wikipedia.org/wiki/Steady_state}{\it steady state}.

Difference equations are used in a variety of contexts, e.g. in \href{https://en.wikipedia.org/wiki/Economics}{economics} to model the evolution through time of variables e.g. \href{https://en.wikipedia.org/wiki/Gross_domestic_product}{gross domestic product}, the \href{https://en.wikipedia.org/wiki/Inflation_rate}{inflation rate}, the \href{https://en.wikipedia.org/wiki/Exchange_rate}{exchange rate}, etc. They are used in modeling such \href{https://en.wikipedia.org/wiki/Time_series}{time series} because values of these variables are only measured at discrete intervals. In \href{https://en.wikipedia.org/wiki/Econometrics}{econometric} applications, linear difference equations are modeled with \href{https://en.wikipedia.org/wiki/Stochastic_process}{stochastic terms} in the form of \href{https://en.wikipedia.org/wiki/Autoregressive_model}{autoregressive (AR) models} \& in models e.g. \href{https://en.wikipedia.org/wiki/Vector_autoregression}{vector autoregression} (VAR) \& \href{https://en.wikipedia.org/wiki/Autoregressive_moving_average}{autoregressive moving average} (ARMA) models that combine AR with other features.

\begin{definition}[Linear recurrence with constant coefficients]
	A {\rm linear recurrence with constant coefficients} is an equation of the following form, written in terms of parameters $a_1,\ldots,a_n,b$:
	\begin{equation}
		\label{linear recurrence with constant coefficients}
		y_n = \sum_{i=1}^k a_iy_{n-i} + b,
	\end{equation}
	or equivalently as
	\begin{equation}
		\label{linear recurrence with constant coefficients 1}
		y_{n + k} = \sum_{i=1}^n a_iy_{n + k - i} + b,
	\end{equation}
\end{definition}

%------------------------------------------------------------------------------%

\section{CSES Problem Set}
Link: \url{https://cses.fi/problemset/}.

\subsection{Introductory Problems}

\begin{problem}[CSES]
	There are $n$ concert tickets available, each with a certain price. Then, $m$ customers arrive, one after another. Each customer announces the maximum price they are willing to pay for a ticket, \& after this, they will get a ticket with nearest possible price such that it does not exceed the maximum price.
	\item {\sf Input.} 1st input line contains $n,m\in\mathbb{N}$: number of tickets \& number of customers. The next line contains $n$ integers $h_1,h_2,\ldots,h_n$: the price of each ticket. The last line contains $m$ integers $t_1,t_2,\ldots,t_m$: the maximum price for each customer in the order they arrive.
	\item {\sf Output.} Print, for each customer, the price that they will pay for their ticket. After this, ticket cannot be purchased again. If a customer cannot get any ticket, print $-1$.
	\item {\sf Constraints.} $1\le m,n\le 2\cdot10^5$, $1\le h_i,t_i\le10^9$.
\end{problem}

\subsection{Dynamic Programming}
\textbf{\textsf{Resources -- Tài nguyên.}}
\begin{enumerate}
	\item \cite{Bertsekas2005,Bertsekas2017}. {\sc Dimitri P. Bertsekas}. {\it Dynamic Programming \& Optimal Control. Vol. I}. 3e. 4e (can't download yet).
	\item \cite{Bertsekas2007,Bertsekas2012} {\sc Dimitri P. Bertsekas}. {\it Dynamic Programming \& Optimal Control. Vol. II}. 3e. 4e (can't download yet).
\end{enumerate}

\subsection{Graph Algorithms}

\subsection{Range Queries}

\subsection{Mathematics}

\begin{problem}[CSES{\tt/}Josephus Queries, \url{https://cses.fi/problemset/task/2164}]
	Consider a game where there are $n\in\mathbb{N}^\star$ children, numbered $1,2,\ldots,n$, in a circle. During the game, every 2nd child is removed from circle, until there are no children left. Task: process $q$ queries of the form: ``when there are $n$ children, who is the $k$th child that will be removed?''
	\begin{itemize}
		\item {\sf Input.} The 1st input line has an integer $q$: the number of queries. After this, there are $q$ lines that describe the queries. Each line has 2 integers $n,k$: the number of children \& the position of the child.
		\item {\sf Output.} Print $q$ integers: the answer for each query.
	\end{itemize}
\end{problem}
It seems to me that {\sf Jack97} (nickname: \verb|abortion_grandmaster|) proposed this problem.

Codes:
\begin{itemize}
	\item C++: \url{https://github.com/NQBH/advanced_STEM_beyond/blob/main/OLP_ICPC/C%2B%2B/gcd_Pascal_triangle.cpp}.
\end{itemize}

\begin{problem}[CSES{\tt/}Dice Probability, \url{https://cses.fi/problemset/task/1725}]
	Throw a dice $n\in\mathbb{N}^\star$ times, \& every throw produces an outcome between $1$ \& $6$. What is the probability that the sum of outcomes is between $a,b\in\mathbb{Z}$?
	\begin{itemize}
		\item {\sf Input.} The only input line contains 3 integers $n,a,b\in\mathbb{N}^\star$.
		\item {\sf Output.} Print probability rounded to 6 decimal places (rounding half to even).
		\item {\sf Constraints.} $1\le n\le100,1\le a\le b\le6n$.
		\item {\sf Example.} Input: {\tt2 9 10}. Output: {\tt0.194444}.
	\end{itemize}
\end{problem}
{\it Phân tích.} Gọi $n$ outcomes là $a_1,\ldots,a_n\in\{1,\ldots,6\}$. Sum of outcomes: $S\coloneqq\sum_{i=1}^n a_i\in\{n,\ldots,6n\}$.

\subsection{String Algorithms}

\subsection{Geometry}

\subsection{Advanced Techniques}

\subsection{Additional Problems}

%------------------------------------------------------------------------------%

\section{OLP}

%------------------------------------------------------------------------------%

\section{ICPC}

\begin{enumerate}
	\item \cite{Wu_Wang2016}. {\sc Yonghui Wu, Jiande Wang}. {\it Data Structure Practice for Collegiate Programming Contests \& Education}.
	\item \cite{Wu_Wang2018}. {\sc Yonghui Wu, Jiande Wang}. {\it Algorithm Design Practice for Collegiate Programming Contests \& Education}.
\end{enumerate}

\begin{problem}[\cite{Wu_Wang2016}, p. 4: financial management]
	{\sc Larry} graduated this year \& finally has a job. He's making a lot of money, but somehow never seems to have enough. {\sc Larry} has decided that he needs to get a hold of his financial portfolio \& solve his financial problems. The 1st step is to figure out what's been going on with his money. {\sc Larry} has his bank account statements \& wants to see how much money he has. Help {\sc Larry} by writing a program to take his closing balance from each of the past 12 months \& calculate his average account balance.
	\item {\sf Input.} The input will be 12 lines. Each line will contain the closing balance of his bank account for a particular month. Each number will be positive \& displayed to the penny. No dollar sign will be included.
	\item {\sf Output.} The output will be a single number, the average (mean) of the closing balances for the 12 months. It will be rounded to the nearest penny, preceded immediately by a dollar sign, \& followed by the end of the line. There will be no other spaces or characters in the output.
	\item {\sf Source.} ACM Mid-Atlantic United States 2001.
	\item {\sf IDs for online judges.} POJ 1004, ZOJ 1048, UVA 2362.
\end{problem}
\textbf{\textsf{Math Analysis.}} Let $(a_i)_{i=1}^{12}\subset[0,\infty)$ be monthly incomes of 12 months. Compute their average by the formula $\overline{a} = \frac{1}{12}\sum_{i=1}^{12} a_i$. This can be generalized to $n\in\mathbb{N}^\star$ months with a sequence of monthly incomes $(a_i)_{i=1}^n\subset[0,\infty)$ with its average value given by the formula $\overline{a}\coloneqq\frac{1}{n}\sum_{i=1}^n a_i$.

\textbf{\textsf{CS Analysis.}} The income of 12 months {\tt a[0..11]} is input by a {\tt for} statement \& the total income ${\tt sum}\coloneqq\sum_{i=0}^{11} a[i]$ is calculated. Then the average monthly income {\tt avg = sum/12} is calculated. Finally, {\tt avg} is output in accordance with the problem's output format by utilizing {\tt printf}'s format functionalities via \verb|printf("$%.2f", avg)|.
\begin{itemize}
	\item Input: \url{https://github.com/NQBH/advanced_STEM_beyond/blob/main/OLP_ICPC/input/financial_management.inp}.
	\item Output: \url{https://github.com/NQBH/advanced_STEM_beyond/blob/main/OLP_ICPC/output/financial_management.out}.
	\item C++: \url{https://github.com/NQBH/advanced_STEM_beyond/blob/main/OLP_ICPC/C++/financial_management.cpp}.
	\begin{verbatim}
#include <iostream>
using namespace std;
int main() {
    double avg, sum = 0.0, a[12] = {0};
    for (int i = 0; i < 12; ++i) { // input income of 12 motnhs a[0..11] & summation
        cin >> a[i];
        sum += a[i];
    }
    avg = sum/12; // compute average monthly
    printf("$%.2f", avg); // output average monthly
    return 0;
}		
	\end{verbatim}
	
	\begin{remark}[array of 0s]
		The technique \verb|a[12] = {0}| initializes an array $a$ with all zero elements.
	\end{remark}
	\item Python: \url{https://github.com/NQBH/advanced_STEM_beyond/blob/main/OLP_ICPC/Python/financial_management.py}.
	\begin{verbatim}
sum = 0
for __ in range(12):
    a = float(input())
    sum += a
print("${:.2f}".format(sum / 12))
	\end{verbatim}
\end{itemize}

\begin{baitoan}[Basic statistical data sample -- mẫu dữ liệu thống kê cơ bản]
	Cho 1 mẫu dữ liệu $(a_i)_{i=1}^n$. Tính trung bình, độ lệch chuẩn, phương sai của mẫu.
\end{baitoan}

\begin{problem}[\cite{Wu_Wang2016}, pp. 5--6: doubles]
	As part of an arithmetic competency program, your students will be given randomly generated lists of 2--15 unique positive integers \& asked to determine how many items in each list are twice some other item in same list. You will need a program to help you with the grading. This program should be able to scan the lists \& output the correct answer for each one. E.g., given the list {\tt1 4 3 2 9 7 18 22} your program should answer $3$, as $2$ is twice $1$, $4$ is twice $2$, \& $18$ is twice $9$.
	\item {\sf Input.} The input file will consist of 1 or more lists of numbers. There will be 1 list of numbers per line. Each list will contain from 2--15 unique positive integers. No integer will be $> 99$. Each line will be terminated with the integer $0$, which is not considered part of the list. A line with the single number $-1$ will mark the end of the file. Some lists may not contain any doubles.
	\item {\sf Output.} The output will consist of 1 line per input list, containing a count of the items that are double some other item.
	\item {\sf Source.} ACM Mid-Central United States 2003.
	\item {\sf IDs for online judges.} POJ 1552, ZOJ 1760, UVA 2787.
\end{problem}

\begin{remark}[Multiple test cases -- đa bộ test]
	For any problem with multiple test cases, a loop is used to deal with multiple test cases. The loop enumerates every test case.
	
	-- Đối với bất kỳ vấn đề nào có nhiều trường hợp thử nghiệm, một vòng lặp được sử dụng để xử lý nhiều trường hợp thử nghiệm. Vòng lặp liệt kê mọi trường hợp thử nghiệm.
\end{remark}

\begin{itemize}
	\item Input: \url{https://github.com/NQBH/advanced_STEM_beyond/blob/main/OLP_ICPC/input/double.inp}.
	\item Output: \url{https://github.com/NQBH/advanced_STEM_beyond/blob/main/OLP_ICPC/output/double.out}.
	\item C++:
	\begin{itemize}
		\item \url{https://github.com/NQBH/advanced_STEM_beyond/blob/main/OLP_ICPC/C++/double.cpp}.
		\begin{verbatim}
#include <iostream>
using namespace std;
int main() {
    int i, j, n, count, a[20];
    cin >> a[0]; // input 1st element
    while (a[0] != -1) { // if it is not end of input, input a new test case
        n = 1;
        for ( ; ; ++n) {
            cin >> a[n];
            if (a[n] == 0) break;
        }
        count = 0; // determine how many items in each list are twice some other item
        for (i = 0; i < n - 1; ++i) { // enumerate all pairs
            for (j = i + 1; j < n; ++j) {
                if (a[i]*2 == a[j] || a[j]*2 == a[i]) // accumulation
                    ++count;
            }
        }
        cout << count << endl; // output result
        cin >> a[0]; // input 1st element of next test case
    }
    return 0;
}
		\end{verbatim}
		\item \url{https://github.com/NQBH/advanced_STEM_beyond/blob/main/OLP_ICPC/C++/double_DPAK.cpp}: use map \& vector.
	\end{itemize} 
\end{itemize}
Bài toán có thể mở rộng từ double thành triple, multiple, or just equal.

\begin{problem}[\cite{Wu_Wang2016}, pp. 7--8: sum of consecutive prime numbers]
	Some positive integers can be represented by a sum of 1 or more consecutive prime numbers. How many such representations does a give positive integer have? E.g., the integer $53$ has 2 representations $5 + 7 + 11 + 13 + 17$ \& $53$. The integer $41$ has 3 representations: $2+ 3 + 5 + 7 + 11 + 13, 11 + 13 + 17$, \& $41$. The integer $3$ has only 1 representation, which is $3$. The integer $20$ has no such representations. Note: summands must be consecutive prime numbers, so neither $7 + 13$ nor $3 + 5 + 5 + 7$ is a valid representation for the integer $20$. Your mission is to write a program that reports the number of representations for the given positive integer.
	\item {\sf Input.} The input is a sequence of positive integers, each in a separate line. The integers are between $2$ \& $10000$, inclusive. The end of the input is indicated by a zero.
	\item {\sf Output.} The output should be composed of lines each corresponding to an input line, except the last zero. An output line includes the number of representations for the input integer as the sum of 1 or more consecutive prime numbers. No other characters should be inserted in the output.
	\item {\sf Source.} ACM Japan 2005.
	\item {\sf IDs for online judges}. POJ 2739, UVA 3399.
\end{problem}

\begin{problem}[\cite{Wu_Wang2016}, pp. 9--10: I think I need a houseboat]
	{\sc Fred Mapper} is considering purchasing some land in Louisiana to build his house on. In the process of investigating the land, he learned that the state of Louisiana is actually shrinking by $50$ square miles each year, due to erosion caused by the Mississippi River. Since {\sc Fred} is hoping to live in this house for the rest of his life, he needs to know if his land is going to be lost to erosion.
	
	After doing more research, {\sc Fred} has learned that the land that is being lost forms a semicircle. This semicircle is part of a circle centered at $(0,0)$, with the line that bisects the circle being the $x$ axis. Locations below the $x$ axis are in the water. The semicircle has an area of $0$ at the beginning of year $1$.
	\item {\sf Input.} The 1st line of input will be a positive integer indicating how many data sets will be included $N$. Each of the next $N$ lines will contain the $x,y$ Cartesian coordinates of the land {\sc Fred} is considering. These will be floating-point numbers measured in miles. The $y$ coordinate will be nonnegative. $(0,0)$ will not be given.
	\item {\sf Output.} For each data set, a single line of output should appear. This line should take the form of
	\begin{center}
		Property $N$: This property will begin eroding in year $Z$.
	\end{center}
	where $N$ is the data set (counting from $1$) \& $Z$ is the 1st year (start from $1$) this property will be within the semicircle AT THE END OF YEAR $Z$. $Z$ must be an integer. After the last data set, this should print out ``END OF OUTPUT.''
	\item {\sf Source.} ACM Mid-Atlantic United States 2001.
	\item {\sf Note.} No property will appear exactly on the semicircle boundary: it will be either inside or outside. This problem will be judged automatically. Your answer must match exactly, including the capitalization, punctuation, \& white space. This includes the periods at the ends of the lines. All locations are given in miles.
	\item {\sf IDs for online judges.} POJ 1005, ZOJ 1049, UVA 2363.
\end{problem}

\begin{problem}[\cite{Wu_Wang2016}, p. 12: Hangover]
	How far can you make a stack of cards overhang a table? If you have 1 card, you can create a maximum overhang of half a card length. (We're assuming that the cards must be perpendicular to the table.) With 2 cards, you can make the top card overhang the bottom one by half a card length, \& the bottom one overhang the table by a third of a card length, for a total maximum overhang of $\frac{1}{2} + \frac{1}{3} = \frac{5}{6}$ card lengths. In general, you can make $n$ cards overhang by $\sum_{i=2}^{n+1} \frac{1}{i} = \frac{1}{2} + \frac{1}{3} + \cdots + \frac{1}{n + 1}$ card lengths, where the top card overhangs the 2nd by $\frac{1}{2}$, the 2nd overhangs the 3rd by $\frac{1}{3}$, the 3rd overhangs the 4th by $\frac{1}{4}$, \& so on, \& the bottom card overhangs the table by $\frac{1}{n + 1}$.
	\item {\sf Input.} The input consists of 1 or more test cases, followed by a line containing the number $0.00$ that signals the end of the input. Each test case is a single line containing a positive floating-point number $c$ whose value is at least $0.01$ \& at most $5.20$; $c$ will contain exactly 3 digits.
	\item {\sf Output.} For each test case, output the minimum number of cards necessary to achieve an overhang of at least $c$ card lengths. Use the exact output format shown in the examples.
	\item {\sf Source.} ACM Mid-Central United States 2001.
	item {\sf IDs for online judges.} POJ 1003, UVA 2294.
\end{problem}

\begin{problem}[\cite{Wu_Wang2016}, p. 17: Sum]
	Your task is to find the sum of all integer numbers lying between $1$ \& $N$ inclusive.
	\item {\sf Input.} The input consists of a single integer $N$ that is not greater than $10000$ by its absolute value.
	\item {\sf Output.} Write a single integer number that is the sum of all integer numbers lying between $1$ \& $N$ inclusive.
	\item {\sf Source.} Source: ACM 2000, Northeastern European Regional Programming Contest (test tour).
	\item {\sf ID for online judge.} Ural 1068.
\end{problem}



%------------------------------------------------------------------------------%

\section{Miscellaneous}

\subsection{Contributors}

\begin{enumerate}
	\item {\sc Võ Ngọc Trâm Anh}. C++ codes.
	\item {\sc Đặng Phúc An Khang}. C++ codes.
	\begin{itemize}
		\item {\sc Đặng Phúc An Khang}. {\it Combinatorics \& Number Theory in Competitive Programming -- Tổ Hợp \& Lý Thuyết Số trong Lập Trình Thi Đấu}.
		\item {\sc Đặng Phúc An Khang}. {\it Hướng Đến Kỳ Thi Olympic Tin học Sinh Viên Toàn Quốc \& ICPC 2025}.
		
		{\sc url}: \url{https://github.com/GrootTheDeveloper/OLP-ICPC/blob/master/2025/COMPETITIVE_REPORT.pdf}.
	\end{itemize}
	\item {\sc Nguyễn Lê Anh Khoa}. C++ codes.
	\item {\sc Phan Vĩnh Tiến}. C++ codes.
\end{enumerate}

\subsection{Donate or Buy Me Coffee}
Donate (but do not donut) or buy me some coffee via NQBH's bank account information at \url{https://github.com/NQBH/publication/blob/master/bank/NQBH_bank_account_information}.

\subsection{See also}

\begin{enumerate}
	\item {\it Vietnamese Mathematical Olympiad for High School- \& College Students (VMC) -- Olympic Toán Học Học Sinh \& Sinh Viên Toàn Quốc}.
	
	PDF: {\sc url}: \url{https://github.com/NQBH/advanced_STEM_beyond/blob/main/VMC/NQBH_VMC.pdf}.
	
	\TeX: {\sc url}: \url{https://github.com/NQBH/advanced_STEM_beyond/blob/main/VMC/NQBH_VMC.tex}.
	\begin{itemize}
		\item Codes:
		\begin{itemize}
			\item C++ code: \url{https://github.com/NQBH/advanced_STEM_beyond/tree/main/VMC/C++}.
			\item Python code: \url{https://github.com/NQBH/advanced_STEM_beyond/tree/main/VMC/Python}.
		\end{itemize}
		\item Resource: \url{https://github.com/NQBH/advanced_STEM_beyond/tree/main/VMC/resource}.
		\item Figures: \url{https://github.com/NQBH/advanced_STEM_beyond/tree/main/VMC/figure}.
	\end{itemize}
\end{enumerate}

%------------------------------------------------------------------------------%

\printbibliography[heading=bibintoc]
	
\end{document}