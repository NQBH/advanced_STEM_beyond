from typing import Dict, List, Set, Tuple

# A type alias for graph representation for better readability.
# We use an adjacency list, represented by a dictionary where keys are
# 0-indexed node IDs and values are lists of their neighbors.
GraphAdjList = Dict[int, List[int]]

def read_dimacs(file_path: str) -> GraphAdjList:
    """
    Reads an undirected graph from a file in DIMACS edge format.

    This function parses a DIMACS file, adhering to its structure:
    - Ignores comment lines starting with 'c'.
    - Reads the problem line 'p edge n m' to determine graph size.
    - Parses edge lines 'e i j', converting 1-based vertex numbers to 0-based indices.
    - Since the graph is undirected, it adds an edge for both (u, v) and (v, u).

    :param file_path: The path to the DIMACS file.
    :return: The graph represented as an adjacency list dictionary.
    """
    graph: GraphAdjList = {}
    num_vertices = 0
    try:
        with open(file_path, 'r') as f:
            for line in f:
                parts = line.strip().split()
                if not parts:
                    continue
                
                line_type = parts[0]

                if line_type == 'c':
                    # Comment line, ignore.
                    continue
                elif line_type == 'p' and parts[1] == 'edge':
                    # Problem definition line: "p edge n m"
                    num_vertices = int(parts[2])
                    # Initialize the graph with empty lists for all vertices.
                    graph = {i: [] for i in range(num_vertices)}
                elif line_type == 'e':
                    # Edge descriptor line: "e i j"
                    # Convert from 1-based (DIMACS) to 0-based (Python list index).
                    u, v = int(parts[1]) - 1, int(parts[2]) - 1
                    
                    if 0 <= u < num_vertices and 0 <= v < num_vertices:
                        # Add the undirected edge.
                        graph[u].append(v)
                        graph[v].append(u)
    except FileNotFoundError:
        print(f"Error: File not found at {file_path}")
        return {}
        
    return graph

def write_dimacs(graph: GraphAdjList, file_path: str):
    """
    Writes a graph to a file in DIMACS edge format.

    This function takes an internal graph representation (adjacency list) and
    writes it to a specified file.
    - It determines the number of vertices and edges. To avoid double-counting
      edges in an undirected graph, it uses a set of canonical edges (u, v) where u < v.
    - It writes the problem line 'p edge n m'.
    - It iterates through the canonical edges and writes them as 'e i j', converting
      0-based indices back to 1-based vertex numbers.

    :param graph: The graph to write, represented as an adjacency list.
    :param file_path: The path of the output file.
    """
    num_vertices = len(graph)
    # Use a set of sorted tuples to store canonical edges (u, v) with u < v to avoid duplicates.
    edge_set: Set[Tuple[int, int]] = set()

    for u, neighbors in graph.items():
        for v in neighbors:
            if u < v: # This ensures each edge is added only once.
                edge_set.add((u, v))
    
    num_edges = len(edge_set)

    try:
        with open(file_path, 'w') as f:
            # Write header and problem definition line.
            f.write("c This file was generated by the DIMACS writer (Python)\n")
            f.write(f"c Graph has {num_vertices} vertices and {num_edges} edges.\n")
            f.write(f"p edge {num_vertices} {num_edges}\n")

            # Write edge descriptor lines, sorted for consistent output.
            for u, v in sorted(list(edge_set)):
                # Convert from 0-based index back to 1-based vertex number.
                f.write(f"e {u + 1} {v + 1}\n")
    except IOError:
        print(f"Error: Could not write to file {file_path}")

def print_graph(graph: GraphAdjList):
    """Helper function to print the graph for verification."""
    for node in sorted(graph.keys()):
        print(f"  Node {node} -> {sorted(graph[node])}")

# =================================================================================
# MAIN EXECUTION BLOCK - DEMONSTRATION FOR EXERCISE 1.1
# =================================================================================
if __name__ == "__main__":
    input_filename = "sample.dimacs"
    output_filename = "output.dimacs"

    # --- 1. Create a sample DIMACS file for the example ---
    print(f"--> Creating a sample DIMACS file named '{input_filename}'...")
    sample_content = """c This is a sample graph for a square with a diagonal
p edge 4 5
e 1 2
e 2 3
e 3 4
e 4 1
e 1 3
"""
    with open(input_filename, "w") as f:
        f.write(sample_content)
    print("--> Sample file created.\n")

    # --- 2. Read the DIMACS file ---
    print(f"--> Reading graph from '{input_filename}'...")
    my_graph = read_dimacs(input_filename)
    print("--> Graph read successfully. Internal representation:")
    print_graph(my_graph)

    # --- 3. Write the graph to a new DIMACS file ---
    print(f"\n--> Writing internal graph representation to '{output_filename}'...")
    write_dimacs(my_graph, output_filename)
    print("--> Graph written successfully.")
    print(f"(You can now check the contents of '{output_filename}')")